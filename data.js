
window.KB_DATA = {
    tree: {"Algorithms-and-Data-Structures-Python": {"01_Pure_Mathematics": {"01_Algebra": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/07_Advanced_Notes_and_Research_Directions.md"}}, "02_Linear_Algebra": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/07_Advanced_Notes_and_Research_Directions.md"}}, "03_Abstract_Algebra": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/07_Advanced_Notes_and_Research_Directions.md"}}, "04_Real_Analysis": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/07_Advanced_Notes_and_Research_Directions.md"}}, "05_Complex_Analysis": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/07_Advanced_Notes_and_Research_Directions.md"}}}}, "Python_Theory": {"01_Introduction": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/07_Practice_Questions.md"}}, "02_Basic_Syntax": {"01_Indentation_and_Comments.md": {"type": "file", "ext": ".md", "path": "Python_Theory/02_Basic_Syntax/01_Indentation_and_Comments.md"}, "02_Variables_and_Constants.md": {"type": "file", "ext": ".md", "path": "Python_Theory/02_Basic_Syntax/02_Variables_and_Constants.md"}, "03_Input_Output.md": {"type": "file", "ext": ".md", "path": "Python_Theory/02_Basic_Syntax/03_Input_Output.md"}, "04_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/02_Basic_Syntax/04_Practice_Questions.md"}}, "03_Data_Types": {"01_Overview.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/01_Overview.md"}, "02_Numbers.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/02_Numbers.md"}, "03_Booleans.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/03_Booleans.md"}, "04_Type_Conversion.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/04_Type_Conversion.md"}, "05_NoneType.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/05_NoneType.md"}, "06_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/06_Practice_Questions.md"}}, "04_Operators_and_Expressions": {"01_Arithmetic.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/01_Arithmetic.md"}, "02_Comparison_Logical.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/02_Comparison_Logical.md"}, "03_Assignment_Bitwise.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/03_Assignment_Bitwise.md"}, "04_Membership_Identity.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/04_Membership_Identity.md"}, "05_Operator_Precedence.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/05_Operator_Precedence.md"}, "06_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/06_Practice_Questions.md"}}, "05_Control_Flow": {"01_Conditional_Statements.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/01_Conditional_Statements.md"}, "02_Loops_For.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/02_Loops_For.md"}, "03_Loops_While.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/03_Loops_While.md"}, "04_Loop_Control_Statements.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/04_Loop_Control_Statements.md"}, "05_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/05_Practice_Questions.md"}}, "06_Functions": {"01_Definition_Syntax.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/01_Definition_Syntax.md"}, "02_Parameters_Arguments.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/02_Parameters_Arguments.md"}, "03_Return_Statement.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/03_Return_Statement.md"}, "04_Scope_Lifetime.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/04_Scope_Lifetime.md"}, "05_Lambda_Functions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/05_Lambda_Functions.md"}, "06_Recursion.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/06_Recursion.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/07_Practice_Questions.md"}}, "07_Modules_and_Packages": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/07_Modules_and_Packages/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/07_Modules_and_Packages/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/07_Modules_and_Packages/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/07_Modules_and_Packages/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/07_Modules_and_Packages/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/07_Modules_and_Packages/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/07_Modules_and_Packages/07_Practice_Questions.md"}}, "08_Strings": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/08_Strings/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/08_Strings/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/08_Strings/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/08_Strings/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/08_Strings/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/08_Strings/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/08_Strings/07_Practice_Questions.md"}}, "09_Lists_Tuples_Sets_Dicts": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/07_Practice_Questions.md"}}, "10_OOP_in_Python": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/10_OOP_in_Python/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/10_OOP_in_Python/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/10_OOP_in_Python/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/10_OOP_in_Python/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/10_OOP_in_Python/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/10_OOP_in_Python/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/10_OOP_in_Python/07_Practice_Questions.md"}}, "11_Error_and_Exception_Handling": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/11_Error_and_Exception_Handling/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/11_Error_and_Exception_Handling/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/11_Error_and_Exception_Handling/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/11_Error_and_Exception_Handling/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/11_Error_and_Exception_Handling/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/11_Error_and_Exception_Handling/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/11_Error_and_Exception_Handling/07_Practice_Questions.md"}}, "12_File_Handling": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/12_File_Handling/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/12_File_Handling/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/12_File_Handling/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/12_File_Handling/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/12_File_Handling/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/12_File_Handling/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/12_File_Handling/07_Practice_Questions.md"}}, "13_Iterators_and_Generators": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/13_Iterators_and_Generators/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/13_Iterators_and_Generators/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/13_Iterators_and_Generators/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/13_Iterators_and_Generators/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/13_Iterators_and_Generators/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/13_Iterators_and_Generators/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/13_Iterators_and_Generators/07_Practice_Questions.md"}}, "14_Decorators": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/14_Decorators/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/14_Decorators/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/14_Decorators/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/14_Decorators/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/14_Decorators/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/14_Decorators/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/14_Decorators/07_Practice_Questions.md"}}, "15_Comprehensions": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/15_Comprehensions/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/15_Comprehensions/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/15_Comprehensions/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/15_Comprehensions/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/15_Comprehensions/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/15_Comprehensions/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/15_Comprehensions/07_Practice_Questions.md"}}, "16_Standard_Library_Overview": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/16_Standard_Library_Overview/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/16_Standard_Library_Overview/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/16_Standard_Library_Overview/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/16_Standard_Library_Overview/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/16_Standard_Library_Overview/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/16_Standard_Library_Overview/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/16_Standard_Library_Overview/07_Practice_Questions.md"}}, "17_Advanced_Topics": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/17_Advanced_Topics/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/17_Advanced_Topics/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/17_Advanced_Topics/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/17_Advanced_Topics/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/17_Advanced_Topics/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/17_Advanced_Topics/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/17_Advanced_Topics/07_Practice_Questions.md"}}}, "nunpy": {"numpy arry indexing": {"main.py": {"type": "file", "ext": ".py", "path": "nunpy/numpy arry indexing/main.py"}}, "numpy_creating arry": {"main.py": {"type": "file", "ext": ".py", "path": "nunpy/numpy_creating arry/main.py"}}, "keypad.py": {"type": "file", "ext": ".py", "path": "nunpy/keypad.py"}, "new.py": {"type": "file", "ext": ".py", "path": "nunpy/new.py"}}, "python": {"PythonMasteryRepo": {"Algorithms": {"Advanced_Graphs": {"all_pairs_shortest_paths_floyd_warshall.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/all_pairs_shortest_paths_floyd_warshall.py"}, "articulation_points_and_bridges.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/articulation_points_and_bridges.py"}, "eulerian_and_hamiltonian_paths_basics.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/eulerian_and_hamiltonian_paths_basics.py"}, "graphs_bfs_dfs.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/graphs_bfs_dfs.py"}, "minimum_spanning_tree_kruskal.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/minimum_spanning_tree_kruskal.py"}, "minimum_spanning_tree_prim.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/minimum_spanning_tree_prim.py"}, "shortest_paths_bellman_ford.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/shortest_paths_bellman_ford.py"}, "shortest_paths_dijkstra.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/shortest_paths_dijkstra.py"}, "strongly_connected_components_kosaraju.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/strongly_connected_components_kosaraju.py"}, "strongly_connected_components_tarjan.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/strongly_connected_components_tarjan.py"}, "topological_sort_kahn_and_dfs.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/topological_sort_kahn_and_dfs.py"}}, "Backtracking": {"backtracking_n_queens.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_n_queens.py"}, "backtracking_permutations_combinations.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_permutations_combinations.py"}, "backtracking_rat_in_a_maze.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_rat_in_a_maze.py"}, "backtracking_subset_generation.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_subset_generation.py"}, "backtracking_sudoku_solver.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_sudoku_solver.py"}}, "Basics": {"recursion_basics_factorial_fibonacci.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/recursion_basics_factorial_fibonacci.py"}, "recursion_tower_of_hanoi.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/recursion_tower_of_hanoi.py"}, "searching_binary.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/searching_binary.py"}, "searching_linear.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/searching_linear.py"}, "sorting_bubble.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_bubble.py"}, "sorting_counting.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_counting.py"}, "sorting_heap.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_heap.py"}, "sorting_insertion.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_insertion.py"}, "sorting_merge.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_merge.py"}, "sorting_quick.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_quick.py"}, "sorting_radix.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_radix.py"}, "sorting_selection.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_selection.py"}}, "Bit_Manipulation_and_Math": {"bit_manipulation_basics.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/bit_manipulation_basics.py"}, "bit_tricks_and_hacks.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/bit_tricks_and_hacks.py"}, "math_catalan_numbers.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/math_catalan_numbers.py"}, "math_single_number_xor_patterns.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/math_single_number_xor_patterns.py"}}, "Dynamic_Programming": {"dp_0_1_knapsack.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_0_1_knapsack.py"}, "dp_coin_change.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_coin_change.py"}, "dp_edit_distance.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_edit_distance.py"}, "dp_longest_common_subsequence.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_longest_common_subsequence.py"}, "dp_longest_increasing_subsequence.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_longest_increasing_subsequence.py"}, "dp_matrix_chain_multiplication.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_matrix_chain_multiplication.py"}, "dp_memoization_vs_tabulation.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_memoization_vs_tabulation.py"}, "dp_subset_sum.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_subset_sum.py"}, "dp_unbounded_knapsack.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_unbounded_knapsack.py"}}, "Geometry_Algorithms": {"geometry_closest_pair_of_points.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_closest_pair_of_points.py"}, "geometry_convex_hull_graham_scan.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_convex_hull_graham_scan.py"}, "geometry_line_intersection.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_line_intersection.py"}, "geometry_point_line_basics.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_point_line_basics.py"}, "geometry_polygon_area.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_polygon_area.py"}}, "Greedy": {"greedy_activity_selection.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_activity_selection.py"}, "greedy_fractional_knapsack.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_fractional_knapsack.py"}, "greedy_huffman_coding.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_huffman_coding.py"}, "greedy_job_sequencing.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_job_sequencing.py"}}, "Intermediate_Data_Structures": {"balanced_trees_avl_intro.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/balanced_trees_avl_intro.py"}, "disjoint_set_union_find.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/disjoint_set_union_find.py"}, "hash_table_open_addressing.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/hash_table_open_addressing.py"}, "hash_table_with_collision_chaining.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/hash_table_with_collision_chaining.py"}, "heaps_min_max_operations.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/heaps_min_max_operations.py"}, "linked_list_circular.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_circular.py"}, "linked_list_doubly.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_doubly.py"}, "linked_list_singly.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_singly.py"}, "priority_queue_heapq.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/priority_queue_heapq.py"}, "queue_array_and_deque.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/queue_array_and_deque.py"}, "stack_array_and_list.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/stack_array_and_list.py"}, "trees_binary_tree_basics.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/trees_binary_tree_basics.py"}, "trees_bst_operations.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/trees_bst_operations.py"}}, "Number_Theory": {"number_theory_chinese_remainder_theorem.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_chinese_remainder_theorem.py"}, "number_theory_fast_exponentiation.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_fast_exponentiation.py"}, "number_theory_gcd_lcm_euclidean.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_gcd_lcm_euclidean.py"}, "number_theory_modular_arithmetic.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_modular_arithmetic.py"}, "number_theory_prime_factorization.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_prime_factorization.py"}, "number_theory_primes_sieve_of_eratosthenes.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_primes_sieve_of_eratosthenes.py"}}, "Paradigms_Advanced": {"branch_and_bound_tsp.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/branch_and_bound_tsp.py"}, "divide_and_conquer_strategies.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/divide_and_conquer_strategies.py"}, "local_search_simulated_annealing.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/local_search_simulated_annealing.py"}, "network_flow_edmonds_karp.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/network_flow_edmonds_karp.py"}, "network_flow_ford_fulkerson.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/network_flow_ford_fulkerson.py"}, "randomized_algorithms_quicksort_select.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/randomized_algorithms_quicksort_select.py"}}, "Parallel_Concurrent": {"parallel_map_reduce_concept.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Parallel_Concurrent/parallel_map_reduce_concept.py"}, "parallel_multiprocessing_vs_threading_detailed.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Parallel_Concurrent/parallel_multiprocessing_vs_threading_detailed.py"}}, "Rare_Data_Structures": {"bloom_filter_basics.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/bloom_filter_basics.py"}, "cache_lru_implementation.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/cache_lru_implementation.py"}, "list_skip_list.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/list_skip_list.py"}, "tree_fenwick_tree.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_fenwick_tree.py"}, "tree_segment_tree.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_segment_tree.py"}, "tree_treap.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_treap.py"}}, "String_Algorithms": {"strings_kmp_algorithm.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_kmp_algorithm.py"}, "strings_longest_palindromic_substring.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_longest_palindromic_substring.py"}, "strings_pattern_matching_naive.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_pattern_matching_naive.py"}, "strings_rabin_karp.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_rabin_karp.py"}, "strings_suffix_tree_intro.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_suffix_tree_intro.py"}, "strings_trie_basics.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_trie_basics.py"}, "strings_z_algorithm.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_z_algorithm.py"}}}, "OOPs": {"Abstraction": {"abstract_base_classes_abc.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Abstraction/abstract_base_classes_abc.py"}, "interfaces_via_protocols.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Abstraction/interfaces_via_protocols.py"}, "partial_implementation_andcontract_enforcement.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Abstraction/partial_implementation_andcontract_enforcement.py"}}, "Advanced_Features": {"callable_objects_and_functors.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/callable_objects_and_functors.py"}, "composition_over_inheritance.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/composition_over_inheritance.py"}, "context_manager_protocol.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/context_manager_protocol.py"}, "dataclasses_basics_and_patterns.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/dataclasses_basics_and_patterns.py"}, "decorators_function_and_class.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/decorators_function_and_class.py"}, "dependency_injection_in_python_oop.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/dependency_injection_in_python_oop.py"}, "descriptors_full_guide.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/descriptors_full_guide.py"}, "magic_dunder_methods_containers.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/magic_dunder_methods_containers.py"}, "magic_dunder_methods_core.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/magic_dunder_methods_core.py"}, "metaclasses_introduction.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/metaclasses_introduction.py"}, "metaclasses_practical_patterns.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/metaclasses_practical_patterns.py"}, "mixins_design.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/mixins_design.py"}, "resource_management_and_raii_pythonic.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/resource_management_and_raii_pythonic.py"}, "slots_and_memory_optimization.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/slots_and_memory_optimization.py"}}, "Basics": {"classes_objects.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Basics/classes_objects.py"}, "constructors_init.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Basics/constructors_init.py"}, "docstrings_and_annotations.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Basics/docstrings_and_annotations.py"}, "instance_vs_class_vars.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Basics/instance_vs_class_vars.py"}, "properties_getters_setters.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Basics/properties_getters_setters.py"}, "static_and_class_methods.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Basics/static_and_class_methods.py"}}, "Concurrency": {"async_await_oop_patterns.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Concurrency/async_await_oop_patterns.py"}, "concurrent_futures_thread_pool_process_pool.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Concurrency/concurrent_futures_thread_pool_process_pool.py"}, "multiprocessing_basics.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Concurrency/multiprocessing_basics.py"}, "producer_consumer_oop_design.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Concurrency/producer_consumer_oop_design.py"}, "threading_basics_and_locking.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Concurrency/threading_basics_and_locking.py"}}, "Design_Patterns": {"behavioral_observer_strategy_command_state.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/behavioral_observer_strategy_command_state.py"}, "creational_singleton_factory_builder.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/creational_singleton_factory_builder.py"}, "iterator_and_generator_patterns.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/iterator_and_generator_patterns.py"}, "registry_plugin_architecture.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/registry_plugin_architecture.py"}, "structural_adapter_decorator_facade_proxy.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/structural_adapter_decorator_facade_proxy.py"}, "template_method_and_hook_patterns.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/template_method_and_hook_patterns.py"}}, "Encapsulation": {"immutability_patterns.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Encapsulation/immutability_patterns.py"}, "name_mangling_and_access_patterns.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Encapsulation/name_mangling_and_access_patterns.py"}, "private_protected_members.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Encapsulation/private_protected_members.py"}, "property_decorator_and_descriptors.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Encapsulation/property_decorator_and_descriptors.py"}}, "Error_Handling": {"contextlib_and_safe_resource_cleanup.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Error_Handling/contextlib_and_safe_resource_cleanup.py"}, "design_by_contract_assertions_and_type_checks.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Error_Handling/design_by_contract_assertions_and_type_checks.py"}, "exceptions_hierarchy_and_custom_exceptions.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Error_Handling/exceptions_hierarchy_and_custom_exceptions.py"}}, "Inheritance": {"hierarchical_inheritance.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Inheritance/hierarchical_inheritance.py"}, "hybrid_inheritance.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Inheritance/hybrid_inheritance.py"}, "method_resolution_order_mro.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Inheritance/method_resolution_order_mro.py"}, "multilevel_inheritance.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Inheritance/multilevel_inheritance.py"}, "multiple_inheritance.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Inheritance/multiple_inheritance.py"}, "single_inheritance.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Inheritance/single_inheritance.py"}, "super_function_and_cooperative_multiple_inheritance.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Inheritance/super_function_and_cooperative_multiple_inheritance.py"}}, "Polymorphism": {"duck_typing_and_eafp.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/duck_typing_and_eafp.py"}, "method_overloading_pythonic_alternatives.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/method_overloading_pythonic_alternatives.py"}, "method_overriding.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/method_overriding.py"}, "operator_overloading_magic_methods.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/operator_overloading_magic_methods.py"}, "typing_protocols_structural_subtyping.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/typing_protocols_structural_subtyping.py"}}, "Testing": {"layering_and_package_structure.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Testing/layering_and_package_structure.py"}, "property_based_testing_for_objects.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Testing/property_based_testing_for_objects.py"}, "serialization_pickle_json_dataclasses_asdict.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Testing/serialization_pickle_json_dataclasses_asdict.py"}, "unit_tests_for_oop_classes.py": {"type": "file", "ext": ".py", "path": "python/PythonMasteryRepo/OOPs/Testing/unit_tests_for_oop_classes.py"}}}, "STYLE_GUIDE.md": {"type": "file", "ext": ".md", "path": "python/PythonMasteryRepo/STYLE_GUIDE.md"}}}},
    index: [{"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Theory and Foundations\n\n## 1. Algebraic Structures\n\nAlgebra in computer science is not just about solving equations; it's about understanding **structures** and **operations** that follow specific rules. These structures are the foundation of cryptography, coding theory, and advanced algorithm design (e.g., FFT).\n\n### 1.1 Groups, Rings, and Fields\n\nThe hierarchy of algebraic structures defines what operations are permissible and what properties they guarantee.\n\n#### 1.1.1 Groups\nA **Group** $(G, \\cdot)$ is a set $G$ equipped with a binary operation $\\cdot$ satisfying:\n1.  **Closure**: $\\forall a, b \\in G, a \\cdot b \\in G$.\n2.  **Associativity**: $(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$.\n3.  **Identity**: $\\exists e \\in G$ such that $a \\cdot e = e \\cdot a = a$.\n4.  **Inverse**: $\\forall a \\in G, \\exists a^{-1} \\in G$ such that $a \\cdot a^{-1} = a^{-1} \\cdot a = e$.\n\n*   **Abelian Group**: If $a \\cdot b = b \\cdot a$ (Commutativity).\n*   *Examples*: Integers under addition $(\\mathbb{Z}, +)$, Non-zero reals under multiplication $(\\mathbb{R}^*, \\cdot)$.\n\n#### 1.1.2 Rings\nA **Ring** $(R, +, \\cdot)$ has two operations:\n1.  $(R, +)$ is an Abelian Group.\n2.  $(R, \\cdot)$ is a Monoid (Closure, Associativity, Identity).\n3.  **Distributivity**: $a \\cdot (b + c) = a \\cdot b + a \\cdot c$.\n\n*   *Example*: Integers $(\\mathbb{Z}, +, \\cdot)$.\n\n#### 1.1.3 Fields\nA **Field** $(F, +, \\cdot)$ is a Ring where:\n1.  $(F^*, \\cdot)$ is an Abelian Group (Multiplicative inverses exist for all non-zero elements).\n2.  Commutativity of multiplication holds.\n\n*   *Examples*: Real numbers $\\mathbb{R}$, Complex numbers $\\mathbb{C}$, Finite fields $\\mathbb{F}_p$ (integers modulo a prime $p$).\n\n### 1.2 Modular Arithmetic (The Integers Modulo $n$)\n\nThe set $\\mathbb{Z}_n = \\{0, 1, \\dots, n-1\\}$ under addition and multiplication modulo $n$.\n*   $\\mathbb{Z}_n$ is always a Ring.\n*   $\\mathbb{Z}_n$ is a **Field** if and only if $n$ is **prime**.\n\n#### Properties:\n*   $a \\equiv b \\pmod n \\iff n \\mid (a - b)$.\n*   $(a + b) \\pmod n = ((a \\pmod n) + (b \\pmod n)) \\pmod n$.\n*   $(a \\cdot b) \\pmod n = ((a \\pmod n) \\cdot (b \\pmod n)) \\pmod n$.\n\n## 2. Homomorphisms and Isomorphisms\n\nMap functions that preserve structure. Let $(G, \\cdot)$ and $(H, *)$ be groups. A function $f: G \\to H$ is a **homomorphism** if:\n$$ f(a \\cdot b) = f(a) * f(b) $$\n\n*   **Isomorphism**: A bijective homomorphism. If exists, $G$ and $H$ are effectively the same structure.\n\n## 3. Polynomial Arithmetic\n\nPolynomials over a field $F$, denoted $F[x]$, behave similarly to integers.\n*   **Division Algorithm**: $A(x) = Q(x)B(x) + R(x)$, where $\\deg(R) < \\deg(B)$.\n*   **Irreducible Polynomials**: Analogous to prime numbers.\n*   **Galois Fields $GF(p^n)$**: Constructed using irreducible polynomials over $\\mathbb{F}_p$. Critical for AES encryption and Reed-Solomon codes.\n\n## 4. Theory Recommendation for CS\n\nUnderstanding **Finite Fields** and **Group Theory** is non-negotiable for:\n1.  **Cryptography**: RSA uses $\\mathbb{Z}_n^*$, Elliptic Curve Cryptography uses groups over finite fields.\n2.  **Hashing**: Cyclic Redundancy Checks (CRC) use polynomial rings.\n3.  **Error Correction**: Reed-Solomon codes rely on field arithmetic.\n4.  **FFT**: Fast Fourier Transform relies on roots of unity in a field (Complex or Finite).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Methods and Algorithms\n\n## 1. Modular Exponentiation\n\nCalculating $a^b \\pmod m$ efficiently is fundamental. Brute force is $O(b)$, which is exponential in the number of bits of $b$.\n**Technique**: Binary Exponentiation (Square-and-Multiply).\n**Complexity**: $O(\\log b)$.\n\n## 2. Euclidean Algorithm for GCD\n\nFinding the Greatest Common Divisor (GCD) of two numbers $a, b$.\n**Recursive Step**: $\\gcd(a, b) = \\gcd(b, a \\pmod b)$.\n**Base Case**: $\\gcd(a, 0) = a$.\n**Complexity**: $O(\\log(\\min(a, b)))$. Lam\u00e9's Theorem relates this to Fibonacci numbers.\n\n## 3. Extended Euclidean Algorithm\n\nFinds $x, y$ such that $ax + by = \\gcd(a, b)$.\nEssential for finding **Modular Inverse**. If $\\gcd(a, m) = 1$, then $ax \\equiv 1 \\pmod m$.\n**Algorithm**:\nMaintain quotients during the standard Euclidean algorithm and back-substitute.\n\n## 4. Euler's Totient Function $\\phi(n)$\n\nCount of integers $1 \\le k < n$ such that $\\gcd(k, n) = 1$.\n*   If $p$ is prime, $\\phi(p) = p - 1$.\n*   If $n = p_1^{e_1} \\dots p_k^{e_k}$, then $\\phi(n) = n \\prod (1 - 1/p_i)$.\n*   **Euler's Theorem**: $a^{\\phi(n)} \\equiv 1 \\pmod n$.\n\n## 5. Primitive Roots and Discrete Logarithm\n\nA **primitive root** modulo $n$ is an integer $g$ such that every $a$ coprime to $n$ can be written as $g^k \\pmod n$.\n*   **Discrete Logarithm Problem**: Given $g, a, n$, find $k$. This is computationally hard and forms the basis of Diffie-Hellman Key Exchange.\n*   **Algorithm**: Baby-step Giant-step ($O(\\sqrt{n})$).\n\n## 6. Fast Fourier Transform (FFT) for Polynomial Multiplication\n\nMultiplying two polynomials of degree $n$:\n*   Naive: $O(n^2)$.\n*   FFT approach: $O(n \\log n)$.\n    1.  Evaluate polynomials at $2n$ points (Roots of Unity) using FFT.\n    2.  Point-wise multiply values.\n    3.  Interpolate back to coefficients using Inverse FFT.\n\n## 7. Gaussian Elimination (Linear Algebra over Fields)\n\nSolving systems of linear equations over any field (e.g., $\\mathbb{F}_2$).\n**Algorithm**: Row reduction to Reduced Row Echelon Form (RREF).\n**Complexity**: $O(n^3)$.\n**Application**: Solving XOR equations (lights out game), Berlekamp-Massey algo.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Tricks and Patterns (Competitive Programming & Optimization)\n\n## 1. Modular Arithmetic Patterns\n\n### 1.1 Negative Modulo\nIn Python, `-5 % 3` is `1`. In C++/Java, it might be `-2`.\n**Pattern**: Always normalize: `res = (a % m + m) % m`.\n\n### 1.2 Identifying \"Cycle Finding\" Problems\nAny sequence defined by $x_{i+1} = f(x_i) \\pmod m$ will eventually cycle.\n**Trick**: Use Floyd's Cycle Finding (Tortoise and Hare) to detect period $\\lambda$ and pre-period $\\mu$.\n**App**: Pollard's Rho Algorithm for integer factorization.\n\n### 1.3 Fermat's Little Theorem for Division\nTo compute $(a / b) \\pmod p$ where $p$ is prime:\nCompute $a \\cdot b^{p-2} \\pmod p$.\n**Precondition**: $b$ is not a multiple of $p$.\n\n## 2. Combinatorics and Modulo\n\n### 2.1 Precomputing Factorials\nTo calculate $\\binom{n}{k} \\pmod p$ repeatedly:\n1.  Precompute fact $[i] = i! \\pmod p$.\n2.  Precompute invFact $[i] = (i!)^{-1} \\pmod p$ using Fermat's Little Theorem (one exp call, then build backwards: $1/((n-1)!) = (1/n!) \\cdot n$).\n\n### 2.2 Lucas Theorem\nFor huge $n, k$ and small prime $p$, $\\binom{n}{k} \\equiv \\prod \\binom{n_i}{k_i} \\pmod p$, where $n_i, k_i$ are digits in base $p$.\n\n## 3. Matrix Exponentiation (Algebra + DP)\nLinear recurrence relations (Fibonacci, Tilings) can be solved in $O(k^3 \\log n)$ using matrix exponentiation.\n**Pattern**:\nState vector $V_i$. Transition $V_{i+1} = M \\times V_i$.\nResult: $V_n = M^n \\times V_0$.\n\n## 4. GCD Properties\n*   $\\gcd(a, b, c) = \\gcd(a, \\gcd(b, c))$.\n*   $\\gcd(a, b) = \\gcd(a, b-a)$.\n*   **Optimization**: $\\gcd(a, b)$ is very fast. Don't hesitate to use it in inner loops if values decrease rapidly.\n\n## 5. Identifying Groups in Disguise\n*   **XOR Operations**: Determine a vector space over $\\mathbb{F}_2$. Use Gaussian Elimination / Linear Basis to find max XOR subset, etc.\n*   **Permutations**: Decompose into disjoint cycles. Order of permutation = LCM of cycle lengths.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "\"\"\"\nAlgebraic Algorithms Implementation.\n\nIncludes:\n1. GCD and Extended GCD (Iterative & Recursive)\n2. Modular Inverse and Exponentiation\n3. Chinese Remainder Theorem Class\n4. Matrix Multiplication and Exponentiation (for Linear Recurrences)\n5. discrete_log (Baby-step Giant-step)\n\"\"\"\n\nfrom typing import Tuple, List, Optional\nimport math\n\n# ==============================================================================\n# 1. Basic Number Theory Helpers\n# ==============================================================================\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"\n    Compute Euclidean GCD of a and b.\n    Complexity: O(log(min(a, b)))\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n    Returns (g, x, y) such that ax + by = g = gcd(a, b).\n    Complexity: O(log(min(a, b)))\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        g, y, x = extended_gcd(b % a, a)\n        return g, x - (b // a) * y, y\n\ndef mod_inverse(a: int, m: int) -> int:\n    \"\"\"\n    Compute modular multiplicative inverse of a under modulo m.\n    Raises ValueError if inverse does not exist (gcd(a, m) != 1).\n    \"\"\"\n    g, x, y = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError(f\"Modular inverse does not exist for {a} modulo {m}\")\n    return (x % m + m) % m\n\ndef binary_exponentiation(base: int, exp: int, mod: int) -> int:\n    \"\"\"\n    Compute (base^exp) % mod using Square-and-Multiply.\n    Complexity: O(log exp)\n    \"\"\"\n    res = 1\n    base %= mod\n    while exp > 0:\n        if exp % 2 == 1:\n            res = (res * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return res\n\n# ==============================================================================\n# 2. Chinese Remainder Theorem\n# ==============================================================================\n\nclass ChineseRemainderSolver:\n    \"\"\"\n    Solves system of congruences:\n    x = a1 (mod n1)\n    x = a2 (mod n2)\n    ...\n    Assumes n_i correspond to pairwise coprime moduli.\n    \"\"\"\n    \n    @staticmethod\n    def solve(remainders: List[int], moduli: List[int]) -> int:\n        prod = 1\n        for n in moduli:\n            prod *= n\n            \n        result = 0\n        for a_i, n_i in zip(remainders, moduli):\n            p = prod // n_i\n            result += a_i * mod_inverse(p, n_i) * p\n        return result % prod\n\n# ==============================================================================\n# 3. Matrix Exponentiation (for Recurrences)\n# ==============================================================================\n\nclass MatrixMod:\n    \"\"\"\n    Matrix operations under modulo m.\n    \"\"\"\n    def __init__(self, mat: List[List[int]], mod: int):\n        self.mat = mat\n        self.mod = mod\n        self.rows = len(mat)\n        self.cols = len(mat[0])\n\n    @staticmethod\n    def identity(n: int, mod: int) -> 'MatrixMod':\n        mat = [[0] * n for _ in range(n)]\n        for i in range(n):\n            mat[i][i] = 1\n        return MatrixMod(mat, mod)\n\n    def __mul__(self, other: 'MatrixMod') -> 'MatrixMod':\n        if self.cols != other.rows:\n            raise ValueError(\"Matrix dimensions mismatch\")\n        \n        res = [[0] * other.cols for _ in range(self.rows)]\n        for i in range(self.rows):\n            for k in range(self.cols):\n                if self.mat[i][k] == 0: continue\n                for j in range(other.cols):\n                    res[i][j] = (res[i][j] + self.mat[i][k] * other.mat[k][j]) % self.mod\n        return MatrixMod(res, self.mod)\n\n    def pow(self, exp: int) -> 'MatrixMod':\n        res = MatrixMod.identity(self.rows, self.mod)\n        base = self\n        while exp > 0:\n            if exp % 2 == 1:\n                res = res * base\n            base = base * base\n            exp //= 2\n        return res\n\n# ==============================================================================\n# 4. Discrete Logarithm (Baby-step Giant-step)\n# ==============================================================================\n\ndef discrete_log(a: int, b: int, m: int) -> Optional[int]:\n    \"\"\"\n    Solves a^x = b (mod m) for x.\n    Time Complexity: O(sqrt(m))\n    Space Complexity: O(sqrt(m))\n    \"\"\"\n    a %= m\n    b %= m\n    n = int(math.sqrt(m)) + 1\n    \n    # Baby steps: store a^j (mod m) for 0 <= j < n\n    value_map = {}\n    curr = 1\n    for j in range(n):\n        value_map[curr] = j\n        curr = (curr * a) % m\n        \n    # Giant steps: check b * (a^(-n))^i for matches\n    # a^x = b => a^(i*n + j) = b => a^j = b * (a^-n)^i\n    \n    try:\n        factor = mod_inverse(binary_exponentiation(a, n, m), m)\n    except ValueError:\n        return None # Inverse doesn't exist implies 'a' not coprime to m\n        \n    cur_val = b\n    for i in range(n + 1):\n        if cur_val in value_map:\n            res = i * n + value_map[cur_val]\n            return res\n        cur_val = (cur_val * factor) % m\n        \n    return None\n\nif __name__ == \"__main__\":\n    # Test GCD\n    assert gcd(48, 18) == 6\n    g, x, y = extended_gcd(35, 15)\n    assert 35*x + 15*y == g\n    \n    # Test Matrix Exp (Fibonacci)\n    # [ F_n+1 ] = [ 1 1 ] [ F_n   ]\n    # [ F_n   ]   [ 1 0 ] [ F_n-1 ]\n    mod = 10**9 + 7\n    fib_matrix = MatrixMod([[1, 1], [1, 0]], mod)\n    # F_10 = 55. Matrix^9 * [1, 0] gives F_10 at index [0][0] roughly\n    res_mat = fib_matrix.pow(9)\n    # Start vector [F_1, F_0] = [1, 0]\n    # Result [F_10, F_9]\n    f_10 = (res_mat.mat[0][0] * 1 + res_mat.mat[0][1] * 0) % mod\n    assert f_10 == 55\n    \n    # Test Discrete Log: 3^x = 13 (mod 17) -> 3^4 = 81 = 13 mod 17\n    assert discrete_log(3, 13, 17) == 4\n    \n    print(\"All Algebra implementations passed.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Annotated Examples and Use Cases\n\n## 1. Cryptography: Diffie-Hellman Key Exchange\n\n**Theory**: Relies on the difficulty of the Discrete Logarithm Problem in a cyclic group.\n**Scenario**: Alice and Bob want to share a secret key over an insecure channel.\n\n**Step-by-Step**:\n1.  **Public Parameters**: A large prime $p$ and a primitive root $g$ modulo $p$. (e.g., $p=23, g=5$).\n2.  **Alice**: Chooses private secret $a = 6$.\n    *   Computes public $A = g^a \\pmod p = 5^6 \\pmod{23} = 8$.\n    *   Sends $A$ to Bob.\n3.  **Bob**: Chooses private secret $b = 15$.\n    *   Computes public $B = g^b \\pmod p = 5^{15} \\pmod{23} = 19$.\n    *   Sends $B$ to Alice.\n4.  **Shared Secret**:\n    *   Alice computes $s = B^a \\pmod p = 19^6 \\pmod{23} = 2$.\n    *   Bob computes $s = A^b \\pmod p = 8^{15} \\pmod{23} = 2$.\n\n**Why it works**:\n$(g^a)^b = g^{ab} = (g^b)^a \\pmod p$.\nAn attacker sees $p, g, A, B$. To find $s$, they need $a$ or $b$, requiring discrete log solution.\n\n## 2. RSA Encryption (Rivest-Shamir-Adleman)\n\n**Theory**: Relies on the difficulty of factoring large numbers.\n**Key Generation**:\n1.  Choose primes $p, q$. Let $n = pq$.\n2.  Compute $\\phi(n) = (p-1)(q-1)$.\n3.  Choose $e$ such that $\\gcd(e, \\phi(n)) = 1$.\n4.  Compute $d$ such that $ed \\equiv 1 \\pmod{\\phi(n)}$ using Extended Euclidean Algo.\n\n**Use Case**:\n*   Public Key: $(e, n)$.\n*   Private Key: $d$.\n*   Encrypt: $C = M^e \\pmod n$.\n*   Decrypt: $M = C^d \\pmod n$.\n\n**Visual Model**:\nThink of encryption as putting a message in a box locked by a \"multiplication\" lock ($e$). The \"division\" key ($d$) unlocks it. But finding $d$ without $p, q$ is like trying to un-mix paint.\n\n## 3. Error Detection: CRC (Cyclic Redundancy Check)\n\n**Theory**: Polynomial division over $\\mathbb{F}_2$.\n**Process**:\n1.  Message is treated as a polynomial $M(x)$.\n2.  Generator polynomial $G(x)$ is fixed (standard specification).\n3.  Multiply $M(x)$ by $x^k$ (shift) and calculate remainder $R(x) = M(x) \\cdot x^k \\pmod{G(x)}$.\n4.  Send $M(x) \\cdot x^k - R(x)$. This is divisible by $G(x)$.\n5.  Receiver checks if received polynomial is divisible by $G(x)$.\n\n## 4. Competitive Programming: N-th Fibonacci via Matrix Exponentiation\n\n**Problem**: Find $F_{10^{18}} \\pmod{10^9+7}$.\n**Naive**: $O(N)$ iteration. TLE.\n**Algebraic Approach**:\n$$ \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} F_n \\\\ F_{n-1} \\end{pmatrix} $$\nLet $M = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}$. Then $\\vec{v}_n = M^n \\vec{v}_0$.\nUse Binary Exponentiation for $M^n$. $O(\\log n)$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Problems and Solutions\n\n## Problem 1: Linear Diophantine Equation\n\n**Statement**: Given $A, B, C$, find integer solutions for $Ax + By = C$. If no solution, print \"Impossible\".\n\n**Approach**:\n1.  Calculate $g = \\gcd(A, B)$ using Euclidean Algo.\n2.  If $C \\% g \\neq 0$, no integer solution exists.\n3.  Use Extended Euclidean Algo to find $x_0, y_0$ such that $Ax_0 + By_0 = g$.\n4.  One particular solution is $x = x_0 \\cdot (C/g)$, $y = y_0 \\cdot (C/g)$.\n5.  General solution: $x' = x + k \\cdot (B/g)$, $y' = y - k \\cdot (A/g)$.\n\n**Python Solution**:\n```python\ndef solve_diophantine(a, b, c):\n    g, x0, y0 = extended_gcd(abs(a), abs(b))\n    if c % g != 0:\n        return None\n    \n    scale = c // g\n    x = x0 * scale\n    y = y0 * scale\n    \n    # Adjust signs if a or b were negative\n    if a < 0: x = -x\n    if b < 0: y = -y\n    return x, y\n```\n\n## Problem 2: Sum of Geometric Series Modulo M\n\n**Statement**: Compute $S = 1 + r + r^2 + \\dots + r^n \\pmod m$.\n\n**Approach**:\n*   Formula: $S = \\frac{r^{n+1} - 1}{r - 1}$.\n*   Requires Modular Inverse of $(r-1)$. This only exists if $\\gcd(r-1, m) = 1$.\n*   **General Case (if inverse doesn't exist)**: Use Divide and Conquer.\n    *   If $n$ is odd ($n = 2k+1$ terms? Let's say indices $0 \\dots 2k$):\n        $1 + \\dots + r^{2k+1} = (1 + r^{k+1})(1 + r + \\dots + r^k)$.\n    *   If $n$ is even, reduce to odd case or handle term manually.\n\n**Python Solution (DnC)**:\n```python\ndef geometric_sum(r, n, m):\n    # Sum r^0 + ... + r^(n-1)\n    if n == 0: return 0\n    if n % 2 == 0: # Even number of terms, e.g., r^0...r^3\n        half_n = n // 2\n        half_sum = geometric_sum(r, half_n, m)\n        multiplier = (1 + pow(r, half_n, m)) % m\n        return (half_sum * multiplier) % m\n    else: # Odd number of terms\n        return (1 + r * geometric_sum(r, n - 1, m)) % m\n```\n\n## Problem 3: Square Root Modulo P\n\n**Statement**: Find $x$ such that $x^2 \\equiv n \\pmod p$.\n\n**Approach**: Tonelli-Shanks Algorithm.\n*   If $p \\equiv 3 \\pmod 4$, then $x \\equiv \\pm n^{(p+1)/4} \\pmod p$.\n*   For general $p$, the algorithm is more involved ($O(\\log^2 p)$).\n\n**Note**: Check Euler's Criterion first: $n^{(p-1)/2} \\equiv 1 \\pmod p$. If $-1$, no solution.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Advanced Notes and Research Directions\n\n## 1. Abstract Algebra Deeper Dive\n\n### 1.1 Solvable Groups and Galois Theory\n*   **Galois Theory** connects Field Theory and Group Theory. It explains why there is no general formula for quintic equations (because $S_5$ is not a solvable group).\n*   **Application**: Advanced error-correcting codes and lattice-based cryptography often draw on these deeper properties.\n\n### 1.2 Ring of Polynomials\n*   $F[x] / P(x)$ forms a field if $P(x)$ is irreducible.\n*   **Research**: Optimizing arithmetic in $GF(2^{128})$ is crucial for GCM mode in AES.\n*   **NTRU Encryption**: Operations occur in a truncated polynomial ring $R = \\mathbb{Z}[X]/(X^N - 1)$.\n\n## 2. Homomorphic Encryption\nAllows computation on encrypted data without decrypting it ($E(a) + E(b) \\to E(a+b)$).\n*   **Partially Homomorphic**: RSA is multiplicative ($E(m_1)E(m_2) = E(m_1 m_2)$).\n*   **Fully Homomorphic Encryption (FHE)**: Based on Lattice problems (LWE - Learning With Errors).\n\n## 3. Pairing-Based Cryptography\nUses **Bilinear Maps** (Pairings) $e: G_1 \\times G_2 \\to G_T$.\n*   $e(aP, bQ) = e(P, Q)^{ab}$.\n*   Allows for **Identity-Based Encryption (IBE)** and short signatures (BLS).\n\n## 4. Primality Testing\n*   **Miller-Rabin**: Probabilistic. Standard in practice.\n*   **AKS (Agrawal-Kayal-Saxena)**: Deterministic polynomial time. Theoretical breakthrough (2002).\n\n## 5. Integer Factorization\n*   **General Number Field Sieve (GNFS)**: Fastest known classical algorithm.\n*   **Shor's Algorithm**: Quantum algorithm that factors in polynomial time. Threatens RSA.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Theory and Foundations\n\n## 1. Vector Spaces and Subspaces\n\nThe central object of linear algebra is the **Vector Space** $V$ over a field $F$.\nVectors obey addition and scalar multiplication.\n\n### 1.1 Basis and Dimension\n*   **Linear Independence**: A set $\\{v_1, \\dots, v_k\\}$ is linearly independent if $c_1 v_1 + \\dots + c_k v_k = 0 \\implies c_i = 0$.\n*   **Span**: The set of all linear combinations of vectors.\n*   **Basis**: A linearly independent set that spans $V$.\n*   **Dimension**: The size of the basis (invariant).\n\n### 1.2 Subspaces\nA subset $W \\subseteq V$ is a subspace if it is closed under addition and scalar multiplication.\n*   **Null Space (Kernel)** of Matrix $A$: $\\{x \\mid Ax = 0\\}$.\n*   **Column Space (Image)** of Matrix $A$: Span of columns of $A$.\n*   **Rank-Nullity Theorem**: $\\text{rank}(A) + \\text{nullity}(A) = n$ (number of cols).\n\n## 2. Matrices and Linear Transformations\n\nMatrices represent linear maps between vector spaces.\nIf $T: \\mathbb{R}^n \\to \\mathbb{R}^m$, there exists an $m \\times n$ matrix $A$ such that $T(x) = Ax$.\n\n### 2.1 Determinant\nA scalar value $\\det(A)$ characterizing square matrices.\n*   Geometric interpretation: Scaling factor of volume.\n*   $\\det(A) \\neq 0 \\iff A$ is invertible.\n*   Multiplicative: $\\det(AB) = \\det(A)\\det(B)$.\n\n### 2.2 Eigenvalues and Eigenvectors\nFor a square matrix $A$, if $Av = \\lambda v$ ($v \\neq 0$), then $\\lambda$ is an **Eigenvalue** and $v$ is an **Eigenvector**.\n*   **Characteristic Polynomial**: $p(\\lambda) = \\det(A - \\lambda I)$. Roots are eigenvalues.\n*   **Diagonalization**: $A = PDP^{-1}$ if $A$ has $n$ linearly independent eigenvectors.\n*   **Spectral Theorem**: Real symmetric matrices can be diagonalized by orthogonal matrices ($A = Q \\Lambda Q^T$).\n\n## 3. Norms and Inner Products\n\nMeasuring \"length\" and \"angle\".\n\n### 3.1 Norms ($L_p$)\n*   $L_1$ (Manhattan): $\\sum |x_i|$.\n*   $L_2$ (Euclidean): $\\sqrt{\\sum x_i^2}$.\n*   $L_\\infty$ (Max): $\\max |x_i|$.\n\n### 3.2 Inner Product\n$\\langle u, v \\rangle = u^T v = \\sum u_i v_i$.\n*   **Orthogonality**: $\\langle u, v \\rangle = 0$.\n*   **Cauchy-Schwarz Inequality**: $|\\langle u, v \\rangle| \\le \\|u\\| \\|v\\|$.\n\n## 4. Decompositions (The \"Factorization\" of LA)\n\nAlgorithms rely on decomposing difficult matrices into simpler ones.\n1.  **LU Decomposition**: $A = LU$ (Lower $\\times$ Upper). Used for solving linear systems.\n2.  **QR Decomposition**: $A = QR$ (Orthogonal $\\times$ Upper Triangular). Used for Least Squares.\n3.  **Cholesky Decomposition**: $A = LL^T$ (for Symmetric Positive Definite).\n4.  **SVD (Singular Value Decomposition)**: The \"King\" of decompositions. $A = U \\Sigma V^T$.\n    *   Exists for **any** matrix (even rectangular).\n    *   Applications: Compression, PCA, Pseudo-inverse, Recommender Systems.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Methods and Algorithms\n\n## 1. Gaussian Elimination\n\n**Purpose**: Solve $Ax = b$, find $\\det(A)$, find $A^{-1}$, find Rank.\n**Method**: Transform augmented matrix $[A|b]$ to Row Echelon Form (REF) and then Reduced REF (RREF).\n**Operations**:\n1.  Swap rows.\n2.  Multiply row by non-zero scalar.\n3.  Add multiple of one row to another.\n**Complexity**: $O(N^3)$.\n\n## 2. Matrix Multiplication Optimization\n\nNaive is $O(N^3)$.\n*   **Strassen's Algorithm**: $O(N^{\\log_2 7}) \\approx O(N^{2.81})$. Uses recursive block multiplication tricks.\n*   **Coppersmith-Winograd**: $O(N^{2.376})$ (Theoretical, huge constant).\n\n## 3. Computing Matrix Powers $A^k$\n\n**Method**: Binary Exponentiation (Square and Multiply).\n**Complexity**: $O(N^3 \\log k)$.\n**Application**: Counting paths of length $k$ in a graph, Linear Recurrences.\n\n## 4. Singular Value Decomposition (SVD) Algorithm\n\n**Goal**: Find $U, \\Sigma, V^T$ such that $A = U \\Sigma V^T$.\n**Iterative Methods**:\n*   **Golub-Kahan-Reinsch**: Reduces $A$ to bidiagonal form, then uses QR-like iterations.\n*   **Power Iteration**: Finds dominant eigenvalue/vector. Can be adapted for SVD.\n\n## 5. Solving Linear Recurrences (The General Method)\n\nGiven $f_n = c_1 f_{n-1} + \\dots + c_k f_{n-k}$.\n1.  Construct Transformation Matrix $T$ size $k \\times k$.\n$$\nT = \\begin{bmatrix}\nc_1 & c_2 & \\dots & c_{k-1} & c_k \\\\\n1 & 0 & \\dots & 0 & 0 \\\\\n0 & 1 & \\dots & 0 & 0 \\\\\n\\vdots & & \\ddots & & \\vdots \\\\\n0 & 0 & \\dots & 1 & 0\n\\end{bmatrix}\n$$\n2.  State vector $V_{n-1} = [f_{n-1}, \\dots, f_{n-k}]^T$.\n3.  $V_{n+m} = T^{m+1} V_{n-1}$.\n\n## 6. Least Squares Regression\n\nGiven overdetermined system $Ax = b$ (more equations than unknowns).\nMinimize $\\|Ax - b\\|^2$.\n**Analytical Solution**: Normal Equation $A^T A x = A^T b$.\n**computional Note**: Solving via Normal Equation is unstable if condition number is high. QR decomposition or SVD is preferred ($x = A^+ b$).\n\n## 7. Linear Basis (Competitive Programming)\n\n**Problem**: Given a set of integers, find max XOR subset, check if $X$ can be formed by XORing subset.\n**Algorithm**: Gaussian Elimination on bits ($GF(2)$).\nMaintain a basis set $\\{b_1, \\dots, b_d\\}$ where each basis vector improves the \"highest bit\".\n**Complexity**: $O(N \\log (\\max val))$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Tricks and Patterns\n\n## 1. Matrix Exponentiation Tricks\n\n### 1.1 Augmenting the State\nSometimes the recurrence depends on $n$ or a sum.\n*   $f_n = f_{n-1} + f_{n-2} + n$.\n*   State: $[f_n, f_{n-1}, n, 1]^T$.\n*   Transition incorporates the $+1$ for $n$ and the $+n$ for $f_n$.\n\n### 1.2 Graph Adjacency Matrix\n*   Let $A$ be the adjacency matrix of an unweighted graph.\n*   $(A^k)_{ij}$ = Number of walks of length exactly $k$ from $i$ to $j$.\n*   **Trick**: If nodes are small ($N \\le 50$) and $k$ is huge, use Matrix Exp.\n\n## 2. XOR Basis (The \"Linear Algebra of Bits\")\n\nTo check if a number $X$ is representable by XOR sum of array $A$:\n1.  Insert all $a \\in A$ into a linear basis.\n2.  Try to reduce $X$ using the basis.\n3.  If $X$ reduces to 0, it is representable.\n4.  **Max XOR**: Greedily XOR with basis elements starting from most significant bit.\n\n## 3. Coordinate Compression\n\nIn geometry or 2D grid problems with huge coordinates but few points:\n*   Map unique sorted $x$-coordinates to $0, 1, 2, \\dots$.\n*   Preserves relative order.\n*   Transforms $10^9$ grid to $O(N)$ grid.\n\n## 4. Vandermonde Matrix Properties\n\nDeterminant of Vandermonde matrix (geometric progression rows) has a closed form: $\\prod_{1 \\le i < j \\le n} (x_j - x_i)$.\n*   Useful in interpolation and secret sharing problems.\n\n## 5. Cayley-Hamilton Theorem\n\nEvery square matrix satisfies its own characteristic equation: $p(A) = 0$.\n*   **Trick**: Enables computing $A^{-1}$ as a polynomial in $A$ of degree $n-1$.\n*   $A^n = c_{n-1}A^{n-1} + \\dots + c_0 I$. Can reduce high powers of $A$ without full multiplication if we only need specific projections.\n\n## 6. Rotation Matrices\n\nTo rotate a point $(x, y)$ by $\\theta$ counter-clockwise:\n$$\n\\begin{bmatrix} x' \\\\ y' \\end{bmatrix} =\n\\begin{bmatrix} \\cos \\theta & -\\sin \\theta \\\\ \\sin \\theta & \\cos \\theta \\end{bmatrix}\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n$$\n**Trick**: For $90^\\circ$, swap and negate: $(x, y) \\to (-y, x)$.\n\n## 7. Fast Hadamard Transform (FHT)\n\nLike FFT but for XOR convolution.\n$(A * B)[k] = \\sum_{i \\oplus j = k} A[i] B[j]$.\nUses the Hadamard matrix structure. Complexity $O(N \\log N)$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "\"\"\"\nLinear Algebra Algorithms Implementation.\n\nIncludes:\n1. Matrix Class (Basic Ops, Transpose, Determinanat via Gaussian)\n2. Gaussian Elimination (Row Reduction)\n3. Linear Basis (XOR Basis)\n4. Fast Walsh-Hadamard Transform (FWHT) for XOR Convolution\n\"\"\"\n\nfrom typing import List, Optional\n\n# ==============================================================================\n# 1. Matrix Operations (Basic)\n# ==============================================================================\n\nclass Matrix:\n    def __init__(self, data: List[List[float]]):\n        self.data = data\n        self.rows = len(data)\n        self.cols = len(data[0])\n\n    def __repr__(self):\n        return \"\\n\".join([\" \".join(f\"{x:.2f}\" for x in row) for row in self.data])\n\n    def multiply(self, other: 'Matrix') -> 'Matrix':\n        if self.cols != other.rows:\n            raise ValueError(\"Dimensions invalid for multiplication\")\n        res = [[0.0] * other.cols for _ in range(self.rows)]\n        for i in range(self.rows):\n            for k in range(self.cols):\n                if self.data[i][k] == 0: continue\n                for j in range(other.cols):\n                    res[i][j] += self.data[i][k] * other.data[k][j]\n        return Matrix(res)\n\n    def determinant(self) -> float:\n        \"\"\"\n        Computes determinant using Gaussian elimination.\n        Complexity: O(N^3)\n        \"\"\"\n        if self.rows != self.cols:\n            raise ValueError(\"Determinant only for square matrices\")\n        \n        n = self.rows\n        mat = [row[:] for row in self.data] # Copy\n        det = 1.0\n        \n        for i in range(n):\n            # Pivot\n            pivot = i\n            while pivot < n and abs(mat[pivot][i]) < 1e-9:\n                pivot += 1\n            if pivot == n:\n                return 0.0 # Singular\n            \n            # Swap\n            if pivot != i:\n                mat[pivot], mat[i] = mat[i], mat[pivot]\n                det *= -1\n                \n            det *= mat[i][i]\n            \n            # Eliminate\n            for j in range(i + 1, n):\n                factor = mat[j][i] / mat[i][i]\n                for k in range(i, n): # Start from i optimization\n                    mat[j][k] -= factor * mat[i][k]\n                    \n        return det\n\n    @staticmethod\n    def identity(n: int) -> 'Matrix':\n        data = [[0.0]*n for _ in range(n)]\n        for i in range(n): data[i][i] = 1.0\n        return Matrix(data)\n\n# ==============================================================================\n# 2. Linear Basis (XOR Basis)\n# ==============================================================================\n\nclass LinearBasis:\n    \"\"\"\n    Manages a basis for XOR vector space.\n    Operations: O(log(MaxVal)) = O(Bits).\n    \"\"\"\n    def __init__(self):\n        self.basis: List[int] = []\n        \n    def insert(self, mask: int):\n        for b in self.basis:\n            mask = min(mask, mask ^ b)\n        if mask > 0:\n            self.basis.append(mask)\n            self.basis.sort(reverse=True) # Keep basis sorted for greedy max\n            \n    def can_form(self, mask: int) -> bool:\n        for b in self.basis:\n            mask = min(mask, mask ^ b)\n        return mask == 0\n        \n    def max_xor(self) -> int:\n        res = 0\n        for b in self.basis:\n            res = max(res, res ^ b)\n        return res\n\n# ==============================================================================\n# 3. Fast Walsh-Hadamard Transform (FWHT)\n# ==============================================================================\n\ndef fwht(a: List[int], inverse: bool = False) -> List[int]:\n    \"\"\"\n    Computes XOR convolution (or transform).\n    Len(a) must be power of 2.\n    \"\"\"\n    n = len(a)\n    if (n & (n - 1)) != 0:\n        raise ValueError(\"Length must be power of 2\")\n        \n    a = list(a) # Copy\n    length = 1\n    while length < n:\n        for i in range(0, n, 2 * length):\n            for j in range(length):\n                x = a[i + j]\n                y = a[i + j + length]\n                if not inverse:\n                    a[i + j] = x + y\n                    a[i + j + length] = x - y\n                else:\n                    a[i + j] = (x + y) // 2\n                    a[i + j + length] = (x - y) // 2\n        length *= 2\n    return a\n\ndef xor_convolution(a: List[int], b: List[int]) -> List[int]:\n    \"\"\"\n    Computes C[k] = sum(A[i] * B[j]) for all i ^ j = k.\n    \"\"\"\n    # Pad to power of 2\n    n = 1\n    while n < max(len(a), len(b)): n *= 2\n    \n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    \n    fa = fwht(a)\n    fb = fwht(b)\n    \n    # Point-wise multiply\n    fc = [fa[i] * fb[i] for i in range(n)]\n    \n    return fwht(fc, inverse=True)\n\n# ==============================================================================\n# 4. Main Test\n# ==============================================================================\n\nif __name__ == \"__main__\":\n    # Test Matrix\n    m1 = Matrix([[1, 2], [3, 4]])\n    assert abs(m1.determinant() - (-2.0)) < 1e-9\n    \n    # Test Linear Basis\n    lb = LinearBasis()\n    lb.insert(3) # 011\n    lb.insert(5) # 101\n    # Can form 3^5 = 6 (110)? Yes.\n    assert lb.can_form(6) is True\n    assert lb.max_xor() == 7 # 6^? no 3 is 011, 5 is 101. Basis [5, 3^5=6]. 5^6 = 3. Max is 5(101) ^ 6(110)? No. 5 is highest bit. 5^011(3)=6. 5^2(from 3^5? no).\n    # Correct Basis behavior:\n    # Ins 3: [3]\n    # Ins 5: 5^3 = 6. [6, 3] (Sorted).\n    # Max: 0^6 = 6. 6^3 = 5. Wait.\n    # 6 (110), 3 (011). \n    # Max XOR: Try to include 6. Res=6. Try include 3. 6^3 = 5 (101). 6 > 5. Keep 6. Wait 6^3 is 110^011=101=5.\n    # Actually, basis logic usually keeps 'high bit' unique.\n    # [5 (101), 3 (011)] -> 5 is basis for bit 2. 3 is basis for bit 1? no. 3^5 = 6(110).\n    # Correct reduction:\n    # ins 3. basis: [3]\n    # ins 5. min(5, 5^3=6). 5 is smaller? Insert 3, then 5.\n    # Standard basis: {101, 011}. Linear combinations: 101, 011, 110. Max is 110 (6).\n    # Code implementation check:\n    # insert 3: basis=[3]\n    # insert 5: 5^3 = 6. 5>6 False. 5 inserted? No logic: mask = min(mask, mask^b). \n    # 5^3 = 6. min(5, 6) = 5. 5 is > 0. basis=[5, 3]?\n    # Let's trace carefully: insert(mask). mask iterates basis.\n    # mask=5. b=3. 5^3=6. min(5, 6)=5. mask stays 5.\n    # append 5. sort reverse. basis=[5, 3].\n    # max_xor: res=0. res^5=5. res^3=6. Final 6. Correct.\n    assert lb.max_xor() == 6\n\n    # Test FWHT\n    # A = [1, 0], B = [1, 1] (Polynomials over methods)\n    # i, j indices. 0,0->0. 0,1->1.\n    # Result should have 1 at index 0, 1 at index 1.\n    poly_a = [1, 0] # Represents {0}\n    poly_b = [1, 1] # Represents {0, 1}\n    # {0}^0 = 0. {0}^1 = 1.\n    res = xor_convolution(poly_a, poly_b)\n    # Expect [1, 1]\n    assert res[0] == 1 and res[1] == 1\n    \n    print(\"All Linear Algebra Implementations Validated.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Annotated Examples and Use Cases\n\n## 1. PageRank Algorithm (Google)\n\n**Theory**: Finding the \"importance\" of nodes in a graph based on incoming links. Modeling the web as a Markov Chain.\n**Linear Algebra Core**: Finding the **Principal Eigenvector** of the transition matrix.\n$$ v_{t+1} = M v_t $$\nwhere $M$ is the stochastic matrix (columns sum to 1).\n**Stationary Distribution**: $v = Mv$. This means $v$ is an eigenvector with eigenvalue $\\lambda = 1$.\n\n**Process**:\n1.  Construct adjacency matrix $A$.\n2.  Normalize columns to get $M$.\n3.  Add \"damping factor\" (teleportation) to ensure connectivity and existence of limit.\n4.  Use **Power Iteration**: Repeatedly multiply $v$ by $M$ until convergence. The magnitude of components of $v$ represents Rank.\n\n## 2. Dimensionality Reduction (PCA)\n\n**Scenario**: You have a dataset with 100 features, but many are correlated. You want to visualize it in 2D.\n**Technique**: Principal Component Analysis via **SVD**.\n1.  Center data (subtract mean). Form matrix $X$ ($n \\text{ samples} \\times d \\text{ features}$).\n2.  Compute covariance matrix $C = \\frac{1}{n} X^T X$.\n3.  Compute Eigenvectors of $C$ (or SVD of $X$).\n4.  The eigenvectors corresponding to largest eigenvalues are \"Principal Components\" (directions of max variance).\n5.  Project $X$ onto these top 2 vectors.\n\n## 3. Game Theory: Lights Out\n\n**Problem**: A grid of lights. Pressing one toggles it and neighbors. Turn all off.\n**Model**: System of linear equations over $\\mathbb{F}_2$ (GF(2)).\n$$ Ax = b $$\nwhere $x$ is vector of button presses (1 or 0), $b$ is current state, $A$ describes effect of buttons.\n**Solution**: Gaussian Elimination over GF(2).\n\n## 4. Recommender Systems (Matrix Factorization)\n\n**Scenario**: Users rating movies. Matrix $R$ (Users $\\times$ Movies) is sparse.\n**Goal**: Fill in blanks.\n**Model**: Assume $R \\approx U \\times V^T$.\n$U$: User preference vectors (latent factors).\n$V$: Movie feature vectors.\n**Solver**: Alternating Least Squares (ALS) or SVD-based approximation.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Problems and Solutions\n\n## Problem 1: Number of Spanning Trees (Matrix Tree Theorem)\n\n**Statement**: Given a connected graph $G$, calculate the number of distinct spanning trees.\n\n**Theory (Kirchhoff's Theorem)**:\nThe number of spanning trees is equal to any cofactor of the **Laplacian Matrix** $L$.\n$L = D - A$, where $D$ is Degree Matrix (diagonal), $A$ is Adjacency Matrix.\n\n**Approach**:\n1.  Construct $L$.\n2.  Remove last row and last column to get $L'$.\n3.  Compute $\\det(L')$.\n\n**Python Solution**:\n```python\ndef count_spanning_trees(adj_matrix):\n    n = len(adj_matrix)\n    # 1. Build Laplacian\n    L = [[0.0] * n for _ in range(n)]\n    for i in range(n):\n        degree = sum(adj_matrix[i])\n        for j in range(n):\n            if i == j:\n                L[i][j] = degree\n            elif adj_matrix[i][j]:\n                L[i][j] = -1\n    \n    # 2. Minor (Remove last row/col)\n    minor = [row[:-1] for row in L[:-1]]\n    \n    # 3. Determinant (using our Matrix class logic)\n    mat = Matrix(minor)\n    return round(mat.determinant()) \n```\n\n## Problem 2: Knight's Moves on Infinite Board\n\n**Statement**: Can a Knight reach $(x, y)$ from $(0, 0)$? In exactly $K$ steps?\n**Linear Algebra Approach**:\nThis is a path counting problem on a graph.\nFor small board: Adjacency Matrix power $A^K$.\nFor infinite board: Not strictly linear algebra matrices, but can be modeled as linear combination of move vectors.\n$(x, y) = a(1, 2) + b(2, 1) + \\dots$\nMore of a Diophantine / BFS problem, but $A^k$ applies for finite bounded boards (e.g., \"Moves on Keypad\").\n\n## Problem 3: Recurrence with \"Sum of Previous Terms\"\n\n**Statement**: $a_n = 2a_{n-1} + a_{n-2} + n^2$. Find $a_N \\pmod M$.\n**State Vector**: Need terms to generate next $n^2$ (which is $(n+1)^2 = n^2 + 2n + 1$).\n$V_n = [a_n, a_{n-1}, n^2, n, 1]^T$.\n**Transition**:\n$a_{n+1} = 2a_n + a_{n-1} + (n+1)^2 = 2a_n + a_{n-1} + n^2 + 2n + 1$.\n$(n+1)^2 = n^2 + 2n + 1$.\n$(n+1) = n + 1$.\n$1 = 1$.\n\nMatrix M:\n```\n[2, 1, 1, 2, 1]\n[1, 0, 0, 0, 0]\n[0, 0, 1, 2, 1]\n[0, 0, 0, 1, 1]\n[0, 0, 0, 0, 1]\n```\nCompute $M^N \\times V_0$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Advanced Notes and Research Directions\n\n## 1. Randomized Linear Algebra\n\nStandard matrix algorithms ($O(N^3)$) are too slow for Big Data ($N=10^6$).\n**Research methods**:\n*   **Sketching**: Project vectors into lower dimensions using random matrices (Johnson-Lindenstrauss Lemma) while preserving norms.\n*   **Randomized SVD**: Identify range of $A$ using random vectors, then SVD on smaller subspace. Very fast approximate PCA.\n\n## 2. Sparse Linear Algebra\n\nAlgorithms optimized for matrices where most entries are zero.\n*   **Storage**: CSR (Compressed Sparse Row), CSC.\n*   **Solvers**: Krylov Subspace Methods (Conjugate Gradient, GMRES). These solve $Ax=b$ by iteratively building a basis for $\\{b, Ab, A^2b \\dots\\}$. $O(k \\cdot E)$ where $E$ is edges, much faster than $N^3$.\n\n## 3. Tensor Algebra (Multilinear Algebra)\n\nGeneralizing matrices (2D) to Tensors (nD).\n*   **Tensor Decomposition**: CP (Canonical Polyadic), Tucker.\n*   **Applications**: Deep Learning (PyTorch/TensorFlow are tensor algebra libraries), Chemometrics.\n\n## 4. Quantum Linear Algebra\n\nHHL Algorithm (Harrow-Hassidim-Lloyd).\n*   Solves $Ax=b$ in $O(\\log N)$ on a quantum computer (under specific conditions).\n*   Offers exponential speedup over classical algorithms.\n\n## 5. Spectral Graph Theory\n\nStudying graphs via eigenvalues of their matrices (Adjacency, Laplacian).\n*   **Cheeger's Inequality**: Relates \"conductance\" (bottlenecks) of a graph to the second smallest eigenvalue of Laplacian ($\\lambda_2$).\n*   **Graph Isomorphism**: Using spectrum to check isomorphism (imperfect but useful).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Group Actions and Combinatorics\n\n## 1. Group Actions\n\nWhile basic algebra checks satisfying properties (Is this a Group?), **Group Actions** study how groups **act** on sets. This is the bridge to Combinatorics and Geometry.\n\n### 1.1 Definition\nLeft action of group $G$ on set $X$ is a function $G \\times X \\to X$, denoted $g \\cdot x$, satisfying:\n1.  **Identity**: $e \\cdot x = x$.\n2.  **Compatibility**: $(gh) \\cdot x = g \\cdot (h \\cdot x)$.\n\n### 1.2 Orbits and Stabilizers\n*   **Orbit** of $x$: $Orb(x) = \\{g \\cdot x \\mid g \\in G\\}$. The set of points $x$ can reach.\n*   **Stabilizer** of $x$: $Stab(x) = \\{g \\in G \\mid g \\cdot x = x\\}$. The set of group elements that fix $x$.\n*   **Orbit-Stabilizer Theorem**: $|G| = |Orb(x)| \\cdot |Stab(x)|$.\n\n## 2. Burnside's Lemma (The \"Counting Lemma\")\n\nUsed to count distinct objects under symmetry (e.g., how many distinct necklaces with 3 beads exist?).\nThe number of distinct orbits $|X/G|$ is the average number of elements fixed by each $g \\in G$.\n\n$$ |X/G| = \\frac{1}{|G|} \\sum_{g \\in G} |fix(g)| $$\nwhere $fix(g) = \\{x \\in X \\mid g \\cdot x = x\\}$.\n\n## 3. P\u00f3lya Enumeration Theorem (PET)\n\nA generalization of Burnside's Lemma that counts distinct colorings by \"weight\" (e.g., 2 Red, 1 Blue).\n*   **Cycle Index Polynomial** $Z(G)$: A polynomial representing the cycle structure of $G$'s permutations.\n    $$ Z(G) = \\frac{1}{|G|} \\sum_{g \\in G} t_1^{j_1(g)} t_2^{j_2(g)} \\dots $$\n    where $j_k(g)$ is the number of cycles of length $k$ in permutation $g$.\n*   **Theorem**: Determine the number of patterns by substituting color weights into $Z(G)$.\n\n## 4. Permutation Groups\n\n*   **Symmetric Group $S_n$**: All $n!$ permutations of $n$ elements.\n*   **Alternating Group $A_n$**: Only even permutations.\n*   **Cayley's Theorem**: Every group is isomorphic to a subgroup of a symmetric group. \n\n## 5. Sylow Theorems (Structure of Finite Groups)\n\nIf $|G| = p^k m$ ($p$ prime not dividing $m$), then:\n1.  **Existence**: $G$ has a subgroup of size $p^k$ (Sylow $p$-subgroup).\n2.  **Conjugacy**: All Sylow $p$-subgroups are conjugate.\n3.  **Counting**: Number of Sylow $p$-subgroups $n_p$ satisfies $n_p \\equiv 1 \\pmod p$ and $n_p \\mid m$.\n\n**Application**: Used to prove a group is not simple (normal subgroups exist).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Methods and Algorithms\n\n## 1. Decomposing Permutations into Disjoint Cycles\n\n**Goal**: Convert a permutation array `p` where `p[i]` is image of `i` into cycle notation $(a, b, c)(d, e)$.\n**Method**:\n1.  Mark all elements as unvisited.\n2.  For each unvisited $i$, follow $i \\to p[i] \\to p[p[i]] \\dots$ until back to $i$.\n3.  This forms one cycle. Mark all in cycle as visited.\n**Complexity**: $O(N)$.\n\n## 2. Applying Burnside's Lemma\n\n**Goal**: Count distinct colorings of an object under symmetries.\n**Algorithm**:\n1.  Identify the group $G$ of symmetries (Rotation, Reflection).\n2.  For each $g \\in G$:\n    a. Decompose $g$ into $k$ disjoint cycles.\n    b. If we have $C$ colors, the number of fixed points $|fix(g)| = C^k$ (Each cycle must be monochromatic).\n3.  Sum results and divide by $|G|$.\n\n## 3. Generating Symmetry Groups\n\n*   **Cyclic Group $C_n$** (Rotations of regular $n$-gon): Generated by rotation $\\sigma$. Elements $\\{e, \\sigma, \\dots, \\sigma^{n-1}\\}$.\n*   **Dihedral Group $D_n$** (Rotations + Reflections): Size $2n$.\n    *   Rotations: $n$ elements.\n    *   Reflections: $n$ elements.\n        *   If $n$ odd: Axis through vertex and midpoint of opposite side.\n        *   If $n$ even: Half through vertices, half through midpoints of sides.\n\n## 4. Baby-step Giant-step for Discrete Log (Generalized)\n\nWorks for any finite cyclic group (not just modulo $p$).\nRequires group operations $a \\cdot b$ and inverse $a^{-1}$.\n\n## 5. Schreier-Sims Algorithm (Computational Group Theory)\n\n**Goal**: Determine the order of a permutation group generated by a set $S$.\n**Concept**: Uses Stabilizer Chain $G = G_0 \\ge G_1 \\ge \\dots \\ge G_k = \\{e\\}$.\n**Complexity**: Polynomial in $n$ (degree of permutation), unlike brute force $n!$.\n*   (Too advanced to implement fully here, but good to know existence).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Tricks and Patterns\n\n## 1. GCD of Polynomials\nJust like integers, polynomials have GCD.\n**Pattern**: Use `numpy.polynomial` or implement standard Euclidean algo for polynomials over a field. Use to find common roots.\n\n## 2. Power of Permutation\nTo compute $P^k$ for large $k$:\n1.  Decompose $P$ into cycles.\n2.  For a cycle of length $L$, the effect of $P^k$ is shifting elements by $k \\pmod L$.\n3.  Reconstruct the permutation.\n**Complexity**: $O(N)$. Much faster than matrix exponentiation or composition ($O(N \\log k)$ or $O(N)$ with composition overhead).\n\n## 3. Order of Permutation\nThe smallest $k$ such that $P^k = I$.\n**Trick**: $\\text{Order}(P) = \\text{LCM}(\\text{length of cycle}_1, \\dots, \\text{length of cycle}_m)$.\n**CP Application**: \"What is the maximum order of a permutation of size $N$?\" -> Landau's Function $g(n)$. Maximum LCM of partition of $n$.\n\n## 4. Fixed Points Calculation (Burnside Shortcut)\nFor rotational symmetry of $N$ items with $C$ colors:\n*   Rotation by $k$ units ($0 \\le k < N$).\n*   Number of cycles is $\\gcd(k, N)$.\n*   Contribution: $C^{\\gcd(k, N)}$.\n*   **Total**: $\\frac{1}{N} \\sum_{k=1}^N C^{\\gcd(k, N)}$.\n\n## 5. Conjugacy Classes\nIn $S_n$, two permutations are conjugate $\\iff$ they have the same cycle type (same number of cycles of each length).\n**Trick**: Iterate partitions of $N$ to sum over $S_n$ quickly using Polya, instead of iterating $n!$ elements.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "\"\"\"\nAbstract Algebra Algorithms Implementation.\n\nIncludes:\n1. Permutation Class (Composition, Power, Cycles).\n2. Burnside's Lemma Solver (for Rotational/Dihedral symmetries).\n3. Landau's Function (Max Order of Permutation).\n\"\"\"\n\nfrom typing import List, Tuple\nfrom math import gcd\n\n# ==============================================================================\n# 1. Permutation Operations\n# ==============================================================================\n\nclass Permutation:\n    def __init__(self, mapping: List[int]):\n        # mapping[i] is the image of i. Assumes 0-indexed elements 0..N-1\n        self.mapping = mapping\n        self.n = len(mapping)\n        \n    def __repr__(self):\n        return f\"Perm({self.mapping})\"\n\n    def __mul__(self, other: 'Permutation') -> 'Permutation':\n        # Composition: (f * g)(x) = f(g(x))\n        if self.n != other.n:\n            raise ValueError(\"Size mismatch\")\n        new_map = [self.mapping[other.mapping[i]] for i in range(self.n)]\n        return Permutation(new_map)\n\n    def get_cycles(self) -> List[List[int]]:\n        visited = [False] * self.n\n        cycles = []\n        for i in range(self.n):\n            if not visited[i]:\n                cycle = []\n                curr = i\n                while not visited[curr]:\n                    visited[curr] = True\n                    cycle.append(curr)\n                    curr = self.mapping[curr]\n                cycles.append(cycle)\n        return cycles\n\n    def power(self, k: int) -> 'Permutation':\n        # Apply permutation k times using cycle decomposition\n        # O(N) instead of O(N log K) composition\n        new_map = [0] * self.n\n        cycles = self.get_cycles()\n        \n        for cycle in cycles:\n            l = len(cycle)\n            shift = k % l\n            for idx, val in enumerate(cycle):\n                # The element at 'val' moves to cycle[(idx + shift) % l]\n                # Wait: mapping[i] is where i goes.\n                # If i is cycle[idx], it goes to cycle[idx+1].\n                # After k steps, it lands at cycle[(idx + k) % l].\n                target = cycle[(idx + shift) % l]\n                new_map[val] = target # val goes to target\n                \n        return Permutation(new_map)\n\n# ==============================================================================\n# 2. Burnside's Lemma / Polya Helpers\n# ==============================================================================\n\ndef count_necklace_embeddings(n: int, k: int) -> int:\n    \"\"\"\n    Count distinct necklaces with n beads and k colors under Rotation.\n    Formula: (1/n) * sum(k^gcd(i, n) for i in 1..n)\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        cycles = gcd(i, n)\n        total += k ** cycles\n    return total // n\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\ndef landau_function_dp(n: int) -> int:\n    \"\"\"\n    Computes g(n): Maximum order of an element of S_n.\n    Equivalent to Max LCM of partitions of n.\n    DP State: dp[i] = sets of possible LCMs summing to i? Too big.\n    Optimization: The partition consists of prime powers.\n    dp[j] = max LCM using sum j.\n    \"\"\"\n    # Primes up to n\n    primes = []\n    is_prime = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if is_prime[p]:\n            primes.append(p)\n            for i in range(p*p, n+1, p): is_prime[i] = False\n            \n    # dp[w] = max_lcm with weight w\n    dp = [1.0] * (n + 1) # Use float to avoid huge int overhead during intermediate steps? No, Python ints are fine.\n    dp_int = [1] * (n + 1)\n    \n    # Knapsack-like approach\n    for p in primes:\n        for w in range(n, -1, -1):\n            pp = p\n            while pp <= w:\n                dp_int[w] = max(dp_int[w], dp_int[w - pp] * pp)\n                pp *= p\n                \n    return max(dp_int)\n\nif __name__ == \"__main__\":\n    # Test Permutation\n    p = Permutation([1, 2, 0, 4, 3]) \n    # Cycles: (0 1 2), (3 4)\n    # Order: LCM(3, 2) = 6. P^6 should be identity.\n    p6 = p.power(6)\n    assert p6.mapping == [0, 1, 2, 3, 4]\n    \n    # Test Necklace\n    # 3 beads, 2 colors (Red, Blue)\n    # Patterns: RRR, BBB, RRB(x3->1), BBR(x3->1). Total 4.\n    # Formula: 1/3 * (2^gcd(1,3) + 2^gcd(2,3) + 2^gcd(3,3)) = 1/3 * (2^1 + 2^1 + 2^3) = 1/3 * (2+2+8) = 12/3 = 4.\n    assert count_necklace_embeddings(3, 2) == 4\n    \n    # Test Landau\n    # g(4) -> partition 4 into max lcm. 4->4, 3+1->3, 2+2->2, 2+1+1->2. Max is 4.\n    # g(5) -> 2,3 -> lcm 6.\n    assert landau_function_dp(5) == 6\n    \n    print(\"Abstract Algebra Implementations Verified.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Annotated Examples and Use Cases\n\n## 1. Coloring the Cube (Burnside's Lemma)\n\n**Problem**: How many ways to color the faces of a cube with 3 colors (R, G, B) under rotation?\n\n**Analysis of Symmetry Group $G$ (Rotations of Cube)**: $|G| = 24$.\n1.  **Identity** (1 element): Fixes 6 faces. Contribution $1 \\cdot 3^6$.\n2.  **Axis through opposite face centers** (3 axes $\\times$ 3 rotations - identity):\n    *   $90^\\circ$ (6 elements): Fixes 2 faces (axis), others cycle 4. Cycles=3. Contrib $6 \\cdot 3^3$.\n    *   $180^\\circ$ (3 elements): Fixes 2 faces, others cycle 2. Cycles=4. Contrib $3 \\cdot 3^4$.\n3.  **Axis through opposite edges** (6 axes $\\times$ 1 rotation $180^\\circ$):\n    *   (6 elements): Fixes 0 faces. 3 cycles of 2. Contrib $6 \\cdot 3^3$.\n4.  **Axis through opposite vertices** (4 axes $\\times$ 2 rotations):\n    *   (8 elements): Fixes 0 faces. 2 cycles of 3. Contrib $8 \\cdot 3^2$.\n\n**Calculation**:\nTotal = $\\frac{1}{24} (3^6 + 6 \\cdot 3^3 + 3 \\cdot 3^4 + 6 \\cdot 3^3 + 8 \\cdot 3^2)$\n$= \\frac{1}{24} (729 + 162 + 243 + 162 + 72) = \\frac{1368}{24} = 57$.\n\n**Answer**: 57 distinct cubes.\n\n## 2. 15-Puzzle Solvability (Group Theory Invariant)\n\n**Problem**: Given a scrambled 15-puzzle, is it solvable?\n**Invariant**: The **Parity** of the permutation of tiles plus the parity of the taxicab distance of the empty square from the bottom-right corner must be even.\n**Group Theory**:\n*   Swapping a tile with empty space is a transposition (odd permutation).\n*   One move changes parity of permutation AND parity of distance (row+col).\n*   Therefore, (Permutation Parity + Distance Parity) is **invariant** (mod 2).\n\n## 3. Rubik's Cube Groups\n\n**Theory**: The states of a Rubik's Cube form a Group generated by $\\{F, B, L, R, U, D\\}$ (Face turns).\nSize is approx $4.3 \\times 10^{19}$.\n**God's Number**: Maximum diameter of the Cayley Graph is 20 (every state is solvable in 20 moves). Proven computationally using group theory coset concepts.\n\n## 4. Error Correction: Reed-Solomon Code\n\n**Theory**: Encodes message as a polynomial over Finite Field $GF(2^m)$.\n**Algebra**:\n*   Message $a_0, \\dots, a_{k-1}$ defines $P(x) = \\sum a_i x^i$.\n*   Codeword is evaluations $[P(1), P(\\alpha), P(\\alpha^2) \\dots]$.\n*   Because two degree $k-1$ polynomials intersect at most $k-1$ points, this code has large Hamming Distance.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Problems and Solutions\n\n## Problem 1: Necklace with Constraints\n\n**Statement**: Count necklaces with 4 beads, colored Black or White, such that **no two Black beads are adjacent**.\n**Approach**: Burnside's Lemma with restricted fixed point counting.\n*   $N=4$, $G = C_4$ (Rotations: 0, 1, 2, 3).\n*   **Rot 0**: All valid linear strings of length 4 without 'BB'. Use DP/Fibonacci.\n    *   Matches: WWWW, WWWB, WWBW, WBWW, BWWW, WBWB, BWBW. (7 strings). Fixed = 7.\n*   **Rot 1 (90)**: Cycle (1 2 3 4). Monochromatic. 'WWWW', 'BBBB'. 'BBBB' invalid. Fixed = 1 (WWWW).\n*   **Rot 2 (180)**: Cycles (1 3)(2 4). Pattern XYXY. No BB implies X,Y cannot both be B.\n    *   (W, W) -> WWWW (Valid)\n    *   (W, B) -> WBWB (Valid)\n    *   (B, W) -> BWBW (Valid)\n    *   (B, B) -> BBBB (Invalid)\n    *   Fixed = 3.\n*   **Rot 3 (270)**: Same as Rot 1. Fixed = 1.\n\nSum: $(7 + 1 + 3 + 1) / 4 = 12 / 4 = 3$.\nPatterns: WWWW, One B (any pos), Two B opposite (BWBW).\n(Note: WBWB is unique. WWBB is invalid. WBBW invalid. WWWB is One B rotated. So 3 is correct: No B, One B, Two Opposite B).\n\n## Problem 2: Permutation Iteration\n\n**Statement**: Given permutation $P$, find $Q$ such that $Q^2 = P$.\n**Theory**:\n*   If $P$ has a cycle of length $L$:\n    *   If $L$ is odd, $Q$ maps to this cycle by \"interleaving\". (Cycle $1 \\to 3 \\to 5 \\dots$).\n    *   If $L$ is even, we need TWO cycles of length $L$ in $P$ to merge into one cycle of length $2L$ in $Q$.\n*   Condition: Count of even length cycles of each size must be even.\n\n## Problem 3: Giant Step\n\n**Statement**: Find the size of the group generated by two integers $a, b$ modulo $n$ under multiplication.\n**Group**: Subgroup of $\\mathbb{Z}_n^*$.\n**Approach**:\n*   This is not just simple LCM.\n*   The group elements are $a^i b^j \\pmod n$.\n*   This forms a 2D lattice structure in the exponents modulo order(a) and order(b), interacting if they share structure.\n*   Generally simply traverse BFS from 1, multiplying by $a$ and $b$ until no new elements found (for small $n$).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Advanced Notes and Research Directions\n\n## 1. Representation Theory\n\nStudying groups by mapping them to Matrix Groups (GL(n)).\n*   **Character Theory**: Trace of the representation matrices. Simplifies group analysis significantly (e.g., Burnside's $p^a q^b$ theorem).\n*   **Application**: FFT is essentially Representation Theory of finite relationships. Non-abelian FFT uses representations of non-commutative groups.\n\n## 2. Monster Group\n\nThe largest sporadic simple group. Order $\\approx 8 \\times 10^{53}$.\n**Monstrous Moonshine**: Connection between the Monster Group and Modular Functions in Number Theory.\n\n## 3. Lattice-Based Cryptography\n\n**Lattices**: A discrete subgroup of $\\mathbb{R}^n$ (like a grid).\n**Shortest Vector Problem (SVP)**: Hard problem that is basis for Post-Quantum Cryptography (kyber, Dilithium).\nUnlike RSA/ECC, Lattice problems are believed to be hard even for Quantum Computers.\n\n## 4. Category Theory\n\nThe \"Algebra of Algebra\". Abstracts structures (objects) and mappings (morphisms).\n**Haskell/Functional Programming**: Deeply connected to Category Theory (Monads, Functors).\n*   A **Monad** is \"just a monoid in the category of endofunctors\".\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Rigorous Foundations of Calculus\n\n## 1. The Real Number System ($\\mathbb{R}$)\n\nUnlike floating point numbers in computers, Real Numbers ($\\mathbb{R}$) are **Continuous** and **Complete**.\n*   **Completeness Axiom**: Every non-empty subset of $\\mathbb{R}$ that is bounded above has a **Least Upper Bound** (Supremum).\n*   **Implication for CS**: Floating point arithmetic breaks these axioms (e.g., associativity errors, underflow). Understanding \"Epsilon\" ($\\epsilon$) is crucial.\n\n## 2. Sequences and Convergence\n\nA sequence $(x_n)$ converges to $L$ ($\\lim_{n \\to \\infty} x_n = L$) if:\n$$ \\forall \\epsilon > 0, \\exists N \\in \\mathbb{N} \\text{ such that } \\forall n \\ge N, |x_n - L| < \\epsilon $$\n*   **Cauchy Sequence**: Items get closer to *each other*. In $\\mathbb{R}$, Cauchy $\\iff$ Convergent.\n*   **Big-O Notation**: Formally defined using limits superior. $f(n) = O(g(n)) \\iff \\limsup |f(n)/g(n)| < \\infty$.\n\n## 3. Continuity and Limits\n\nA function $f$ is continuous at $c$ if $\\lim_{x \\to c} f(x) = f(c)$.\n*   **Delta-Epsilon Definition**: $\\forall \\epsilon > 0, \\exists \\delta > 0$ such that $|x - c| < \\delta \\implies |f(x) - f(c)| < \\epsilon$.\n*   **Lipschitz Continuity**: $|f(x) - f(y)| \\le K |x - y|$. Stronger than uniform continuity. Critical in **GANs (Generative Adversarial Networks)** training stability (Wasserstein GAN).\n\n## 4. Derivatives and Smoothness\n\nSlope of the tangent line.\n$$ f'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h} $$\n*   **Differentiability classes ($C^k$)**:\n    *   $C^0$: Continuous.\n    *   $C^1$: Differentiable, derivative is continuous (Smooth-ish).\n    *   $C^\\infty$: Infinitely differentiable (Smooth).\n    *   **ReLU**: Not $C^1$ at 0. But practically useful.\n\n## 5. Taylor Series\n\nApproximating functions with polynomials.\n$$ f(x) \\approx \\sum_{n=0}^k \\frac{f^{(n)}(a)}{n!} (x-a)^n $$\n*   **CS Application**: Optimization algorithms (Newton's Method) use 2nd order Taylor approximation.\n\n## 6. Integration (Riemann vs Lebesgue)\n\n*   **Riemann**: Sum of rectangles. Good for continuous functions.\n*   **Lebesgue**: Partitions the range. Handles weird functions (like Dirichlet function). standard necessity for Probability Theory.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Methods and Algorithms\n\n## 1. Root Finding (Solving $f(x) = 0$)\n\n### 1.1 Bisection Method\n**Theory**: Intermediate Value Theorem. If $f(a)$ and $f(b)$ have opposite signs, a root exists in $[a, b]$.\n**Algo**: Check mid. Recurse.\n**Complexity**: Linear choice of accuracy ($O(\\log(1/\\epsilon))$).\n\n### 1.2 Newton-Raphson Method\n**Theory**: Linear approximation using derivative.\n**Algo**: $x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$.\n**Convergence**: Quadratic (doubles digits of precision per step) if close to root.\n\n## 2. Numerical Differentiation\n\nHow to calculate $f'(x)$ if we only have $f$ as a black box?\n*   **Finite Difference**:\n    *   Forward: $\\frac{f(x+h) - f(x)}{h}$. Error $O(h)$.\n    *   Central: $\\frac{f(x+h) - f(x-h)}{2h}$. Error $O(h^2)$. (Much Better).\n*   **Automatic Differentiation (Autodiff)**: The heart of PyTorch/TensorFlow. Applies Chain Rule exactly to computer programs. NOT numerical differentiation.\n\n## 3. Numerical Integration (Quadrature)\n\nCalculating $\\int_a^b f(x) dx$.\n*   **Trapezoidal Rule**: Connect points with lines. Error $O(h^2)$.\n*   **Simpson's Rule**: Connect with parabolas. Error $O(h^4)$.\n*   **Monte Carlo Integration**: Sample random points. $\\frac{1}{N} \\sum f(x_i)$. Error $O(1/\\sqrt{N})$. Good for high dimensions.\n\n## 4. Fixed Point Iteration\n\nSolving $x = g(x)$.\n**Banach Fixed Point Theorem**: If $g$ is a contraction mapping (Lipschitz constant $K < 1$), then $x_{n+1} = g(x_n)$ converges to unique fixed point.\n**App**: PageRank, iterative linear solvers.\n\n## 5. Golden Section Search\n\nFinding min/max of unimodal function without derivatives.\nMaintains a bracket $[a, b]$ and two inner points $c, d$.\nRatio $(b-a)/(d-a)$ is the Golden Ratio $\\phi$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Tricks and Patterns\n\n## 1. Handling Floating Point (The \"Epsilon\" Pattern)\n\nIn Python/C++, never strictly check `a == b` for floats.\n**Pattern**:\n```python\nEPS = 1e-9\nif abs(a - b) < EPS: ...\n```\n\n## 2. Log-Sum-Exp Trick\n\nWhen computing $\\log(\\sum e^{x_i})$ (common in ML softmax), naive computation overflows if $x_i$ is large.\n**Trick**:\n$$ \\log(\\sum e^{x_i}) = \\max(x) + \\log(\\sum e^{x_i - \\max(x)}) $$\nThis effectively shifts exponents to be $\\le 0$, preventing overflow.\n\n## 3. Finding Roots of Monotonic Functions\nIf you need to invert a monotonic function $y = f(x)$ (find $x$ for given $y$):\n**Pattern**: Use Binary Search on the Answer.\n*   Continuous domain: Bisection usually 60-100 iterations gives high precision.\n*   Discrete domain: Standard binary search.\n\n## 4. Convexity Tricks\nIf $f$ is Convex ($f'' > 0$):\n*   Local minimum is Global minimum.\n*   **Jensen's Inequality**: $E[f(X)] \\ge f(E[X])$.\n*   **Ternary Search**: Use to find minimum of unimodal function in $O(\\log n)$.\n\n## 5. Kahan Summation Algorithm\n\nSumming a large array of floats accumulates error.\n**Trick**: Maintain a `c` (compensation) variable to track low-order bits lost in addition.\nReduces error from $O(N \\epsilon)$ to $O(1 \\epsilon)$ effectively.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "\"\"\"\nReal Analysis Algorithms Implementation.\n\nIncludes:\n1. Root Finding (Newton, Bisection).\n2. Numerical Integration (Simpson).\n3. Kahan Summation.\n4. AutoDiff (Toy Implementation of Forward Mode).\n\"\"\"\n\nfrom typing import Callable, List, Union\nimport math\n\n# ==============================================================================\n# 1. Root Finding\n# ==============================================================================\n\ndef bisection_method(f: Callable[[float], float], a: float, b: float, tol=1e-9) -> float:\n    if f(a) * f(b) > 0:\n        raise ValueError(\"No root bracketed\")\n    \n    mid = 0.0\n    for _ in range(100): # Hard limit prevents infinite loops\n        mid = (a + b) / 2\n        if (b - a) < tol:\n            return mid\n        if f(mid) == 0:\n            return mid\n        \n        if f(a) * f(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return mid\n\ndef newton_method(f: Callable[[float], float], df: Callable[[float], float], x0: float, tol=1e-9) -> float:\n    x = x0\n    for _ in range(100):\n        y = f(x)\n        dy = df(x)\n        if abs(y) < tol:\n            return x\n        if dy == 0:\n            raise ValueError(\"Derivative zero\")\n        x = x - y / dy\n    return x\n\n# ==============================================================================\n# 2. Numerical Integration\n# ==============================================================================\n\ndef simpsons_rule(f: Callable[[float], float], a: float, b: float, n: int) -> float:\n    \"\"\"\n    Approximates definite integral using Simpson's 1/3 rule.\n    n must be even.\n    \"\"\"\n    if n % 2 != 0: n += 1\n    h = (b - a) / n\n    s = f(a) + f(b)\n    \n    for i in range(1, n, 2):\n        s += 4 * f(a + i * h)\n    for i in range(2, n - 1, 2):\n        s += 2 * f(a + i * h)\n        \n    return s * h / 3\n\n# ==============================================================================\n# 3. Kahan Summation\n# ==============================================================================\n\ndef kahan_sum(arr: List[float]) -> float:\n    sum_val = 0.0\n    c = 0.0 # Compensation for lost low-order bits\n    for x in arr:\n        y = x - c\n        t = sum_val + y\n        c = (t - sum_val) - y\n        sum_val = t\n    return sum_val\n\n# ==============================================================================\n# 4. Toy Automatic Differentiation (Forward Mode)\n# ==============================================================================\n\nclass Dual:\n    \"\"\"\n    Represents a number a + b*epsilon where epsilon^2 = 0.\n    val: value\n    der: derivative component\n    \"\"\"\n    def __init__(self, val: float, der: float = 0.0):\n        self.val = val\n        self.der = der\n        \n    def __repr__(self):\n        return f\"Dual(val={self.val}, der={self.der})\"\n    \n    def __add__(self, other):\n        other = other if isinstance(other, Dual) else Dual(other)\n        return Dual(self.val + other.val, self.der + other.der)\n    \n    def __mul__(self, other):\n        other = other if isinstance(other, Dual) else Dual(other)\n        # Product Rule: (u*v)' = u'v + uv'\n        return Dual(self.val * other.val, self.der * other.val + self.val * other.der)\n    \n    def sin(self):\n        # Chain Rule: sin(u)' = cos(u) * u'\n        return Dual(math.sin(self.val), math.cos(self.val) * self.der)\n\ndef differentiate(func: Callable[[Dual], Dual], x: float) -> float:\n    \"\"\"\n    Computes derivative of func at x using Forward Mode Basic.\n    \"\"\"\n    d = Dual(x, 1.0) # Seed derivative 1\n    res = func(d)\n    return res.der\n\nif __name__ == \"__main__\":\n    # Test Root Finding (x^2 - 4 = 0)\n    root_bis = bisection_method(lambda x: x*x - 4, 0, 5)\n    assert abs(root_bis - 2.0) < 1e-6\n    \n    root_newt = newton_method(lambda x: x*x - 4, lambda x: 2*x, 5)\n    assert abs(root_newt - 2.0) < 1e-9\n    \n    # Test Integration (Integral x^2 dx from 0 to 3 is x^3/3 = 9)\n    integ = simpsons_rule(lambda x: x*x, 0, 3, 100)\n    assert abs(integ - 9.0) < 1e-6\n    \n    # Test Autodiff (derivative of x^2 + 2x at x=3 is 2x+2 = 8)\n    def my_func(x):\n        return x*x + Dual(2)*x\n    \n    der_val = differentiate(my_func, 3.0)\n    assert abs(der_val - 8.0) < 1e-9\n    \n    print(\"All Real Analysis Implementations Verified.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Annotated Examples and Use Cases\n\n## 1. Gradient Descent (Optimization)\n\n**Scenario**: Training a Neural Network. Minimizing Loss $L(\\theta)$.\n**Methods**:\n*   **Gradient Descent**: $\\theta_{new} = \\theta_{old} - \\alpha \\nabla L(\\theta)$.\n*   Relies on the derivative pointing in direction of steepest ascent.\n*   **Lipschitz Continuity** ensures that if we take a small enough step ($\\alpha < 1/L$), we strictly decrease Loss.\n\n## 2. Audio Processing (Signals)\n\n**Theory**: Fourier Series implies any periodic function (sound wave) can be represented as sum of infinite sines/cosines.\n**Real Analysis**: Convergence of Fourier Series.\n*   Phenomenon: **Gibbs Phenomenon** at discontinuities (ringing artifacts).\n*   Sampling Theorem (Nyquist-Shannon): Needs rigorous limits to prove.\n\n## 3. Zeno's Paradoxes and Infinite Series\n\n**Problem**: Achilles and the Tortoise. To catch up, Achilles travels half distance, then half remaining... does he ever reach?\n**Analysis**: The sum of an infinite Geometric Series exists and is finite.\n$$ \\sum_{n=1}^\\infty (1/2)^n = 1 $$\nThis resolved centuries of philosophical debate.\n\n## 4. Probability Density Functions (PDF)\n\n**Scenario**: Normal Distribution.\n**Area**: $\\int_{-\\infty}^\\infty \\frac{1}{\\sqrt{2\\pi}} e^{-x^2/2} dx = 1$.\n**Improper Integrals**: Integration over infinite bounds requires Limits: $\\lim_{t \\to \\infty} \\int_{-t}^t$.\n\n## 5. Detecting Edge Cases (Analysis helps bugs)\n\n*   **Function**: $f(x) = 1/x$.\n*   **Problem**: Not continuous at 0.\n*   **Code**: `if abs(x) < 1e-9: raise ValueError`.\n*   **Mathematical Insight**: The limit $\\lim_{x \\to 0^+} f(x) = \\infty$, $\\lim_{x \\to 0^-} f(x) = -\\infty$. Discontinuity is essential, not just a nuisance.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Problems and Solutions\n\n## Problem 1: Square Root without Math Library\n\n**Statement**: Compute `sqrt(n)` to precision `p`.\n**Approach**: Newton's Method on $f(x) = x^2 - n$.\n*   $f'(x) = 2x$.\n*   Update: $x \\leftarrow x - (x^2 - n)/(2x) = (x + n/x) / 2$.\n*   This is the Babylonian Method.\n\n**Python**:\n```python\ndef my_sqrt(n):\n    if n < 0: raise ValueError\n    x = n\n    while abs(x*x - n) > 1e-10:\n        x = (x + n/x) / 2\n    return x\n```\n\n## Problem 2: Ternary Search for Unimodal Max\n\n**Statement**: Given a function $f(x)$ that strictly increases then strictly decreases, find peak.\n**Approach**:\n*   Pick two points $m1 = l + (r-l)/3$, $m2 = r - (r-l)/3$.\n*   If $f(m1) < f(m2)$, peak is in $[m1, r]$.\n*   Else, peak is in $[l, m2]$.\n*   Converges in $O(\\log n)$.\n\n## Problem 3: Simpson's Paradox (Probability/Stats boundary)\n\n(Actually a Stats problem, replacing with Analysis problem).\n\n## Problem 3: Continuous Knapsack (Greedy Analysis)\n\n**Statement**: You can cut items (continuous). Maximize value in weight $W$.\n**Analysis**:\n*   Sort items by density $v_i / w_i$.\n*   Take whole items until $W$ full. Take fraction of last item.\n*   **Proof**: Exchange argument. If you take simpler density item instead of higher, you lose total value. This relies on the \"Intermediate Value\" property of continuous mass.\n\n## Problem 4: Finding Fixed Point\n\n**Statement**: $f: [0, 1] \\to [0, 1]$ is continuous. Prove $f(x)=x$ has a solution and find it.\n**Analytical Proof**: Let $g(x) = f(x) - x$.\n$g(0) = f(0) - 0 \\ge 0$.\n$g(1) = f(1) - 1 \\le 0$.\nBy IVT, exists $c$ such that $g(c)=0 \\implies f(c)=c$.\n**Algo**: Bisection method on $f(x)-x$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Advanced Notes and Research Directions\n\n## 1. Metric Spaces and Topology\n\n$\\mathbb{R}$ is just one example of a Metric Space (Set with distance function).\n*   **Topology**: Generalized notions of \"open sets\" and \"continuity\" without distance.\n*   **Manifolds**: Spaces that look like $\\mathbb{R}^n$ locally. (e.g., surface of a sphere).\n*   **Manifold Learning**: ML technique assuming high-dim data lies on low-dim manifold.\n\n## 2. Measure Theory\n\nGeneralizing \"length\" and \"volume\".\n*   **Lebesgue Measure**: The standard way to assign size to sets.\n*   **Probability Theory**: Formally defined as Measure Theory with total measure 1.\n*   **Almost Everywhere (a.e.)**: Property holds everywhere except on a set of measure zero. (e.g., $ReLU$ is differentiable a.e.).\n\n## 3. Functional Analysis\n\nVector spaces where \"vectors\" are functions.\n*   **Hilbert Spaces**: Complete inner product spaces (infinite dimensions). Basis for Quantum Mechanics.\n*   **Reproducing Kernel Hilbert Spaces (RKHS)**: The math behind Kernel Machines (SVMs) and Gaussian Processes.\n\n## 4. Fourier Analysis (Harmonic Analysis)\n\nDecomposing functions into frequencies.\n*   **Wavelets**: Localized frequency analysis. Used in JPEG2000 and signal denoising.\n*   **Sparse Fourier Transform**: Algorithms faster than FFT for sparse signals.\n\n## 5. Non-Standard Analysis\n\nRigorous formulation of calculus using infinitesimals (hyperreal numbers).\n*   Justifies logical intuition of $dx$ as an infinitely small number.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: The Geometry of Numbers\n\n## 1. Complex Numbers $\\mathbb{C}$\n\nExtensions of reals with $i^2 = -1$.\n*   **Form**: $z = x + iy$.\n*   **Polar Form**: $z = r e^{i\\theta} = r (\\cos \\theta + i \\sin \\theta)$.\n*   **Euler's Formula**: $e^{i\\pi} + 1 = 0$.\n\n### 1.1 Geometry\n*   Addition: Vector addition in 2D plane.\n*   Multiplication: Scale lengths ($r_1 r_2$), Add angles ($\\theta_1 + \\theta_2$).\n*   **Roots of Unity**: Solutions to $z^n = 1$. Form a regular $n$-gon. Critical for FFT.\n\n## 2. Holomorphic Functions\n\nComplex differentiable functions. This is a MUCh stronger condition than real differentiability.\n$$ f'(z_0) = \\lim_{z \\to z_0} \\frac{f(z) - f(z_0)}{z - z_0} $$\nLimit must be independent of direction of approach.\n\n### 2.1 Cauchy-Riemann Equations\nFor $f(z) = u(x, y) + i v(x, y)$ to be holomorphic:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y} \\quad \\text{and} \\quad \\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x} $$\nConsequence: Holomorphic functions are $C^\\infty$ (infinitely differentiable) and **Analytic** (equal to their Taylor series).\n\n## 3. Cauchy's Integral Theorem\n\nIf $f$ is holomorphic on a simply connected domain and $\\gamma$ is a closed loop:\n$$ \\oint_\\gamma f(z) dz = 0 $$\n**Path Independence**: Integration between two points is independent of path.\n\n### 3.1 Cauchy's Integral Formula\nValue inside a loop is determined by values on boundary:\n$$ f(a) = \\frac{1}{2\\pi i} \\oint_\\gamma \\frac{f(z)}{z-a} dz $$\n\n## 4. Residue Theorem\n\nA powerful tool to evaluate integrals.\n$$ \\oint_\\gamma f(z) dz = 2\\pi i \\sum \\text{Res}(f, a_k) $$\nwhere $a_k$ are singularities inside $\\gamma$.\n*   **Residue**: The coefficient $c_{-1}$ in the Laurent Series $\\sum c_n (z-a)^n$.\n\n## 5. Conformal Mapping\n\nHolomorphic functions preserve angles (conformal).\n*   **Riemann Mapping Theorem**: Any simply connected non-empty open subset of $\\mathbb{C}$ (not whole $\\mathbb{C}$) can be mapped bijectively to the open unit disk.\n*   **App**: Solving fluid flow (aerodynamics) on complex shapes by mapping shape to a circle.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Methods and Algorithms\n\n## 1. Fast Fourier Transform (FFT)\n\nThe most important algorithm in history ($O(N \\log N)$).\n**Theory**: Evaluating a polynomial $P(x)$ at $n$-th Roots of Unity.\n**Divide and Conquer**:\n$P(x) = P_{even}(x^2) + x P_{odd}(x^2)$.\nUsing $\\omega_n^k$, we exploit symmetry $\\omega_n^{k + n/2} = -\\omega_n^k$.\n\n## 2. M\u00f6bius Transformations\n\nBijective maps from extended complex plane to itself.\n$$ f(z) = \\frac{az + b}{cz + d} $$\n*   Maps circles/lines to circles/lines.\n*   Used in **Image Processing** for warping.\n\n## 3. Contour Integration (for Real Integrals)\n\nTechnique to solve hard real integrals $\\int_{-\\infty}^\\infty f(x) dx$ by \"completing the contour\" in the complex plane and summing Residues.\n**Method**:\n1.  Choose semi-circle contour.\n2.  Show integral on arc $\\to 0$ as $R \\to \\infty$ (Jordan's Lemma).\n3.  Answer is $2\\pi i \\sum \\text{Residues}$.\n\n## 4. Generating Fractal Images (Mandelbrot)\n\nIterating $z_{n+1} = z_n^2 + c$.\n*   **Mandelbrot Set**: $c$ such that $|z_n|$ remains bounded starting $z_0 = 0$.\n*   **Julia Sets**: Fixed $c$, vary $z_0$.\n\n## 5. Phase Unwrapping\n\nIn signal processing, we compute phase $\\phi(t) = \\text{arg}(z(t))$.\nThis value jumps by $2\\pi$.\n**Algorithm**: Detect jumps $>\\pi$ and add $\\pm 2\\pi$ to make phase continuous.\nEssential for Radar/Sonar processing.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Tricks and Patterns\n\n## 1. Roots of Unity Tricks\n\n### 1.1 Sum of Roots\nSum of all $n$-th roots of unity is 0 (for $n > 1$).\n$\\sum_{k=0}^{n-1} \\omega^k = \\frac{\\omega^n - 1}{\\omega - 1} = 0$.\n\n### 1.2 Filtering\nTo extract coefficients where index is multiple of $k$:\nEvaluate polynomial at all $k$-th roots of unity and average.\n**App**: Solving combinatorial problems with modulo constraints.\n\n## 2. Rotation as Multiplication\n\nTo rotate a 2D point $(x, y)$ by $\\theta$:\nDon't use $2 \\times 2$ matrices.\nUse $z = x + iy$.\n$z_{new} = z \\cdot e^{i\\theta}$.\nMuch cleaner code and math derivation.\n\n## 3. Analytic Continuation\n\nIf two holomorphic functions agree on a small line segment, they agree everywhere.\n**Trick**: Prove identity for real $x$, it holds for complex $z$.\nExample: $\\sin^2 z + \\cos^2 z = 1$ is true for all $\\mathbb{C}$.\n\n## 4. Argument Principle\n\nTo count zeros of $f(z)$ inside a contour:\n$$ \\frac{1}{2\\pi i} \\oint \\frac{f'(z)}{f(z)} dz = N - P $$\n($N$ zeros, $P$ poles).\n**App**: Nyquist Stability Criterion in Control Theory.\n\n## 5. Identifying Circle Equation\nEquation $|z - a| = r$ is a circle.\nCan be expanded: $(z-a)(\\bar{z}-\\bar{a}) = r^2$.\n$z\\bar{z} - z\\bar{a} - \\bar{z}a + |a|^2 - r^2 = 0$.\nUseful in computational geometry involving inversion.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "\"\"\"\nComplex Analysis Algorithms Implementation.\n\nIncludes:\n1. Complex Number Basic Operations (Demo).\n2. Iterative FFT (Cooley-Tukey).\n3. Mandelbrot Set Generator.\n4. M\u00f6bius Transformation Class.\n\"\"\"\n\nfrom typing import List, Tuple\nimport math\nimport cmath\n\n# ==============================================================================\n# 1. FFT (Iterative)\n# ==============================================================================\n\ndef fft(a: List[complex], inverse: bool = False) -> List[complex]:\n    \"\"\"\n    Computes FFT of array a. Len(a) must be power of 2.\n    \"\"\"\n    n = len(a)\n    if (n & (n - 1)) != 0:\n        raise ValueError(\"Length must be power of 2\")\n        \n    # Bit Reversal Permutation\n    # O(N)\n    b = list(a)\n    shifts = n.bit_length() - 1\n    for i in range(n):\n        # Reverse bits of i\n        rev = 0\n        temp = i\n        for _ in range(shifts):\n            rev = (rev << 1) | (temp & 1)\n            temp >>= 1\n        if i < rev:\n            b[i], b[rev] = b[rev], b[i]\n            \n    # Cooley-Tukey Butterfly\n    # O(N log N)\n    length = 2\n    while length <= n:\n        angle = 2 * math.pi / length * (-1 if inverse else 1)\n        wlen = cmath.exp(complex(0, angle))\n        for i in range(0, n, length):\n            w = 1 + 0j\n            for j in range(length // 2):\n                u = b[i + j]\n                v = b[i + j + length // 2] * w\n                b[i + j] = u + v\n                b[i + j + length // 2] = u - v\n                w *= wlen\n        length *= 2\n        \n    if inverse:\n        for i in range(n):\n            b[i] /= n\n            \n    return b\n\ndef multiply_polynomials_fft(p1: List[int], p2: List[int]) -> List[int]:\n    \"\"\"\n    Multiplies two polynomials using FFT.\n    Takes coeffs, returns coeffs of product.\n    \"\"\"\n    n = 1\n    while n < len(p1) + len(p2): n *= 2\n    \n    fa = [complex(x, 0) for x in p1] + [0] * (n - len(p1))\n    fb = [complex(x, 0) for x in p2] + [0] * (n - len(p2))\n    \n    fa = fft(fa)\n    fb = fft(fb)\n    \n    fc = [fa[i] * fb[i] for i in range(n)]\n    \n    res_complex = fft(fc, inverse=True)\n    return [round(x.real) for x in res_complex]\n\n# ==============================================================================\n# 2. M\u00f6bius Transformation\n# ==============================================================================\n\nclass MobiusTransform:\n    def __init__(self, a, b, c, d):\n        # f(z) = (az + b) / (cz + d)\n        self.mat = [[a, b], [c, d]]\n        \n    def apply(self, z: complex) -> complex:\n        num = self.mat[0][0] * z + self.mat[0][1]\n        den = self.mat[1][0] * z + self.mat[1][1]\n        if den == 0:\n            return float('inf') # Point at infinity\n        return num / den\n\n    def compose(self, other: 'MobiusTransform') -> 'MobiusTransform':\n        # Composition corresponds to matrix multiplication\n        a1, b1 = self.mat[0]\n        c1, d1 = self.mat[1]\n        a2, b2 = other.mat[0]\n        c2, d2 = other.mat[1]\n        \n        return MobiusTransform(\n            a1*a2 + b1*c2, a1*b2 + b1*d2,\n            c1*a2 + d1*c2, c1*b2 + d1*d2\n        )\n\nif __name__ == \"__main__\":\n    # Test FFT Mult: (1 + x)(1 + x) = 1 + 2x + x^2\n    p1 = [1, 1]\n    p2 = [1, 1]\n    res = multiply_polynomials_fft(p1, p2)\n    # Expected [1, 2, 1, 0...]\n    assert res[0] == 1 and res[1] == 2 and res[2] == 1\n    \n    # Test Mobius\n    # f(z) = 1/z  (a=0, b=1, c=1, d=0)\n    inv = MobiusTransform(0, 1, 1, 0)\n    z = 2 + 0j\n    assert abs(inv.apply(z) - 0.5) < 1e-9\n    \n    print(\"Complex Analysis Implementations Verified.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Annotated Examples and Use Cases\n\n## 1. Electrical Engineering: AC Circuits\n\n**Concept**: Impedance.\n*   Resistors: Real. $R$.\n*   Inductors: Imaginary. $j\\omega L$.\n*   Capacitors: Imaginary negative. $1/(j\\omega C)$.\n*   **Ohm's Law**: $V = I Z$ (Complex numbers).\n*   Greatly simplifies differential equations to algebraic equations.\n\n## 2. Fluid Dynamics: Potential Flow\n\n**Concept**: Modeling ideal (inviscid, incompressible) flow in 2D.\n*   Velocity Potential $\\phi$. Stream Function $\\psi$.\n*   Complex Potential: $w(z) = \\phi + i \\psi$.\n*   Velocity vector field is $\\overline{w'(z)}$.\n*   **Joukowski Transform**: Maps circle to airfoil shape. Foundational for early aeronautics.\n\n## 3. Quantum Mechanics\n\n**Wavefunction**: $\\Psi(x, t)$ is complex-valued.\n*   Probability: $|\\Psi|^2$.\n*   Phase is physically meaningful (Interference).\n*   Schr\u00f6dinger Equation involves $i$: $i \\hbar \\frac{\\partial}{\\partial t} \\Psi = \\hat{H} \\Psi$.\n\n## 4. Control Theory: Root Locus\n\n**Problem**: Stability of feedback systems.\n**poles**: Roots of denominator of Transfer Function $H(s)$.\n**Condition**: System is stable if all poles have **negative real part** (Left Half Plane).\n**Nyquist Plot**: Contour integral of transfer function to count poles around origin.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Problems and Solutions\n\n## Problem 1: Integration via Residues\n\n**Statement**: Evaluate $I = \\int_{-\\infty}^\\infty \\frac{1}{x^2 + 1} dx$.\n**Real Method**: $\\arctan(x)|_{-\\infty}^\\infty = \\pi/2 - (-\\pi/2) = \\pi$.\n**Complex Method**:\n1.  Consider $f(z) = \\frac{1}{z^2 + 1}$. Singularities at $z = \\pm i$.\n2.  Contour: Semi-circle in upper half plane $R \\to \\infty$.\n3.  Residue at $z=i$: $\\lim_{z \\to i} (z-i) \\frac{1}{(z-i)(z+i)} = \\frac{1}{2i}$.\n4.  Integral = $2\\pi i \\times \\text{Res} = 2\\pi i (1/2i) = \\pi$. Matches.\n\n## Problem 2: Counting Roots (Rouche's Theorem)\n\n**Statement**: How many roots does $z^5 + 3z + 1 = 0$ have inside $|z| < 1$?\n**Theorem**: If $|g(z)| < |f(z)|$ on boundary, $f$ and $f+g$ have same number of zeros.\n**Attempt**:\n*   Let $f(z) = 3z$, $g(z) = z^5 + 1$.\n*   On boundary $|z|=1$: $|f(z)| = 3$. $|g(z)| \\le |z|^5 + 1 = 2$.\n*   Since $2 < 3$, $|g| < |f|$.\n*   $f(z)=3z$ has 1 zero inside.\n*   Therefore, $z^5 + 3z + 1$ has **1 zero** inside.\n\n## Problem 3: Conformal Map Construction\n\n**Statement**: Map Upper Half Plane ($\\text{Im}(z) > 0$) to Unit Disk ($|w| < 1$).\n**Ansatz**: M\u00f6bius transform.\n*   Map $i \\to 0$ (Center).\n*   Map $0 \\to -1$ (Boundary).\n*   Map $\\infty \\to 1$ (Boundary).\n**Result**: $f(z) = \\frac{z-i}{z+i}$.\n*   This is the **Cayley Transform**.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Advanced Notes and Research Directions\n\n## 1. Riemann Zeta Function $\\zeta(s)$\n\nDefined as $\\sum n^{-s}$ for Re($s$) > 1. Analytic continuation to $\\mathbb{C}$.\n*   **Riemann Hypothesis (Millennium Prize)**: All non-trivial zeros lie on Re($s$) = 1/2.\n*   Deep connection to distribution of Prime Numbers.\n\n## 2. Several Complex Variables\n\n$\\mathbb{C}^n$ is much weirder than $\\mathbb{C}^1$.\n*   **Hartogs' Extension Theorem**: Singularities cannot be isolated points (unlike $\\mathbb{C}^1$ where $1/z$ has singularity at 0). Holes in domain are \"filled in\" by holomorphic functions.\n*   **Domains of Holomorphy**: Only specific shapes allow functions that don't extend beyond them.\n\n## 3. Modular Forms\n\nFunctions on the upper half plane satisfying symmetries under $SL_2(\\mathbb{Z})$ group actions.\n$$ f\\left(\\frac{az+b}{cz+d}\\right) = (cz+d)^k f(z) $$\n*   Crucial in proof of **Fermat's Last Theorem**.\n*   String Theory uses Modular Forms extensively.\n\n## 4. Complex Dynamics\n\nStudy of iteration $f(f(...z...))$.\n*   **Fatou Set**: Values behave normally.\n*   **Julia Set**: Values behave chaotically.\n*   Essential for Chaos Theory.\n"}, {"id": "Python_Theory/01_Introduction/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/01_Introduction/01_Definition.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": "# What is Python?\n\n## Definition\n**Python** is a high-level, interpreted, general-purpose programming language. Created by Guido van Rossum and first released in 1991, Python emphasizes code readability with its notable use of significant indentation.\n\n## Key Characteristics\n\n### 1. High-Level Language\n- Abstracts away low-level details (memory management, hardware interaction).\n- Focuses on problem-solving rather than machine-level operations.\n\n### 2. Interpreted\n- Code is executed line-by-line by the Python interpreter.\n- No separate compilation step required (unlike C/C++).\n- Makes debugging easier but can be slower than compiled languages.\n\n### 3. Dynamically Typed\n- Variable types are determined at runtime.\n- No need to declare types explicitly: `x = 5` (Python infers `int`).\n\n### 4. Multi-Paradigm\nSupports multiple programming styles:\n- **Procedural**: Step-by-step instructions.\n- **Object-Oriented**: Classes and objects.\n- **Functional**: Functions as first-class citizens, lambda expressions.\n\n### 5. Cross-Platform\n- Runs on Windows, macOS, Linux, and more.\n- \"Write once, run anywhere\" philosophy.\n\n## Python Philosophy (The Zen of Python)\nType `import this` in Python to see the full philosophy. Key principles:\n- **Beautiful is better than ugly.**\n- **Explicit is better than implicit.**\n- **Simple is better than complex.**\n- **Readability counts.**\n\n## Version Note\n- **Python 2.x**: Legacy (officially discontinued January 1, 2020).\n- **Python 3.x**: Current standard. This course uses Python 3.\n"}, {"id": "Python_Theory/01_Introduction/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/01_Introduction/02_Theory.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": "# Python: Theoretical Foundations\n\n## 1. The Interpreter Model\n\n### How Python Executes Code\n1. **Source Code** (`.py` file) \u2192 Written by programmer.\n2. **Bytecode** (`.pyc` file) \u2192 Compiled by Python to an intermediate representation.\n3. **Python Virtual Machine (PVM)** \u2192 Executes bytecode.\n\n```\nSource Code (.py) \u2192 Bytecode (.pyc) \u2192 PVM \u2192 Output\n```\n\n### Compilation vs Interpretation\n- **Compiled Languages** (C, C++): Source \u2192 Machine Code \u2192 Execution.\n  - Faster execution, platform-specific binaries.\n- **Interpreted Languages** (Python, JavaScript): Source \u2192 Interpreter \u2192 Execution.\n  - Slower execution, but portable and flexible.\n\nPython is technically **both**: It compiles to bytecode, then interprets it.\n\n## 2. Memory Management\n\n### Automatic Memory Management\n- **Garbage Collection**: Python automatically frees memory when objects are no longer referenced.\n- **Reference Counting**: Tracks how many references point to an object.\n\n### Everything is an Object\nIn Python, **everything** is an object:\n- Numbers: `5` is an object of class `int`.\n- Functions: Functions are objects that can be passed around.\n- Classes: Even classes themselves are objects (of type `type`).\n\n## 3. Name Binding (Variables as References)\n\nPython variables are **names** that refer to objects, not containers holding values.\n\n```python\na = [1, 2, 3]\nb = a  # b refers to the SAME list object as a\nb.append(4)\nprint(a)  # [1, 2, 3, 4] - a is also modified!\n```\n\n## 4. The Global Interpreter Lock (GIL)\n\n- **GIL**: A mutex that protects access to Python objects, preventing multiple threads from executing Python bytecode at once.\n- **Impact**: Limits true parallelism in CPU-bound multi-threaded programs.\n- **Workaround**: Use `multiprocessing` (separate processes) instead of `threading` for CPU-intensive tasks.\n\n## 5. Duck Typing\n\n> \"If it walks like a duck and quacks like a duck, it's a duck.\"\n\nPython doesn't check types explicitly. It checks if an object has the required methods/attributes.\n\n```python\ndef make_sound(animal):\n    animal.quack()  # Doesn't care what type 'animal' is\n\nclass Duck:\n    def quack(self): print(\"Quack!\")\n\nclass Person:\n    def quack(self): print(\"I'm imitating a duck!\")\n\nmake_sound(Duck())    # Works\nmake_sound(Person())  # Also works!\n```\n"}, {"id": "Python_Theory/01_Introduction/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/01_Introduction/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": "# Properties and Use Cases of Python\n\n## Key Properties\n\n### 1. Readability and Simplicity\nPython's syntax is clean and resembles natural English.\n\n**Compare:**\n```python\n# Python\nif x > 10:\n    print(\"Greater than 10\")\n```\n\n```java\n// Java\nif (x > 10) {\n    System.out.println(\"Greater than 10\");\n}\n```\n\n### 2. Extensive Standard Library\n\"Batteries included\" philosophy.\n- File I/O, networking, web services, data structures, math, and more.\n- Example: `import json` for JSON parsing, `import datetime` for date/time.\n\n### 3. Large Ecosystem (PyPI)\n- **PyPI** (Python Package Index): 400,000+ third-party packages.\n- Install with `pip`: `pip install numpy`\n\n### 4. Community and Support\n- Massive global community.\n- Extensive documentation, tutorials, Stack Overflow answers.\n\n### 5. Integration Capabilities\n- **C/C++ Integration**: Use `ctypes`, `cffi`, or write C extensions.\n- **Java Integration**: Jython (Python on JVM).\n- **Web APIs**: Easy HTTP requests with `requests` library.\n\n## Major Use Cases\n\n### 1. Web Development\n**Frameworks:**\n- **Django**: Full-stack framework (batteries included).\n- **Flask**: Lightweight, micro-framework.\n- **FastAPI**: Modern, fast, for building APIs.\n\n**Examples:** Instagram, Spotify, Pinterest use Django.\n\n### 2. Data Science and Machine Learning\n**Libraries:**\n- **NumPy**: Numerical computing.\n- **Pandas**: Data manipulation and analysis.\n- **Matplotlib/Seaborn**: Data visualization.\n- **Scikit-learn**: Machine learning.\n- **TensorFlow/PyTorch**: Deep learning.\n\n**Why Python?** Simple syntax allows data scientists to focus on algorithms, not syntax.\n\n### 3. Automation and Scripting\n- Automate repetitive tasks (file renaming, data extraction, web scraping).\n- **Libraries:** `os`, `shutil`, `selenium`, `BeautifulSoup`.\n\n### 4. Scientific Computing\n- Simulations, numerical analysis, research.\n- **SciPy**, **SymPy** (symbolic mathematics).\n\n### 5. Game Development\n- **Pygame**: 2D game development.\n- Prototyping game logic before porting to C++/Unity.\n\n### 6. Desktop GUI Applications\n- **Tkinter**: Built-in GUI library.\n- **PyQt/PySide**: Professional-grade GUIs.\n\n### 7. Cybersecurity and Penetration Testing\n- Network scanning, vulnerability assessment.\n- **Libraries:** `scapy`, `socket`.\n\n### 8. DevOps and System Administration\n- Configuration management, deployment automation.\n- **Tools:** Ansible (written in Python).\n\n## When NOT to Use Python\n\n### 1. Mobile App Development\n- Not the primary choice (use Swift/Kotlin/Flutter).\n- **Kivy** exists but limited.\n\n### 2. High-Performance Computing (Real-Time Systems)\n- GIL limits multi-threading.\n- Use C/C++/Rust for performance-critical applications.\n\n### 3. Low-Level System Programming\n- No direct memory manipulation.\n- Use C/C++ for operating systems, drivers.\n"}, {"id": "Python_Theory/01_Introduction/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/01_Introduction/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": "# Basic Syntax and Important Functions\n\n## General Syntax Rules\n\n1.  **Case Sensitivity**: Python is case-sensitive. `Variable` and `variable` are different identifiers.\n2.  **Line Structure**: Newlines indicate the end of a statement. No semicolons `;` act as terminators (though using them allows multiple statements on one line, it's non-Pythonic).\n3.  **Indentation**: Python uses **indentation** (whitespace) to define blocks of code (loop bodies, function bodies, conditionals).\n    - Standard convention: **4 spaces** per indentation level.\n    - Consistent indentation is mandatory; mixing tabs and spaces will cause errors.\n4.  **Comments**:\n    - Single-line: Starts with `#`.\n    - Multi-line (Docstrings): Enclosed in triple quotes `'''` or `\"\"\"`.\n\n## Important Built-in Functions (Introduction)\n\n| Function | Description | Example |\n| :--- | :--- | :--- |\n| `print()` | Outputs data to the standard output device (screen). | `print(\"Hello\")` |\n| `input()` | Reads a line from standard input (keyboard) as a string. | `name = input(\"Enter name: \")` |\n| `type()` | Returns the data type of an object. | `type(42)` -> `<class 'int'>` |\n| `help()` | Invokes the built-in help system. | `help(print)` |\n| `dir()` | Returns a list of attributes and methods of an object. | `dir(\"string\")` |\n| `id()` | Returns the unique identity (memory address) of an object. | `id(x)` |\n| `len()` | Returns the length of an object (string, list, etc.). | `len(\"hello\")` -> `5` |\n| `range()` | Generates a sequence of numbers. | `range(5)` -> `0, 1, 2, 3, 4` |\n| `int()`, `float()`, `str()` | Type conversion functions. | `int(\"10\")` -> `10` |\n\n## Syntax Example\n```python\n# This is a comment\ndef greet(name):\n    \"\"\"\n    This is a docstring.\n    It explains what the function does.\n    \"\"\"\n    message = \"Hello, \" + name  # Indented block\n    print(message)              # Indented block\n\ngreet(\"World\")  # Function call\n```\n\n## Statements vs Expressions\n\n### Statement\nA complete line of code that performs an action.\n```python\nx = 5          # Assignment statement\nprint(\"Hi\")    # Function call statement\nif x > 3:      # Conditional statement\n    pass\n```\n\n### Expression\nA combination of values and operators that evaluates to a value.\n```python\n5 + 3          # Evaluates to 8\nx > 10         # Evaluates to True or False\n\"Hello\" * 2    # Evaluates to \"HelloHello\"\n```\n\n## Identifiers (Naming Rules)\n\n### Valid Identifiers\n- Must start with a letter (a-z, A-Z) or underscore `_`.\n- Can contain letters, digits (0-9), and underscores.\n- **Cannot** start with a digit.\n- **Cannot** be a reserved keyword.\n\n### Reserved Keywords\n```python\nimport keyword\nprint(keyword.kwlist)\n# ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', \n#  'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', \n#  'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', \n#  'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', \n#  'try', 'while', 'with', 'yield']\n```\n\n## The `pass` Statement\nA null operation. Used as a placeholder.\n```python\ndef future_function():\n    pass  # TODO: Implement later\n\nif condition:\n    pass  # Do nothing for now\n```\n"}, {"id": "Python_Theory/01_Introduction/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/01_Introduction/05_Examples.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": "# Python Code Examples\n\n## Example 1: Hello World\nThe traditional first program.\n\n```python\nprint(\"Hello, World!\")\n```\n\n**Output:**\n```\nHello, World!\n```\n\n## Example 2: Variables and Types\n\n```python\n# Integer\nage = 25\n\n# Float\nprice = 19.99\n\n# String\nname = \"Alice\"\n\n# Boolean\nis_student = True\n\n# Display types\nprint(type(age))        # <class 'int'>\nprint(type(price))      # <class 'float'>\nprint(type(name))       # <class 'str'>\nprint(type(is_student)) # <class 'bool'>\n```\n\n## Example 3: User Input and Output\n\n```python\n# Get user input\nname = input(\"Enter your name: \")\nage = input(\"Enter your age: \")\n\n# Convert age to integer\nage = int(age)\n\n# Display personalized message\nprint(f\"Hello {name}, you are {age} years old.\")\n\n# Calculate birth year (assuming current year is 2025)\nbirth_year = 2025 - age\nprint(f\"You were born in approximately {birth_year}.\")\n```\n\n## Example 4: Simple Calculator\n\n```python\n# Get two numbers from user\nnum1 = float(input(\"Enter first number: \"))\nnum2 = float(input(\"Enter second number: \"))\n\n# Perform operations\naddition = num1 + num2\nsubtraction = num1 - num2\nmultiplication = num1 * num2\ndivision = num1 / num2\n\n# Display results\nprint(f\"{num1} + {num2} = {addition}\")\nprint(f\"{num1} - {num2} = {subtraction}\")\nprint(f\"{num1} * {num2} = {multiplication}\")\nprint(f\"{num1} / {num2} = {division}\")\n```\n\n## Example 5: Conditional Logic\n\n```python\n# Check if number is positive, negative, or zero\nnumber = float(input(\"Enter a number: \"))\n\nif number > 0:\n    print(\"The number is positive.\")\nelif number < 0:\n    print(\"The number is negative.\")\nelse:\n    print(\"The number is zero.\")\n```\n\n## Example 6: Simple Loop\n\n```python\n# Print numbers 1 to 10\nfor i in range(1, 11):\n    print(i, end=\" \")\nprint()  # New line\n\n# Print even numbers from 0 to 20\nfor i in range(0, 21, 2):\n    print(i, end=\" \")\n```\n\n**Output:**\n```\n1 2 3 4 5 6 7 8 9 10 \n0 2 4 6 8 10 12 14 16 18 20\n```\n\n## Example 7: List Operations\n\n```python\n# Create a list\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\n# Add an item\nfruits.append(\"orange\")\n\n# Access items\nprint(fruits[0])  # apple\nprint(fruits[-1]) # orange (last item)\n\n# Loop through list\nfor fruit in fruits:\n    print(f\"I like {fruit}\")\n\n# List length\nprint(f\"Total fruits: {len(fruits)}\")\n```\n\n## Example 8: Simple Function\n\n```python\ndef greet(name, greeting=\"Hello\"):\n    \"\"\"\n    Greets a person with a custom or default greeting.\n    \n    Args:\n        name (str): The person's name\n        greeting (str): The greeting message (default: \"Hello\")\n    \n    Returns:\n        str: The complete greeting message\n    \"\"\"\n    message = f\"{greeting}, {name}!\"\n    return message\n\n# Call the function\nprint(greet(\"Alice\"))                    # Hello, Alice!\nprint(greet(\"Bob\", \"Good morning\"))      # Good morning, Bob!\n```\n\n## Example 9: Dictionary Usage\n\n```python\n# Create a dictionary\nstudent = {\n    \"name\": \"John Doe\",\n    \"age\": 20,\n    \"major\": \"Computer Science\",\n    \"gpa\": 3.8\n}\n\n# Access values\nprint(f\"Name: {student['name']}\")\nprint(f\"GPA: {student['gpa']}\")\n\n# Add new key-value pair\nstudent[\"year\"] = \"Junior\"\n\n# Loop through dictionary\nfor key, value in student.items():\n    print(f\"{key}: {value}\")\n```\n\n## Example 10: File Operations\n\n```python\n# Write to a file\nwith open(\"sample.txt\", \"w\") as file:\n    file.write(\"Hello, this is a test file.\\n\")\n    file.write(\"Python makes file handling easy!\\n\")\n\n# Read from a file\nwith open(\"sample.txt\", \"r\") as file:\n    content = file.read()\n    print(content)\n\n# Read line by line\nwith open(\"sample.txt\", \"r\") as file:\n    for line in file:\n        print(line.strip())  # strip() removes newline characters\n```\n"}, {"id": "Python_Theory/01_Introduction/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/01_Introduction/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": "# Common Errors for Beginners\n\n## 1. SyntaxError\n\n### Missing Colon\n```python\n# WRONG\nif x > 5\n    print(\"Greater\")\n\n# CORRECT\nif x > 5:\n    print(\"Greater\")\n```\n\n### Incorrect Indentation\n```python\n# WRONG\ndef greet():\nprint(\"Hello\")  # IndentationError\n\n# CORRECT\ndef greet():\n    print(\"Hello\")\n```\n\n### Mixing Tabs and Spaces\n```python\n# WRONG (invisible error - mixing tabs and spaces)\ndef example():\n    x = 5      # 4 spaces\n\ty = 10     # 1 tab\n    \n# CORRECT - Use only spaces (4 spaces is standard)\ndef example():\n    x = 5\n    y = 10\n```\n\n## 2. NameError\n\n### Using Undefined Variable\n```python\n# WRONG\nprint(message)  # NameError: name 'message' is not defined\n\n# CORRECT\nmessage = \"Hello\"\nprint(message)\n```\n\n### Typo in Variable Name\n```python\n# WRONG\nuser_name = \"Alice\"\nprint(username)  # NameError (missing underscore)\n\n# CORRECT\nuser_name = \"Alice\"\nprint(user_name)\n```\n\n## 3. TypeError\n\n### Concatenating Different Types\n```python\n# WRONG\nage = 25\nprint(\"I am \" + age + \" years old\")  # TypeError\n\n# CORRECT\nage = 25\nprint(\"I am \" + str(age) + \" years old\")\n# OR use f-string\nprint(f\"I am {age} years old\")\n```\n\n### Calling Non-Callable Object\n```python\n# WRONG\nx = 5\nresult = x()  # TypeError: 'int' object is not callable\n\n# CORRECT\ndef x():\n    return 5\nresult = x()\n```\n\n## 4. IndexError\n\n### Accessing Out-of-Range Index\n```python\n# WRONG\nfruits = [\"apple\", \"banana\"]\nprint(fruits[2])  # IndexError: list index out of range\n\n# CORRECT\nfruits = [\"apple\", \"banana\"]\nif len(fruits) > 2:\n    print(fruits[2])\nelse:\n    print(\"Index out of range\")\n```\n\n## 5. KeyError\n\n### Accessing Non-Existent Dictionary Key\n```python\n# WRONG\nstudent = {\"name\": \"John\", \"age\": 20}\nprint(student[\"grade\"])  # KeyError: 'grade'\n\n# CORRECT - Use .get() method\nstudent = {\"name\": \"John\", \"age\": 20}\nprint(student.get(\"grade\", \"Not found\"))  # Returns \"Not found\"\n```\n\n## 6. ValueError\n\n### Invalid Type Conversion\n```python\n# WRONG\nage = int(\"twenty\")  # ValueError: invalid literal for int()\n\n# CORRECT - Validate input\nage_str = input(\"Enter age: \")\nif age_str.isdigit():\n    age = int(age_str)\nelse:\n    print(\"Please enter a valid number\")\n```\n\n## 7. AttributeError\n\n### Calling Non-Existent Method\n```python\n# WRONG\nx = 5\nx.append(10)  # AttributeError: 'int' object has no attribute 'append'\n\n# CORRECT\nx = [5]  # Use a list instead\nx.append(10)\n```\n\n## 8. IndentationError\n\n### Unexpected Indent\n```python\n# WRONG\nx = 5\n    y = 10  # IndentationError: unexpected indent\n\n# CORRECT\nx = 5\ny = 10\n```\n\n### Unindent Does Not Match\n```python\n# WRONG\ndef example():\n    if True:\n        print(\"Hello\")\n      print(\"World\")  # IndentationError\n\n# CORRECT\ndef example():\n    if True:\n        print(\"Hello\")\n    print(\"World\")\n```\n\n## 9. ZeroDivisionError\n\n### Division by Zero\n```python\n# WRONG\nresult = 10 / 0  # ZeroDivisionError\n\n# CORRECT - Check before dividing\ndivisor = 0\nif divisor != 0:\n    result = 10 / divisor\nelse:\n    print(\"Cannot divide by zero\")\n```\n\n## 10. ImportError / ModuleNotFoundError\n\n### Importing Non-Existent Module\n```python\n# WRONG\nimport nonexistent_module  # ModuleNotFoundError\n\n# CORRECT - Install the module first\n# pip install module_name\nimport numpy  # After installing: pip install numpy\n```\n\n## Tips to Avoid Errors\n\n1. **Read Error Messages Carefully**: Python error messages tell you exactly what went wrong and where.\n2. **Use an IDE**: IDEs like PyCharm, VS Code highlight syntax errors before you run the code.\n3. **Print Debugging**: Use `print()` statements to check variable values.\n4. **Use Try-Except**: Handle potential errors gracefully.\n   ```python\n   try:\n       age = int(input(\"Enter age: \"))\n   except ValueError:\n       print(\"Invalid input. Please enter a number.\")\n   ```\n5. **Follow PEP 8**: Python's style guide helps maintain consistent, readable code.\n"}, {"id": "Python_Theory/01_Introduction/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/01_Introduction/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": "# Practice Questions - Introduction to Python\n\n## Beginner Level\n\n### Q1: First Program\nWrite a Python program that prints your name, age, and favorite hobby on separate lines.\n\n### Q2: Simple Math\nCreate a program that calculates and prints the area of a rectangle with length 10 and width 5.\nFormula: `Area = length \u00d7 width`\n\n### Q3: Temperature Converter\nWrite a program that converts 100\u00b0F to Celsius.\nFormula: `C = (F - 32) \u00d7 5/9`\n\n### Q4: String Manipulation\nCreate a variable with your full name. Print:\n- The length of your name\n- Your name in uppercase\n- Your name in lowercase\n\n### Q5: Type Checking\nCreate variables of different types (int, float, str, bool) and print their types using the `type()` function.\n\n---\n\n## Intermediate Level\n\n### Q6: User Input Calculator\nWrite a program that:\n1. Asks the user for two numbers\n2. Asks for an operation (+, -, *, /)\n3. Performs the operation and displays the result\n\n### Q7: List Operations\nCreate a list of 5 favorite movies. Write code to:\n- Print the first movie\n- Print the last movie\n- Add a new movie to the list\n- Print the total number of movies\n\n### Q8: Even or Odd\nWrite a program that asks the user for a number and tells them whether it's even or odd.\n\n### Q9: Grade Calculator\nWrite a program that takes a numerical score (0-100) and prints the letter grade:\n- A: 90-100\n- B: 80-89\n- C: 70-79\n- D: 60-69\n- F: Below 60\n\n### Q10: Sum of Numbers\nWrite a program that calculates the sum of all numbers from 1 to 100.\n\n---\n\n## Solutions\n\n### A1: First Program\n```python\nprint(\"Name: Alice Johnson\")\nprint(\"Age: 25\")\nprint(\"Hobby: Photography\")\n```\n\n### A2: Simple Math\n```python\nlength = 10\nwidth = 5\narea = length * width\nprint(f\"Area of rectangle: {area}\")\n```\n\n### A3: Temperature Converter\n```python\nfahrenheit = 100\ncelsius = (fahrenheit - 32) * 5/9\nprint(f\"{fahrenheit}\u00b0F = {celsius:.2f}\u00b0C\")\n```\n\n### A4: String Manipulation\n```python\nname = \"John Doe\"\nprint(f\"Length: {len(name)}\")\nprint(f\"Uppercase: {name.upper()}\")\nprint(f\"Lowercase: {name.lower()}\")\n```\n\n### A5: Type Checking\n```python\nnum_int = 42\nnum_float = 3.14\ntext = \"Hello\"\nflag = True\n\nprint(type(num_int))    # <class 'int'>\nprint(type(num_float))  # <class 'float'>\nprint(type(text))       # <class 'str'>\nprint(type(flag))       # <class 'bool'>\n```\n\n### A6: User Input Calculator\n```python\nnum1 = float(input(\"Enter first number: \"))\nnum2 = float(input(\"Enter second number: \"))\noperation = input(\"Enter operation (+, -, *, /): \")\n\nif operation == \"+\":\n    result = num1 + num2\nelif operation == \"-\":\n    result = num1 - num2\nelif operation == \"*\":\n    result = num1 * num2\nelif operation == \"/\":\n    if num2 != 0:\n        result = num1 / num2\n    else:\n        result = \"Error: Division by zero\"\nelse:\n    result = \"Invalid operation\"\n\nprint(f\"Result: {result}\")\n```\n\n### A7: List Operations\n```python\nmovies = [\"Inception\", \"The Matrix\", \"Interstellar\", \"The Prestige\", \"Memento\"]\n\nprint(f\"First movie: {movies[0]}\")\nprint(f\"Last movie: {movies[-1]}\")\n\nmovies.append(\"Tenet\")\nprint(f\"Total movies: {len(movies)}\")\nprint(f\"Updated list: {movies}\")\n```\n\n### A8: Even or Odd\n```python\nnumber = int(input(\"Enter a number: \"))\n\nif number % 2 == 0:\n    print(f\"{number} is even\")\nelse:\n    print(f\"{number} is odd\")\n```\n\n### A9: Grade Calculator\n```python\nscore = int(input(\"Enter score (0-100): \"))\n\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelif score >= 70:\n    grade = \"C\"\nelif score >= 60:\n    grade = \"D\"\nelse:\n    grade = \"F\"\n\nprint(f\"Grade: {grade}\")\n```\n\n### A10: Sum of Numbers\n```python\n# Method 1: Using a loop\ntotal = 0\nfor i in range(1, 101):\n    total += i\nprint(f\"Sum: {total}\")\n\n# Method 2: Using formula (more efficient)\nn = 100\nsum_formula = n * (n + 1) // 2\nprint(f\"Sum: {sum_formula}\")\n\n# Method 3: Using built-in sum()\nsum_builtin = sum(range(1, 101))\nprint(f\"Sum: {sum_builtin}\")\n```\n\n---\n\n## Challenge Questions\n\n### C1: Palindrome Checker\nWrite a program that checks if a word is a palindrome (reads the same forwards and backwards).\nExample: \"racecar\" is a palindrome.\n\n### C2: Fibonacci Sequence\nWrite a program that prints the first 10 numbers in the Fibonacci sequence.\n(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)\n\n### C3: Prime Number Checker\nWrite a program that checks if a number is prime.\n\n---\n\n## Challenge Solutions\n\n### C1: Palindrome Checker\n```python\nword = input(\"Enter a word: \").lower()\nif word == word[::-1]:\n    print(f\"{word} is a palindrome\")\nelse:\n    print(f\"{word} is not a palindrome\")\n```\n\n### C2: Fibonacci Sequence\n```python\nn = 10\na, b = 0, 1\nprint(\"Fibonacci sequence:\")\nfor _ in range(n):\n    print(a, end=\" \")\n    a, b = b, a + b\n```\n\n### C3: Prime Number Checker\n```python\nnum = int(input(\"Enter a number: \"))\n\nif num < 2:\n    print(f\"{num} is not prime\")\nelse:\n    is_prime = True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            is_prime = False\n            break\n    \n    if is_prime:\n        print(f\"{num} is prime\")\n    else:\n        print(f\"{num} is not prime\")\n```\n"}, {"id": "Python_Theory/02_Basic_Syntax/01_Indentation_and_Comments.md", "title": "01 Indentation and Comments", "type": "Topic", "path": "Python_Theory/02_Basic_Syntax/01_Indentation_and_Comments.md", "breadcrumbs": ["Python Theory", "02 Basic Syntax"], "content": "# Indentation and Comments\n\n## Definition\n**Indentation** refers to the spaces at the beginning of a code line. In Python, it is not just for readability but is a **syntactic requirement** to define blocks of code.\n**Comments** are text ignored by the interpreter, used to explain code or leave notes.\n\n## Theory\n- **Indentation**: Most languages (C++, Java) use braces `{}` to define scope. Python uses whitespace. This enforces readability (\"readability counts\").\n- **Comments**: Critical for collaboration. Python supports single-line comments and docstrings (documentation strings) for modules, classes, and functions.\n\n## Syntax and Rules\n\n### Indentation\n- **Standard**: 4 spaces per level (PEP 8 recommendation).\n- **Rule**: All statements in the same block must have the same indentation level.\n- **Tabs vs Spaces**: Do not mix them. Using spaces is the preferred method.\n\n### Comments\n- **Single-line**: Starts with `#`.\n- **Multi-line (Docstrings)**: Enclosed in `\"\"\"` or `'''`. While technically string literals, when placed at the start of a function/module, they act as documentation.\n\n## Examples\n\n```python\n# This is a single-line comment\n\ndef example_function():\n    \"\"\"\n    This is a docstring.\n    It explains the function.\n    \"\"\"\n    if True:\n        # This block is indented\n        print(\"Indentation matters!\")\n    # End of if block\n# End of function\n```\n\n## Common Errors\n1.  **IndentationError: unexpected indent**: Adding spaces where they aren't needed.\n2.  **IndentationError: unindent does not match any outer indentation level**: Messy structure.\n3.  **TabError**: Mixing tabs and spaces.\n"}, {"id": "Python_Theory/02_Basic_Syntax/02_Variables_and_Constants.md", "title": "02 Variables and Constants", "type": "Topic", "path": "Python_Theory/02_Basic_Syntax/02_Variables_and_Constants.md", "breadcrumbs": ["Python Theory", "02 Basic Syntax"], "content": "# Variables and Constants\n\n## Definition\n- **Variable**: A reserved memory location to store values. In Python, a variable is a *name* that refers to an object in memory.\n- **Constant**: A type of variable whose value should not be changed. Python does not enforce constants syntactically, but by convention, uppercase names are used.\n\n## Theory\n- **Dynamic Typing**: You don't declare types (e.g., `int x`). Python infers types at runtime.\n- **References**: Variables are references (pointers) to objects. If `a = [1]` and `b = a`, both point to the same list.\n- **Naming Conventions**:\n    - Variables: `snake_case` (e.g., `user_name`)\n    - Constants: `UPPER_CASE` (e.g., `MAX_SPEED`)\n    - Classes: `PascalCase` (e.g., `MyClass`)\n\n## Syntax\n\n```python\nvariable_name = value\nCONSTANT_NAME = value\n```\n\n- **Multiple Assignment**: `x, y, z = 1, 2, 3`\n- **Chain Assignment**: `x = y = z = 0`\n\n## Examples\n\n```python\n# Variable assignment\nage = 25\nname = \"John\"\n\n# Constant (Convention only)\nPI = 3.14159\n\n# Changing a variable (Dynamic typing)\nx = 100       # x is an int\nx = \"Hello\"   # x is now a str (Perfectly valid in Python)\n\nprint(name)\nprint(x)\n```\n\n## Common Errors\n1.  **NameError**: Using a variable before assignment.\n2.  **SyntaxError**: Variable names cannot start with a number (`1st_var` is invalid) or contain spaces.\n"}, {"id": "Python_Theory/02_Basic_Syntax/03_Input_Output.md", "title": "03 Input Output", "type": "Topic", "path": "Python_Theory/02_Basic_Syntax/03_Input_Output.md", "breadcrumbs": ["Python Theory", "02 Basic Syntax"], "content": "# Input and Output\n\n## Output: `print()`\nThe `print()` function sends data to the standard output.\n\n### key Arguments\n- `sep`: Separator between items (default is space `' '`).\n- `end`: What to print at the end (default is newline `'\\n'`).\n\n### Examples\n```python\nprint(\"Hello\", \"World\")             # Output: Hello World\nprint(\"Hello\", \"World\", sep=\"-\")    # Output: Hello-World\nprint(\"Line 1\", end=\" \")\nprint(\"Line 2\")                     # Output: Line 1 Line 2\n```\n\n## Input: `input()`\nThe `input()` function pauses execution and waits for the user to type text and press Enter.\n**Important**: It *always* returns a **string**.\n\n### Syntax\n```python\nvariable = input(\"Prompt message: \")\n```\n\n### Type Casting\nIf you need a number, you must cast the string.\n```python\nage = input(\"Enter age: \")  # \"25\"\nage_int = int(age)          # 25\n```\n\n## String Formatting (Output Formatting)\nThe modern way to format strings is using **f-strings** (formatted string literals), introduced in Python 3.6.\n\n```python\nname = \"Alice\"\nscore = 95\nprint(f\"Player {name} scored {score} points.\")\n```\n\nOther methods (older):\n- `.format()`: `\"Player {} scored {}\".format(name, score)`\n- `%` operator: `\"Player %s scored %d\" % (name, score)`\n"}, {"id": "Python_Theory/02_Basic_Syntax/04_Practice_Questions.md", "title": "04 Practice Questions", "type": "Topic", "path": "Python_Theory/02_Basic_Syntax/04_Practice_Questions.md", "breadcrumbs": ["Python Theory", "02 Basic Syntax"], "content": "# Practice Questions - Basic Syntax\n\n## Questions\n\n### Q1: Variable Swapping\nCreate two variables `a = 50` and `b = 100`. Swap their values without using a third variable (hint: Python allows multiple assignment).\n\n### Q2: Formatted Output\nAsk the user for their name and birth year. Print a message:\n`Hello [Name], you are approx [age] years old.`\n(Assume current year is 2025).\n\n### Q3: Fix the Code\n```python\nprice = 19.99\nprint(\"The price is \" + price)\n```\n\n## Solutions\n\n**A1:**\n```python\na, b = 50, 100\na, b = b, a\nprint(a, b)  # 100 50\n```\n\n**A2:**\n```python\ncurrent_year = 2025\nname = input(\"Enter name: \")\nyear_str = input(\"Enter birth year: \")\nage = current_year - int(year_str)  # Convert input to int\nprint(f\"Hello {name}, you are approx {age} years old.\")\n```\n\n**A3:**\nError: `TypeError`, cannot concatenate float to string.\nFix:\n```python\nprint(f\"The price is {price}\")\n# OR\nprint(\"The price is \" + str(price))\n```\n"}, {"id": "Python_Theory/03_Data_Types/01_Overview.md", "title": "01 Overview", "type": "Topic", "path": "Python_Theory/03_Data_Types/01_Overview.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Data Types Overview\n\n## Definition\nVariables can store data of different types, and different types can do different things.\nPython has the following standard built-in data types:\n\n## Taxonomy of Data Types\nIt is crucial to understand which types are **Mutable** (changeable) and **Immutable** (unchangeable).\n\n### 1. Immutable Types\nOnce created, their value cannot be changed. If you \"modify\" them, Python actually creates a new object.\n- **Numeric**: `int`, `float`, `complex`\n- **Text**: `str`\n- **Boolean**: `bool`\n- **Sequence**: `tuple` (contains immutable or mutable items, but the tuple structure itself is immutable)\n- **Special**: `NoneType`\n\n### 2. Mutable Types\nYou can change the content without changing the identity (memory address) of the object.\n- **Sequence**: `list`\n- **Mapping**: `dict`\n- **Set Types**: `set`\n- **Binary**: `bytearray`\n\n## Getting the Type\nUse the `type()` function to check the type of any object.\n\n```python\nx = 5\nprint(type(x))  # <class 'int'>\n\ny = \"Hello\"\nprint(type(y))  # <class 'str'>\n```\n\n## Summary Table\n\n| Category | Type Name | Example | Mutable? |\n| :--- | :--- | :--- | :--- |\n| Text | `str` | `\"Hello\"` | No |\n| Numeric | `int` | `20` | No |\n| Numeric | `float` | `20.5` | No |\n| Numeric | `complex` | `1j` | No |\n| Sequence | `list` | `[\"apple\", \"banana\"]` | **Yes** |\n| Sequence | `tuple` | `(\"apple\", \"banana\")` | No |\n| Sequence | `range` | `range(6)` | No |\n| Mapping | `dict` | `{\"name\": \"John\", \"age\": 36}` | **Yes** |\n| Set | `set` | `{\"apple\", \"banana\"}` | **Yes** |\n| Set | `frozenset` | `frozenset({\"apple\", \"banana\"})` | No |\n| Boolean | `bool` | `True` | No |\n| Binary | `bytes` | `b\"Hello\"` | No |\n| None | `NoneType` | `None` | No |\n"}, {"id": "Python_Theory/03_Data_Types/02_Numbers.md", "title": "02 Numbers", "type": "Topic", "path": "Python_Theory/03_Data_Types/02_Numbers.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Numbers\n\n## Definition\nPython supports three distinct numeric types:\n1.  **Integers** (`int`)\n2.  **Floating point numbers** (`float`)\n3.  **Complex numbers** (`complex`)\n\n## 1. Integers (`int`)\n- Whole numbers, positive or negative, without decimals, of unlimited length.\n- Python 3 handles large integers automatically (no \"long\" type like in Python 2 or C).\n\n```python\nx = 1\ny = 35656222554887711\nz = -3255522\n\nprint(type(x))  # <class 'int'>\n```\n\n## 2. Floating Point Numbers (`float`)\n- Numbers containing one or more decimals.\n- Can also be scientific numbers with an \"e\" to indicate the power of 10.\n\n```python\nx = 1.10\ny = 1.0\nz = -35.59\nw = 35e3        # 35 * 10^3 = 35000.0\n# Note: w is a float\n```\n\n## 3. Complex Numbers (`complex`)\n- Written with a \"j\" as the imaginary part.\n- Useful in engineering and complex mathematics.\n\n```python\nx = 3+5j\ny = 5j\nz = -5j\n\nprint(type(x))  # <class 'complex'>\nprint(x.real)   # 3.0\nprint(x.imag)   # 5.0\n```\n\n## Useful Math Functions\n\n### Built-in\n- `abs(x)`: Absolute value.\n- `round(x, n)`: Round number to `n` digits.\n- `pow(x, y)`: x to the power of y (same as `x ** y`).\n\n### The `math` Module\nFor more advanced operations, import `math`.\n\n```python\nimport math\n\nprint(math.ceil(1.4))   # 2\nprint(math.floor(1.4))  # 1\nprint(math.sqrt(64))    # 8.0\nprint(math.pi)          # 3.14159...\n```\n\n## Common Errors\n- **Float Precision**: Floats are approximations. `0.1 + 0.2` might equal `0.30000000000000004` instead of `0.3` due to binary floating-point representation.\n- **Division**: In Python 3, `/` always returns a float (`a / b`). Use `//` for integer (floor) division.\n"}, {"id": "Python_Theory/03_Data_Types/03_Booleans.md", "title": "03 Booleans", "type": "Topic", "path": "Python_Theory/03_Data_Types/03_Booleans.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Booleans\n\n## Definition\nBooleans represent one of two values: `True` or `False`. They are a subclass of integers (where True is 1 and False is 0).\n\n## Theory\n- Used primarily in **conditional statements** (if/else) and **loops**.\n- Comparison operations return booleans.\n\n```python\nprint(10 > 9)   # True\nprint(10 == 9)  # False\nprint(10 < 9)   # False\n```\n\n## Truthiness (True or False?)\nIn Python, almost any value is evaluated to `True` if it has some sort of content.\n\n### What is True?\n- Any non-zero number.\n- Any non-empty string.\n- Any non-empty list, tuple, set, or dictionary.\n\n### What is False?\n- `False` itself.\n- `None`.\n- Zero of any numeric type: `0`, `0.0`, `0j`.\n- Empty sequences and collections: `''`, `()`, `[]`, `{}`.\n\n## Bool Function\nTo check if a value acts as True or False, use the `bool()` function.\n\n```python\nprint(bool(\"Hello\"))  # True\nprint(bool(15))       # True\n\nprint(bool(\"\"))       # False\nprint(bool(0))        # False\nprint(bool([]))       # False\n```\n\n## Boolean Logic Operators\n`and`, `or`, `not`\n\n```python\nx = True\ny = False\n\nprint(x and y)  # False\nprint(x or y)   # True\nprint(not x)    # False\n```\n"}, {"id": "Python_Theory/03_Data_Types/04_Type_Conversion.md", "title": "04 Type Conversion", "type": "Topic", "path": "Python_Theory/03_Data_Types/04_Type_Conversion.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Type Conversion (Casting)\n\n## Definition\nType conversion is the process of converting the value of one data type (integer, string, float, etc.) to another data type.\n\n## 1. Implicit Conversion\nPython automatically converts one data type to another without any user involvement. This usually happens when mixing types to prevent data loss.\n\n```python\nx_int = 10\ny_float = 10.5\n\nresult = x_int + y_float\n\nprint(result)        # 20.5\nprint(type(result))  # <class 'float'>\n# Python promoted the int to float to perform the addition.\n```\n\n## 2. Explicit Conversion (Casting)\nThe user manually changes the data type using built-in functions like `int()`, `float()`, `str()`, etc.\n\n### Common Functions\n\n- `int(x)`: Converts x to an integer.\n    - `int(3.9)` -> `3` (truncates, does not round)\n    - `int(\"10\")` -> `10`\n    - `int(\"10.5\")` -> Error! (String must look like an int)\n\n- `float(x)`: Converts x to a float.\n    - `float(5)` -> `5.0`\n    - `float(\"3.14\")` -> `3.14`\n\n- `str(x)`: Converts x to a string representation.\n    - `str(100)` -> `\"100\"`\n    - `str([1, 2])` -> `\"[1, 2]\"`\n\n### Examples\n\n```python\n# Convert float to int\nnum_sum = int(123.654)\nprint(num_sum)  # 123 (truncation)\n\n# Convert number to string for concatenation\nage = 25\nmessage = \"I am \" + str(age) + \" years old\"\nprint(message)\n```\n\n## Common Errors\n- **ValueError**: Trying to cast an incompatible string to a number.\n  ```python\n  x = int(\"Hello\")  # ValueError: invalid literal for int()\n  y = int(\"12.5\")   # ValueError: invalid literal for int() (must convert to float first, then int)\n  ```\n"}, {"id": "Python_Theory/03_Data_Types/05_NoneType.md", "title": "05 NoneType", "type": "Topic", "path": "Python_Theory/03_Data_Types/05_NoneType.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# NoneType\n\n## Definition\n`None` is a special keyword in Python that represents the **absence of a value** or a **null** value. It is an object of its own datatype, the `NoneType`.\n\n## Theory\n- `None` is not the same as `0` (zero), `False`, or an empty string `\"\"`.\n- `None` is the only value of the `NoneType`.\n- Functions that do not explicitly return a value return `None` by default.\n\n## Syntax and Usage\n\n```python\nx = None\n\nif x is None:\n    print(\"x has no value\")\n\nif x is not None:\n    print(\"x has a value\")\n```\n\n### Important Rule: Use `is` for None\nAlways use `is` or `is not` to check for `None`, rather than `==` or `!=`.\n- `x is None` (Correct/Pythonic)\n- `x == None` (Works, but discouraged)\n\n## Example: Default return value\n\n```python\ndef my_func():\n    print(\"Doing something\")\n    # No return statement here\n\nresult = my_func()\nprint(result)  # Output: None\n```\n\n## Common Errors\n- **AttributeError**: Trying to access methods on a `None` value (often forgetting that a function returned `None`).\n    ```python\n    x = None\n    # print(x.upper())  # AttributeError: 'NoneType' object has no attribute 'upper'\n    ```\n"}, {"id": "Python_Theory/03_Data_Types/06_Practice_Questions.md", "title": "06 Practice Questions", "type": "Topic", "path": "Python_Theory/03_Data_Types/06_Practice_Questions.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Practice Questions - Data Types\n\n## Questions\n\n### Q1: Type Identification\nWhat is the data type of the following values?\n1. `x = 5`\n2. `x = 5.0`\n3. `x = 5 > 4`\n4. `x = \"5\"`\n5. `x = int(\"5\")`\n\n### Q2: Immutability\nWhat happens if you run the following code? Why?\n```python\nx = (1, 2)\nx[0] = 5\n```\n\n### Q3: Casting Challenge\nConvert the float number `8.99` to an integer. What is the result: `8` or `9`?\n\n### Q4: Boolean Logic\nEvaluate:\n`True and False or not False`\n\n---\n\n## Solutions\n\n**A1:**\n1. `int`\n2. `float`\n3. `bool` (`True`)\n4. `str`\n5. `int`\n\n**A2:**\n**TypeError**. Tuples are immutable; you cannot change elements after creation.\n\n**A3:**\nResult is `8`. Casting `int(8.99)` truncates the decimal part; it does not round.\n\n**A4:**\nOrder of operations: `not` -> `and` -> `or`.\n1. `not False` -> `True`\n2. `True and False` -> `False`\n3. `False or True` -> `True`\nFinal Answer: `True`\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/01_Arithmetic.md", "title": "01 Arithmetic", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/01_Arithmetic.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Arithmetic Operators\n\n## Definition\nArithmetic operators are used with numeric values to perform common mathematical operations.\n\n## List of Operators\n\n| Operator | Name | Description | Example |\n| :--- | :--- | :--- | :--- |\n| `+` | Addition | Adds two values. | `x + y` |\n| `-` | Subtraction | Subtracts right operand from left. | `x - y` |\n| `*` | Multiplication | Multiplies two values. | `x * y` |\n| `/` | Division | Divides left by right (always returns float). | `x / y` |\n| `%` | Modulus | Returns the remainder of division. | `x % y` |\n| `**` | Exponentiation | Raises left operand to power of right. | `x ** y` |\n| `//` | Floor Division | Divides and rounds down to nearest integer. | `x // y` |\n\n## Code Examples\n\n```python\na = 10\nb = 3\n\nprint(a + b)   # 13\nprint(a - b)   # 7\nprint(a * b)   # 30\nprint(a / b)   # 3.3333333333333335 (Float division)\nprint(a // b)  # 3 (Floor division - truncates decimal)\nprint(a % b)   # 1 (Remainder: 10 = 3*3 + 1)\nprint(a ** b)  # 1000 (10^3)\n```\n\n## Common Uses\n- **Modulus (`%`)**: Checking if a number is even or odd (`x % 2 == 0`).\n- **Floor Division (`//`)**: Determining how many full items fit in a container.\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/02_Comparison_Logical.md", "title": "02 Comparison Logical", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/02_Comparison_Logical.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Comparison and Logical Operators\n\n## 1. Comparison Operators\nComparison operators are used to compare two values. They **always** return a Boolean value (`True` or `False`).\n\n| Operator | Name | Example |\n| :--- | :--- | :--- |\n| `==` | Equal | `x == y` |\n| `!=` | Not Equal | `x != y` |\n| `>` | Greater than | `x > y` |\n| `<` | Less than | `x < y` |\n| `>=` | Greater than or equal to | `x >= y` |\n| `<=` | Less than or equal to | `x <= y` |\n\n### Chained Comparison\nPython supports chained comparisons, which is a unique feature.\n```python\nx = 5\nprint(1 < x < 10)  # True (Equivalent to: 1 < x and x < 10)\n```\n\n## 2. Logical Operators\nLogical operators are used to combine conditional statements.\n\n| Operator | Description | Example |\n| :--- | :--- | :--- |\n| `and` | Returns True if both statements are true | `x < 5 and  x < 10` |\n| `or` | Returns True if one of the statements is true | `x < 5 or x < 4` |\n| `not` | Reverse the result, returns False if the result is true | `not(x < 5 and x < 10)` |\n\n### Short-Circuit Evaluation\n- `and`: If the first operand is False, Python doesn't check the second operand; returns False immediately.\n- `or`: If the first operand is True, Python doesn't check the second operand; returns True immediately.\n\n```python\nx = 10\n# 'x > 20' is False, so execution stops there. \n# Safe because 10/0 would raise ZeroDivisionError if evaluated.\nif x > 20 and (10 / 0) == 1:\n    print(\"This won't print\")\nelse:\n    print(\"Safe\")\n```\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/03_Assignment_Bitwise.md", "title": "03 Assignment Bitwise", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/03_Assignment_Bitwise.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Assignment and Bitwise Operators\n\n## 1. Assignment Operators\nUsed to assign values to variables.\n\n| Operator | Description | Example | Same As |\n| :--- | :--- | :--- | :--- |\n| `=` | Assigns value | `x = 5` | |\n| `+=` | Add AND | `x += 3` | `x = x + 3` |\n| `-=` | Subtract AND | `x -= 3` | `x = x - 3` |\n| `*=` | Multiply AND | `x *= 3` | `x = x * 3` |\n| `/=` | Divide AND | `x /= 3` | `x = x / 3` |\n| `//=` | Floor Div AND | `x //= 3` | `x = x // 3` |\n| `%=` | Modulus AND | `x %= 3` | `x = x % 3` |\n| `**=` | Exponent AND | `x **= 3` | `x = x ** 3` |\n\n## 2. Bitwise Operators\nBitwise operators act on operands as if they were strings of binary digits. They operate bit by bit.\n\n| Operator | Name | Description | Example |\n| :--- | :--- | :--- | :--- |\n| `&` | AND | Sets each bit to 1 if both bits are 1 | `x & y` |\n| `|` | OR | Sets each bit to 1 if one of two bits is 1 | `x | y` |\n| `^` | XOR | Sets each bit to 1 if only one of two bits is 1 | `x ^ y` |\n| `~` | NOT | Inverts all the bits | `~x` |\n| `<<` | Zero fill left shift | Shift left by pushing zeros in from the right | `x << 2` |\n| `>>` | Signed right shift | Shift right by pushing copies of the leftmost bit in from the left | `x >> 2` |\n\n### Example\n```python\nval = 10        # Binary: 1010\nmask = 4        # Binary: 0100\n\nprint(val & mask)  # 0000 -> 0\nprint(val | mask)  # 1110 -> 14\nprint(val >> 1)    # 0101 -> 5\n```\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/04_Membership_Identity.md", "title": "04 Membership Identity", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/04_Membership_Identity.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Membership and Identity Operators\n\n## 1. Membership Operators\nMembership operators are used to test if a sequence is presented in an object.\n\n| Operator | Description | Example |\n| :--- | :--- | :--- |\n| `in` | Returns True if a sequence with the specified value is present in the object | `x in y` |\n| `not in` | Returns True if a sequence with the specified value is NOT present in the object | `x not in y` |\n\n### Examples\n```python\nfruits = [\"apple\", \"banana\"]\n\nprint(\"banana\" in fruits)  # True\nprint(\"pineapple\" not in fruits)  # True\nprint(\"a\" in \"apple\")  # True (Works with strings too)\n```\n\n## 2. Identity Operators\nIdentity operators compare the objects, not if they are equal, but if they are actually the **same object**, with the same memory location.\n\n| Operator | Description | Example |\n| :--- | :--- | :--- |\n| `is` | Returns True if both variables are the same object | `x is y` |\n| `is not` | Returns True if both variables are not the same object | `x is not y` |\n\n### `is` vs `==`\n- `==` compares **value**.\n- `is` compares **identity** (memory address).\n\n```python\nx = [\"apple\", \"banana\"]\ny = [\"apple\", \"banana\"]\nz = x\n\nprint(x is z)  # True (z points to the same object as x)\nprint(x is y)  # False (x and y are two different objects in memory)\nprint(x == y)  # True (x and y have the same content)\n```\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/05_Operator_Precedence.md", "title": "05 Operator Precedence", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/05_Operator_Precedence.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Operator Precedence\n\n## Definition\nOperator precedence describes the order in which operations are performed when there are multiple operators in an expression.\n\n## Precedence Table (Highest to Lowest)\n\n| Level | Operator | Description |\n| :--- | :--- | :--- |\n| 1 | `()` | Parentheses |\n| 2 | `**` | Exponentiation |\n| 3 | `+x`, `-x`, `~x` | Unary plus, Unary minus, Bitwise NOT |\n| 4 | `*`, `/`, `//`, `%` | Multiplication, Division, Floor division, Modulus |\n| 5 | `+`, `-` | Addition, Subtraction |\n| 6 | `<<`, `>>` | Bitwise shift |\n| 7 | `&` | Bitwise AND |\n| 8 | `^` | Bitwise XOR |\n| 9 | `\\|` | Bitwise OR |\n| 10 | `==`, `!=`, `>`, `>=`, `<`, `<=`, `is`, `is not`, `in`, `not in` | Comparisons, Identity, Membership operators |\n| 11 | `not` | Logical NOT |\n| 12 | `and` | Logical AND |\n| 13 | `or` | Logical OR |\n\n## Examples\n\n```python\nresult = 10 + 2 * 3\n# Multiplication (*) is higher than Addition (+)\n# 10 + 6\n# 16\nprint(result)\n\nresult = (10 + 2) * 3\n# Parentheses have the highest precedence\n# 12 * 3\n# 36\nprint(result)\n\n# Right-to-left associativity for Exponentiation\nprint(2 ** 3 ** 2)  # 2 ** (3 ** 2) -> 2 ** 9 -> 512\n```\n\n## Tips\n- When in doubt, use parentheses `()` to ensure the order of operations is what you intend. It improves readability.\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/06_Practice_Questions.md", "title": "06 Practice Questions", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/06_Practice_Questions.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Practice Questions - Operators\n\n## Questions\n\n### Q1: Arithmetic\nCalculate `25 // 4` and `25 % 4`. Explain the results.\n\n### Q2: Logic Check\nWhat is the result of `False or (True and False)`?\n\n### Q3: Identity\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b)\nprint(a is b)\n```\nWhat will the two print statements output?\n\n### Q4: Precedence\nEvaluate: `3 * 1 ** 3`.\n\n### Q5: Membership\nHow do you check if the character \"z\" is NOT present in the string \"Python\"?\n\n---\n\n## Solutions\n\n**A1:**\n- `25 // 4` -> `6` (Integer division, goes in 6 times)\n- `25 % 4` -> `1` (Remainder is 1)\n\n**A2:**\n`False`.\n1. `(True and False)` -> `False`\n2. `False or False` -> `False`\n\n**A3:**\n- `True` (Values are equal)\n- `False` (Different objects in memory). `[1, 2, 3]` creates a new list each time.\n\n**A4:**\n`3`.\nExponentiation (`**`) has higher precedence than multiplication (`*`).\n1. `1 ** 3` -> `1`\n2. `3 * 1` -> `3`\n\n**A5:**\n```python\n\"z\" not in \"Python\"  # Returns True\n```\n"}, {"id": "Python_Theory/05_Control_Flow/01_Conditional_Statements.md", "title": "01 Conditional Statements", "type": "Topic", "path": "Python_Theory/05_Control_Flow/01_Conditional_Statements.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# Conditional Statements (if, elif, else)\n\n## Definition\nConditional statements allow the program to execute certain blocks of code only if specific conditions are met.\n\n## Syntax\n\n```python\nif condition:\n    # Code to execute if condition is True\nelif other_condition:\n    # Code to execute if previous conditions were False and this is True\nelse:\n    # Code to execute if all previous conditions were False\n```\n\n## Important Rules\n1.  **Indentation**: The code block under the `if/elif/else` statement must be indented.\n2.  **Order**: `if` comes first, `elif` is optional (can have multiple), and `else` is optional (must be last).\n3.  **Conditions**: Must evaluate to a Boolean (True/False).\n\n## Examples\n\n### Basic If-Else\n```python\nage = 18\n\nif age >= 18:\n    print(\"You are an adult.\")\nelse:\n    print(\"You are a minor.\")\n```\n\n### Multiple Conditions (Elif)\n```python\nscore = 85\n\nif score >= 90:\n    print(\"Grade: A\")\nelif score >= 80:\n    print(\"Grade: B\")\nelif score >= 70:\n    print(\"Grade: C\")\nelse:\n    print(\"Grade: F\")\n```\n\n### Nested If\nYou can have an `if` statement inside another `if` statement.\n\n```python\nx = 25\n\nif x > 10:\n    print(\"Above 10\")\n    if x > 20:\n        print(\"and also above 20!\")\n```\n\n## Short Hand If (Ternary Operator)\nWrite if-else in a single line.\n`value_if_true if condition else value_if_false`\n\n```python\na = 5\nb = 10\nprint(\"A is greater\") if a > b else print(\"B is greater\")\n```\n"}, {"id": "Python_Theory/05_Control_Flow/02_Loops_For.md", "title": "02 Loops For", "type": "Topic", "path": "Python_Theory/05_Control_Flow/02_Loops_For.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# For Loops\n\n## Definition\nA `for` loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string).\n\n## Syntax\n```python\nfor item in sequence:\n    # Code block to be executed\n```\n\n## The `range()` Function\nOften used with for loops to repeat a block of code a specific number of times.\n- `range(stop)`: 0 to stop-1.\n- `range(start, stop)`: start to stop-1.\n- `range(start, stop, step)`: increment by step.\n\n## Examples\n\n### 1. Iterating over a List\n```python\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor x in fruits:\n    print(x)\n```\n\n### 2. Iterating over a String\n```python\nfor char in \"banana\":\n    print(char)\n```\n\n### 3. Using `range()`\n```python\nfor i in range(5):\n    print(i)\n# Output: 0, 1, 2, 3, 4\n\nfor i in range(2, 6):\n    print(i)\n# Output: 2, 3, 4, 5\n```\n\n### 4. Nested Loops\nA loop inside a loop.\n```python\nadj = [\"red\", \"big\"]\nfruits = [\"apple\", \"banana\"]\n\nfor x in adj:\n    for y in fruits:\n        print(x, y)\n```\n"}, {"id": "Python_Theory/05_Control_Flow/03_Loops_While.md", "title": "03 Loops While", "type": "Topic", "path": "Python_Theory/05_Control_Flow/03_Loops_While.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# While Loops\n\n## Definition\nWith the `while` loop, we can execute a set of statements as long as a condition is true.\n\n## Syntax\n```python\nwhile condition:\n    # Code block\n```\n\n**Warning**: Remember to increment/change the variable used in the condition to avoid an **infinite loop**.\n\n## Examples\n\n### Basic While Loop\n```python\ni = 1\nwhile i < 6:\n    print(i)\n    i += 1  # Important: Increment i\n```\n\n## When to use `while` vs `for`?\n- Use **for loops** when you know exactly how many times you want to loop (e.g., iterating over a list).\n- Use **while loops** when you want to loop until a specific condition is met, and you don't know beforehand how many iterations that will take (e.g., waiting for user input).\n\n## Infinite Loops\nSometimes infinite loops are useful (e.g., servers, game loops), but accidental ones crash programs.\n```python\n# Infinite loop example (Use Ctrl+C to stop)\n# while True:\n#     print(\"This will run forever\")\n```\n"}, {"id": "Python_Theory/05_Control_Flow/04_Loop_Control_Statements.md", "title": "04 Loop Control Statements", "type": "Topic", "path": "Python_Theory/05_Control_Flow/04_Loop_Control_Statements.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# Loop Control Statements (break, continue, pass)\n\nLoop control statements change the execution from its normal sequence.\n\n## 1. Break\nTerminates the loop containing it. Control of the program flows to the statement immediately after the body of the loop.\n\n```python\nfor val in \"string\":\n    if val == \"i\":\n        break\n    print(val)\nprint(\"The end\")\n\n# Output:\n# s\n# t\n# r\n# The end\n```\n\n## 2. Continue\nSkips the rest of the code inside `exclude` the current iteration only. Loop does not terminate but continues on with the next iteration.\n\n```python\nfor val in \"string\":\n    if val == \"i\":\n        continue\n    print(val)\nprint(\"The end\")\n\n# Output:\n# s\n# t\n# r\n# n\n# g\n# The end\n```\n\n## 3. Pass\nThe `pass` statement is a null operation; nothing happens when it executes. It is used as a placeholder.\n\n```python\nfor x in [0, 1, 2]:\n    pass # To be implemented later\n```\n\n## The `else` Clause in Loops\nPython allows `else` at the end of a `for` or `while` loop.\n- The `else` block executes **only if the loop completes normally**.\n- It does **not** execute if the loop was stopped by a `break`.\n\n```python\nfor n in range(5):\n    if n == 10:\n        break\nelse:\n    print(\"Loop completed successfully!\")\n# Output: Loop completed successfully!\n```\n"}, {"id": "Python_Theory/05_Control_Flow/05_Practice_Questions.md", "title": "05 Practice Questions", "type": "Topic", "path": "Python_Theory/05_Control_Flow/05_Practice_Questions.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# Practice Questions - Control Flow\n\n## Questions\n\n### Q1: Grading System\nWrite a program that takes a score (0-100) and prints:\n- \"A\" if score > 90\n- \"B\" if score > 80\n- \"C\" if score > 70\n- \"Fail\" otherwise.\n\n### Q2: Sum of Numbers\nWrite a `for` loop to calculate the sum of all numbers from 1 to 100.\n\n### Q3: Pattern Printing\nUse nested loops to print the following pattern:\n```\n*\n**\n***\n****\n*****\n```\n\n### Q4: Finder\nWrite a loop that searches for the number `5` in the list `[1, 9, 3, 5, 7]`. If found, print \"Found!\" and stop the loop.\n\n---\n\n## Solutions\n\n**A1:**\n```python\nscore = 85\nif score > 90:\n    print(\"A\")\nelif score > 80:\n    print(\"B\")\nelif score > 70:\n    print(\"C\")\nelse:\n    print(\"Fail\")\n```\n\n**A2:**\n```python\ntotal = 0\nfor i in range(1, 101):\n    total += i\nprint(total) # 5050\n```\n\n**A3:**\n```python\nfor i in range(1, 6):\n    print(\"*\" * i)\n# OR nested loop way:\n# for i in range(1, 6):\n#    for j in range(i):\n#        print(\"*\", end=\"\")\n#    print()\n```\n\n**A4:**\n```python\nnums = [1, 9, 3, 5, 7]\nfor n in nums:\n    if n == 5:\n        print(\"Found!\")\n        break\n```\n"}, {"id": "Python_Theory/06_Functions/01_Definition_Syntax.md", "title": "01 Definition Syntax", "type": "Topic", "path": "Python_Theory/06_Functions/01_Definition_Syntax.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Functions Definition and Syntax\n\n## Definition\nA **function** is a block of organized, reusable code that is used to perform a single, related action. Functions provide better modularity for your application and a high degree of code reusing.\n\n## Theory\n- **Abstractions**: Functions allow you to abstract logic. Instead of repeating 10 lines of code, you call a function once.\n- **Maintainability**: If you need to change logic, you only change it in one place (the function definition).\n\n## Syntax\n- Defined using the `def` keyword.\n- Function name should follow variable naming conventions (snake_case).\n- Parentheses `()` allow passing parameters.\n- A colon `:` starts the function block.\n- The function body must be indented.\n- An optional `return` statement exits the function, passing back a value.\n\n```python\ndef function_name(parameters):\n    \"\"\"docstring\"\"\"\n    # statement(s)\n    return expression\n```\n\n## First Function Example\n\n```python\n# Definition\ndef say_hello():\n    print(\"Hello from a function\")\n\n# Calling the function\nsay_hello()\n```\n\n## Pass by Object Reference\nPython uses a mechanism known as \"Call by Object Reference\".\n- If you pass an **immutable** object (int, str, tuple), the function cannot modify the original object.\n- If you pass a **mutable** object (list, dict), the function *can* modify the contents of the object.\n"}, {"id": "Python_Theory/06_Functions/02_Parameters_Arguments.md", "title": "02 Parameters Arguments", "type": "Topic", "path": "Python_Theory/06_Functions/02_Parameters_Arguments.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Parameters and Arguments\n\n## Definition\n- **Parameter**: The variable listed inside the parentheses in the function definition.\n- **Argument**: The value that is sent to the function when it is called.\n\n## Types of Arguments\n\n### 1. Positional Arguments\nThe most common type. Arguments must be passed in the correct order.\n\n```python\ndef describe_pet(animal_type, pet_name):\n    print(f\"I have a {animal_type} named {pet_name}.\")\n\ndescribe_pet(\"hamster\", \"Harry\")\n```\n\n### 2. Keyword Arguments\nYou specify the parameter name when calling the function. Order doesn't matter.\n\n```python\ndescribe_pet(pet_name=\"Harry\", animal_type=\"hamster\")\n```\n\n### 3. Default Arguments\nParameters can have default values. If the argument is omitted, the default is used.\n\n```python\ndef describe_pet(pet_name, animal_type=\"dog\"):\n    print(f\"I have a {animal_type} named {pet_name}.\")\n\ndescribe_pet(\"Willie\")         # Uses default \"dog\"\ndescribe_pet(\"Harry\", \"cat\")   # Overrides default\n```\n\n### 4. Arbitrary Arguments (`*args`)\nUsed when you don't know how many arguments will be passed. Receiving a tuple of arguments.\n\n```python\ndef make_pizza(*toppings):\n    print(toppings)\n    for topping in toppings:\n        print(f\"- {topping}\")\n\nmake_pizza(\"pepperoni\")\nmake_pizza(\"mushrooms\", \"green peppers\", \"extra cheese\")\n```\n\n### 5. Arbitrary Keyword Arguments (`**kwargs`)\nUsed when you don't know how many keyword arguments will be passed. Receives a dictionary.\n\n```python\ndef build_profile(first, last, **user_info):\n    user_info['first_name'] = first\n    user_info['last_name'] = last\n    return user_info\n\nuser_profile = build_profile('albert', 'einstein', location='princeton', field='physics')\nprint(user_profile)\n```\n"}, {"id": "Python_Theory/06_Functions/03_Return_Statement.md", "title": "03 Return Statement", "type": "Topic", "path": "Python_Theory/06_Functions/03_Return_Statement.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Return Statement\n\n## Definition\nThe `return` statement is used to exit a function and go back to the place from where it was called.\n\n## Usage\n- **Returning a value**: `return result`\n- **Returning `None`**: If `return` is omitted or used without a value, the function returns `None`.\n- **Exiting early**: `return` can be used to stop function execution based on a condition.\n\n## Multiple Return Values\nPython allows returning multiple values. It effectively packs them into a **tuple**.\n\n```python\ndef get_user():\n    name = \"John\"\n    age = 30\n    return name, age\n\nname, age = get_user()\nprint(name) # John\n```\n\n## Examples\n\n### Basic Return\n```python\ndef add(a, b):\n    return a + b\n\nresult = add(5, 3)\nprint(result) # 8\n```\n\n### Early Exit\n```python\ndef absolute_value(num):\n    if num >= 0:\n        return num\n    return -num\n\nprint(absolute_value(-10)) # 10\n```\n"}, {"id": "Python_Theory/06_Functions/04_Scope_Lifetime.md", "title": "04 Scope Lifetime", "type": "Topic", "path": "Python_Theory/06_Functions/04_Scope_Lifetime.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Scope and Lifetime\n\n## Definition\n- **Scope**: The region of code where a variable is defined and can be accessed.\n- **Lifetime**: How long a variable exists in memory.\n\n## Types of Scope (LEGB Rule)\nPython resolves names using the LEGB rule:\n1.  **L**ocal: Defined inside function/class.\n2.  **E**nclosing: Defined in enclosing functions (nested functions).\n3.  **G**lobal: Defined at the uppermost level.\n4.  **B**uilt-in: Reserved names in Python modules (e.g., `print`, `len`).\n\n## Global vs Local\n\n### Local Scope\nVariables created inside a function are local to it.\n```python\ndef my_func():\n    x = 10  # Local scope\n    print(x)\n\nmy_func()\n# print(x) # NameError: name 'x' is not defined\n```\n\n### Global Scope\nVariables created outside functions are global.\n```python\nx = 100 # Global\n\ndef my_func():\n    print(x) # Access global x\n\nmy_func()\n```\n\n## The `global` Keyword\nTo modify a global variable inside a function, use `global`.\n```python\ncount = 0\n\ndef increment():\n    global count\n    count += 1\n\nincrement()\nprint(count) # 1\n```\n\n## Common Errors\n- **UnboundLocalError**: Trying to modify a global variable inside a function without declaring it global, but treating it like a local variable.\n    ```python\n    x = 10\n    def broken():\n        print(x) # Errors here because Python sees assignment below and thinks x is local\n        x = 5\n    ```\n"}, {"id": "Python_Theory/06_Functions/05_Lambda_Functions.md", "title": "05 Lambda Functions", "type": "Topic", "path": "Python_Theory/06_Functions/05_Lambda_Functions.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Lambda Functions (Anonymous Functions)\n\n## Definition\nA **lambda function** is a small anonymous function.\n- It can take any number of arguments, but can only have **one expression**.\n- It returns the result of the expression automatically.\n\n## Syntax\n```python\nlambda arguments: expression\n```\n\n## Examples\n\n### 1. Basic Usage\n```python\n# A lambda that adds 10 to the argument\nx = lambda a: a + 10\nprint(x(5))  # 15\n```\n\n### 2. Multiple Arguments\n```python\n# Multiply argument a with argument b\nx = lambda a, b: a * b\nprint(x(5, 6))  # 30\n```\n\n## When to Use?\nLambda functions are most useful when used as an **anonymous function inside another function**, especially with higher-order functions like `map()`, `filter()`, and `reduce()`.\n\n### Example with `filter()`\nKeep only even numbers.\n```python\nnums = [1, 5, 4, 6, 8, 11, 3, 12]\n\nevens = list(filter(lambda x: x % 2 == 0, nums))\nprint(evens) # [4, 6, 8, 12]\n```\n\n### Example with `map()`\nDouble every number.\n```python\nnums = [1, 2, 3, 4]\n\ndoubled = list(map(lambda x: x * 2, nums))\nprint(doubled) # [2, 4, 6, 8]\n```\n"}, {"id": "Python_Theory/06_Functions/06_Recursion.md", "title": "06 Recursion", "type": "Topic", "path": "Python_Theory/06_Functions/06_Recursion.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Recursion\n\n## Definition\n**Recursion** is a common mathematical and programming concept. It means that a function **calls itself**.\n\n## Theory\n- **Base Case**: The condition that stops the recursion. Without it, the function calls itself forever (Stack Overflow).\n- **Recursive Case**: The part where the function calls itself with a modified parameter, moving towards the base case.\n\n## Example: Factorial\nFactorial of n (`n!`) is `n * (n-1) * ... * 1`.\n`5! = 5 * 4 * 3 * 2 * 1 = 120`.\n\n```python\ndef factorial(n):\n    # Base Case\n    if n == 1:\n        return 1\n    # Recursive Case\n    else:\n        return n * factorial(n - 1)\n\nprint(factorial(5)) # 120\n```\n\n## Analysis of Execution\n`factorial(5)` calls `5 * factorial(4)`\n    `factorial(4)` calls `4 * factorial(3)`\n        `factorial(3)` calls `3 * factorial(2)`\n            `factorial(2)` calls `2 * factorial(1)`\n                `factorial(1)` returns `1`\n\n## Pros and Cons\n- **Pros**: Code looks clean and elegant for problems like tree traversals, sorting (Merge Sort, Quick Sort).\n- **Cons**: Can be memory-intensive (maintains a stack frame for each call). Python has a recursion limit (usually 1000).\n\n## Common Errors\n- **RecursionError: maximum recursion depth exceeded**: Happens when there is no base case or the base case is unreachable.\n"}, {"id": "Python_Theory/06_Functions/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/06_Functions/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Practice Questions - Functions\n\n## Questions\n\n### Q1: Calculator Function\nWrite a function `calculate(a, b, operation)` where `operation` is a string (`add`, `sub`). It should return the result.\n\n### Q2: Lambda Sort\nGiven a list of tuples: `points = [(1, 2), (3, 1), (5, 0)]`.\nuse a lambda function to sort this list by the *second* element of each tuple.\n\n### Q3: Factorial Recursion\nWrite a recursive function that returns the sum of natural numbers up to `n`. `sum(3) -> 3+2+1 = 6`.\n\n### Q4: Default Arguments\nDefine a function `greet(name, msg=\"Good morning!\")`. Call it in two ways: once with just a name, and once with a name and a custom message.\n\n### Q5: Scope Debug\nWhat is the output of this code?\n```python\nx = 10\ndef change():\n    x = 20\nchange()\nprint(x)\n```\n\n---\n\n## Solutions\n\n**A1:**\n```python\ndef calculate(a, b, operation):\n    if operation == \"add\":\n        return a + b\n    elif operation == \"sub\":\n        return a - b\n\nprint(calculate(10, 5, \"add\")) # 15\n```\n\n**A2:**\n```python\npoints = [(1, 2), (3, 1), (5, 0)]\npoints.sort(key=lambda x: x[1])\nprint(points)\n# Output: [(5, 0), (3, 1), (1, 2)]\n```\n\n**A3:**\n```python\ndef sum_n(n):\n    if n == 1:\n        return 1\n    return n + sum_n(n - 1)\n```\n\n**A4:**\n```python\ngreet(\"Alice\")\ngreet(\"Bob\", \"How are you?\")\n```\n\n**A5:**\n`10`. The function `change()` creates a *local* variable `x` and sets it to 20. It does not affect the *global* `x`.\n"}, {"id": "Python_Theory/07_Modules_and_Packages/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/07_Modules_and_Packages/01_Definition.md", "breadcrumbs": ["Python Theory", "07 Modules and Packages"], "content": "# Modules and Packages\n\n## Definition\n\n### Module\nA **module** is a file containing Python code (functions, classes, variables). Any `.py` file is a module.\n- Purpose: Organize code into logical units.\n- Reusability: Write once, import anywhere.\n\n### Package\nA **package** is a directory containing multiple modules and a special `__init__.py` file.\n- Purpose: Organize related modules into a hierarchy.\n- Example: `numpy`, `django` are packages.\n\n## Why Use Modules?\n\n1. **Code Organization**: Break large programs into smaller, manageable files.\n2. **Reusability**: Import the same code in multiple projects.\n3. **Namespace Management**: Avoid name conflicts.\n4. **Maintainability**: Easier to debug and update specific functionality.\n\n## Module vs Script\n\n| Aspect | Module | Script |\n|--------|--------|--------|\n| Purpose | To be imported | To be executed |\n| `__name__` | Module name | `\"__main__\"` |\n| Usage | `import mymodule` | `python script.py` |\n"}, {"id": "Python_Theory/07_Modules_and_Packages/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/07_Modules_and_Packages/02_Theory.md", "breadcrumbs": ["Python Theory", "07 Modules and Packages"], "content": "# Importing Modules\n\n## Basic Import Syntax\n\n### 1. Import Entire Module\n```python\nimport math\n\nprint(math.sqrt(16))  # 4.0\nprint(math.pi)        # 3.141592653589793\n```\n\n### 2. Import with Alias\n```python\nimport numpy as np\n\narr = np.array([1, 2, 3])\n```\n\n### 3. Import Specific Items\n```python\nfrom math import sqrt, pi\n\nprint(sqrt(16))  # 4.0\nprint(pi)        # 3.141592653589793\n```\n\n### 4. Import All (Not Recommended)\n```python\nfrom math import *\n\n# Can use all functions directly\nprint(sqrt(25))  # 5.0\n```\n**Warning**: Pollutes namespace, can cause conflicts.\n\n## The `import` Statement Mechanics\n\nWhen you `import mymodule`:\n1. Python searches for `mymodule.py` in:\n   - Current directory\n   - `PYTHONPATH` environment variable directories\n   - Standard library directories\n2. Compiles to bytecode (`.pyc` file in `__pycache__`)\n3. Executes the module code\n4. Creates a module object in memory\n\n## The `sys.path` List\n```python\nimport sys\nprint(sys.path)\n```\nShows all directories Python searches for modules.\n\n## Relative vs Absolute Imports\n\n### Absolute Import\n```python\nfrom package.subpackage import module\n```\n\n### Relative Import (within packages)\n```python\nfrom . import sibling_module        # Same directory\nfrom .. import parent_module        # Parent directory\nfrom ..sibling_package import mod   # Sibling package\n```\n\n## Circular Import Problem\n\n**Problem:**\n```python\n# file_a.py\nimport file_b\ndef func_a():\n    file_b.func_b()\n\n# file_b.py\nimport file_a\ndef func_b():\n    file_a.func_a()\n```\n\n**Solution**: Restructure code or use local imports.\n\n## Lazy Importing\nImport inside functions to delay loading:\n```python\ndef process_data():\n    import pandas as pd  # Only loaded when function is called\n    df = pd.DataFrame()\n```\n"}, {"id": "Python_Theory/07_Modules_and_Packages/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/07_Modules_and_Packages/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "07 Modules and Packages"], "content": "# Creating Your Own Modules\n\n## Step 1: Create a `.py` File\n\n**mymath.py**\n```python\n\"\"\"\nA simple math utilities module.\n\"\"\"\n\ndef add(a, b):\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\ndef multiply(a, b):\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n\nPI = 3.14159\n```\n\n## Step 2: Import and Use\n\n**main.py**\n```python\nimport mymath\n\nresult = mymath.add(5, 3)\nprint(result)  # 8\n\nprint(mymath.PI)  # 3.14159\n```\n\n## The `__name__` Variable\n\n```python\n# mymodule.py\ndef greet():\n    print(\"Hello from mymodule!\")\n\nif __name__ == \"__main__\":\n    # This code only runs when the file is executed directly\n    print(\"Running as script\")\n    greet()\nelse:\n    # This runs when imported\n    print(\"Imported as module\")\n```\n\n**Usage:**\n- `python mymodule.py` \u2192 Prints \"Running as script\"\n- `import mymodule` \u2192 Prints \"Imported as module\"\n\n## Module Attributes\n\nEvery module has special attributes:\n- `__name__`: Module name\n- `__file__`: File path\n- `__doc__`: Docstring\n- `__dict__`: Module namespace\n\n```python\nimport math\nprint(math.__name__)  # 'math'\nprint(math.__doc__)   # Module documentation\n```\n\n## Best Practices\n\n1. **One module = One responsibility**\n2. **Use docstrings** for documentation\n3. **Avoid global state** (mutable module-level variables)\n4. **Use `if __name__ == \"__main__\":`** for test code\n"}, {"id": "Python_Theory/07_Modules_and_Packages/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/07_Modules_and_Packages/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "07 Modules and Packages"], "content": "# Creating Packages\n\n## Package Structure\n\n```\nmypackage/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 module1.py\n\u251c\u2500\u2500 module2.py\n\u2514\u2500\u2500 subpackage/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 module3.py\n```\n\n## The `__init__.py` File\n\nMakes a directory a package. Can be empty or contain initialization code.\n\n**mypackage/__init__.py**\n```python\n\"\"\"\nMy custom package.\n\"\"\"\n\n# Import commonly used items to package level\nfrom .module1 import func1\nfrom .module2 import func2\n\n__version__ = \"1.0.0\"\n__all__ = ['func1', 'func2']  # Controls `from mypackage import *`\n```\n\n## Importing from Packages\n\n```python\n# Import module\nimport mypackage.module1\n\n# Import specific function\nfrom mypackage.module1 import func1\n\n# Import from subpackage\nfrom mypackage.subpackage import module3\n```\n\n## Namespace Packages (PEP 420)\n\nPython 3.3+ allows packages without `__init__.py`:\n```\nmypackage/\n\u251c\u2500\u2500 module1.py\n\u2514\u2500\u2500 module2.py\n```\n\nStill works, but no package-level initialization.\n\n## `__all__` Variable\n\nControls what gets imported with `from package import *`:\n\n```python\n# __init__.py\n__all__ = ['module1', 'module2']  # Only these are imported with *\n```\n"}, {"id": "Python_Theory/07_Modules_and_Packages/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/07_Modules_and_Packages/05_Examples.md", "breadcrumbs": ["Python Theory", "07 Modules and Packages"], "content": "# Package Management with pip\n\n## What is pip?\n\n**pip** = \"Pip Installs Packages\"\n- Python's package installer\n- Installs packages from PyPI (Python Package Index)\n\n## Basic Commands\n\n### Install a Package\n```bash\npip install package_name\npip install requests\n```\n\n### Install Specific Version\n```bash\npip install package_name==1.2.3\npip install numpy==1.21.0\n```\n\n### Upgrade a Package\n```bash\npip install --upgrade package_name\npip install -U numpy\n```\n\n### Uninstall a Package\n```bash\npip uninstall package_name\n```\n\n### List Installed Packages\n```bash\npip list\npip freeze  # Format suitable for requirements.txt\n```\n\n### Show Package Info\n```bash\npip show package_name\n```\n\n## Requirements File\n\n**requirements.txt**\n```\nnumpy==1.21.0\npandas>=1.3.0\nrequests\n```\n\n### Install from requirements.txt\n```bash\npip install -r requirements.txt\n```\n\n### Generate requirements.txt\n```bash\npip freeze > requirements.txt\n```\n\n## Virtual Environments\n\n### Why Use Virtual Environments?\n- Isolate project dependencies\n- Avoid version conflicts\n- Reproducible environments\n\n### Create Virtual Environment\n```bash\n# Using venv (built-in)\npython -m venv myenv\n\n# Activate (Windows)\nmyenv\\Scripts\\activate\n\n# Activate (Mac/Linux)\nsource myenv/bin/activate\n\n# Deactivate\ndeactivate\n```\n\n### Using virtualenv\n```bash\npip install virtualenv\nvirtualenv myenv\n```\n\n## Best Practices\n\n1. **Always use virtual environments** for projects\n2. **Pin versions** in requirements.txt for production\n3. **Update regularly** but test thoroughly\n4. **Use `pip list --outdated`** to check for updates\n"}, {"id": "Python_Theory/07_Modules_and_Packages/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/07_Modules_and_Packages/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "07 Modules and Packages"], "content": "# Common Module Errors\n\n## 1. ModuleNotFoundError\n\n**Error:**\n```python\nimport nonexistent_module\n# ModuleNotFoundError: No module named 'nonexistent_module'\n```\n\n**Solutions:**\n- Install the package: `pip install module_name`\n- Check spelling\n- Ensure module is in `sys.path`\n\n## 2. ImportError\n\n**Error:**\n```python\nfrom math import nonexistent_function\n# ImportError: cannot import name 'nonexistent_function'\n```\n\n**Solution:** Check the module's documentation for correct names.\n\n## 3. Circular Import\n\n**file_a.py:**\n```python\nimport file_b\ndef func_a():\n    return file_b.func_b()\n```\n\n**file_b.py:**\n```python\nimport file_a\ndef func_b():\n    return file_a.func_a()\n```\n\n**Error:** Infinite loop or `AttributeError`\n\n**Solutions:**\n- Restructure code to remove circular dependency\n- Use local imports (import inside function)\n- Use `import` instead of `from ... import`\n\n## 4. Name Conflicts\n\n```python\nfrom math import *\nfrom numpy import *\n\n# Which sqrt() is being used? Namespace pollution!\nresult = sqrt(16)\n```\n\n**Solution:** Use explicit imports or aliases.\n\n## 5. Relative Import in Non-Package\n\n**Error:**\n```python\nfrom . import module  # ValueError: attempted relative import in non-package\n```\n\n**Solution:** Ensure you're inside a package (directory with `__init__.py`).\n\n## 6. Module Caching\n\nPython caches imported modules. Changes to a module won't reflect until restart.\n\n**Solution:**\n```python\nimport importlib\nimportlib.reload(mymodule)\n```\n"}, {"id": "Python_Theory/07_Modules_and_Packages/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/07_Modules_and_Packages/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "07 Modules and Packages"], "content": "# Practice Questions - Modules and Packages\n\n## Questions\n\n### Q1: Create a Module\nCreate a module `calculator.py` with functions for add, subtract, multiply, and divide. Import and use it in another file.\n\n### Q2: Package Structure\nCreate a package `geometry` with modules `circle.py` and `rectangle.py`, each containing area and perimeter functions.\n\n### Q3: Import Variations\nGiven `import math`, write three different ways to calculate the square root of 25.\n\n### Q4: Virtual Environment\nCreate a virtual environment, activate it, install `requests`, and freeze the requirements.\n\n### Q5: Fix the Import\n```python\n# main.py\nimport utils\n\nprint(utils.greet(\"Alice\"))\n```\n\nCreate `utils.py` to make this work.\n\n---\n\n## Solutions\n\n### A1: Calculator Module\n\n**calculator.py:**\n```python\ndef add(a, b):\n    return a + b\n\ndef subtract(a, b):\n    return a - b\n\ndef multiply(a, b):\n    return a * b\n\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n```\n\n**main.py:**\n```python\nimport calculator\n\nprint(calculator.add(10, 5))       # 15\nprint(calculator.subtract(10, 5))  # 5\nprint(calculator.multiply(10, 5))  # 50\nprint(calculator.divide(10, 5))    # 2.0\n```\n\n### A2: Geometry Package\n\n```\ngeometry/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 circle.py\n\u2514\u2500\u2500 rectangle.py\n```\n\n**geometry/circle.py:**\n```python\nimport math\n\ndef area(radius):\n    return math.pi * radius ** 2\n\ndef perimeter(radius):\n    return 2 * math.pi * radius\n```\n\n**geometry/rectangle.py:**\n```python\ndef area(length, width):\n    return length * width\n\ndef perimeter(length, width):\n    return 2 * (length + width)\n```\n\n**geometry/__init__.py:**\n```python\nfrom . import circle\nfrom . import rectangle\n```\n\n**Usage:**\n```python\nfrom geometry import circle, rectangle\n\nprint(circle.area(5))\nprint(rectangle.area(10, 5))\n```\n\n### A3: Import Variations\n\n```python\nimport math\n\n# Method 1\nresult1 = math.sqrt(25)\n\n# Method 2\nfrom math import sqrt\nresult2 = sqrt(25)\n\n# Method 3\nimport math as m\nresult3 = m.sqrt(25)\n```\n\n### A4: Virtual Environment\n\n```bash\n# Create\npython -m venv myenv\n\n# Activate (Windows)\nmyenv\\Scripts\\activate\n\n# Install\npip install requests\n\n# Freeze\npip freeze > requirements.txt\n```\n\n### A5: Fix the Import\n\n**utils.py:**\n```python\ndef greet(name):\n    return f\"Hello, {name}!\"\n```\n"}, {"id": "Python_Theory/08_Strings/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/08_Strings/01_Definition.md", "breadcrumbs": ["Python Theory", "08 Strings"], "content": "# Strings in Python\n\n## Definition\nA **string** is a sequence of characters enclosed in quotes. Strings are **immutable** - once created, they cannot be changed.\n\n## Creating Strings\n```python\n# Single quotes\ns1 = 'Hello'\n\n# Double quotes\ns2 = \"World\"\n\n# Triple quotes (multiline)\ns3 = \"\"\"This is\na multiline\nstring\"\"\"\n\n# Raw strings (ignore escape sequences)\ns4 = r\"C:\\new\\path\"\n```\n\n## String Immutability\n```python\ntext = \"Hello\"\n# text[0] = 'h'  # TypeError: 'str' object does not support item assignment\n\n# Must create new string\ntext = 'h' + text[1:]  # \"hello\"\n```\n\n## String as Sequence\nStrings are sequences, supporting indexing and slicing like lists.\n"}, {"id": "Python_Theory/08_Strings/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/08_Strings/02_Theory.md", "breadcrumbs": ["Python Theory", "08 Strings"], "content": "# String Indexing and Slicing\n\n## Indexing\n```python\ntext = \"Python\"\nprint(text[0])   # 'P' (first character)\nprint(text[-1])  # 'n' (last character)\nprint(text[-2])  # 'o' (second from end)\n```\n\n## Slicing\nSyntax: `string[start:end:step]`\n\n```python\ntext = \"Python Programming\"\n\nprint(text[0:6])    # \"Python\" (index 0 to 5)\nprint(text[:6])     # \"Python\" (start defaults to 0)\nprint(text[7:])     # \"Programming\" (end defaults to length)\nprint(text[::2])    # \"Pto rgamn\" (every 2nd character)\nprint(text[::-1])   # \"gnimmargorP nohtyP\" (reverse)\n```\n\n## String Concatenation and Repetition\n```python\ns1 = \"Hello\"\ns2 = \"World\"\n\n# Concatenation\nresult = s1 + \" \" + s2  # \"Hello World\"\n\n# Repetition\nrepeat = \"Ha\" * 3  # \"HaHaHa\"\n```\n"}, {"id": "Python_Theory/08_Strings/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/08_Strings/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "08 Strings"], "content": "# String Methods\n\n## Case Conversion\n```python\ntext = \"Hello World\"\n\nprint(text.upper())       # \"HELLO WORLD\"\nprint(text.lower())       # \"hello world\"\nprint(text.capitalize())  # \"Hello world\"\nprint(text.title())       # \"Hello World\"\nprint(text.swapcase())    # \"hELLO wORLD\"\n```\n\n## Searching\n```python\ntext = \"Python Programming\"\n\nprint(text.find(\"Pro\"))      # 7 (index of first occurrence)\nprint(text.find(\"Java\"))     # -1 (not found)\nprint(text.index(\"Pro\"))     # 7 (raises ValueError if not found)\nprint(text.count(\"m\"))       # 2\nprint(text.startswith(\"Py\")) # True\nprint(text.endswith(\"ing\"))  # True\n```\n\n## Modification\n```python\ntext = \"  Hello World  \"\n\nprint(text.strip())        # \"Hello World\" (remove whitespace)\nprint(text.lstrip())       # \"Hello World  \"\nprint(text.rstrip())       # \"  Hello World\"\nprint(text.replace(\"World\", \"Python\"))  # \"  Hello Python  \"\n```\n\n## Splitting and Joining\n```python\ntext = \"apple,banana,cherry\"\n\n# Split\nfruits = text.split(\",\")  # ['apple', 'banana', 'cherry']\n\n# Join\nresult = \" - \".join(fruits)  # \"apple - banana - cherry\"\n```\n\n## Checking\n```python\nprint(\"123\".isdigit())     # True\nprint(\"abc\".isalpha())     # True\nprint(\"abc123\".isalnum())  # True\nprint(\"   \".isspace())     # True\n```\n"}, {"id": "Python_Theory/08_Strings/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/08_Strings/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "08 Strings"], "content": "# String Formatting\n\n## 1. f-strings (Python 3.6+) - RECOMMENDED\n```python\nname = \"Alice\"\nage = 30\n\nmessage = f\"My name is {name} and I am {age} years old\"\nprint(message)\n\n# Expressions inside {}\nprint(f\"Next year I'll be {age + 1}\")\n\n# Formatting numbers\npi = 3.14159\nprint(f\"Pi is approximately {pi:.2f}\")  # 3.14\n```\n\n## 2. str.format()\n```python\nmessage = \"My name is {} and I am {} years old\".format(\"Bob\", 25)\n\n# Named placeholders\nmessage = \"My name is {name} and I am {age} years old\".format(name=\"Bob\", age=25)\n\n# Formatting\nprint(\"{:.2f}\".format(3.14159))  # 3.14\n```\n\n## 3. % Operator (Old Style)\n```python\nname = \"Charlie\"\nage = 35\n\nmessage = \"My name is %s and I am %d years old\" % (name, age)\n```\n\n## Format Specifications\n```python\nnumber = 1234.5678\n\nprint(f\"{number:10}\")      # '1234.5678 ' (width 10)\nprint(f\"{number:10.2f}\")   # '   1234.57' (width 10, 2 decimals)\nprint(f\"{number:010.2f}\")  # '0001234.57' (zero-padded)\nprint(f\"{number:,}\")       # '1,234.5678' (thousands separator)\n```\n"}, {"id": "Python_Theory/08_Strings/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/08_Strings/05_Examples.md", "breadcrumbs": ["Python Theory", "08 Strings"], "content": "# String Examples\n\n## Example 1: Palindrome Checker\n```python\ndef is_palindrome(text):\n    text = text.lower().replace(\" \", \"\")\n    return text == text[::-1]\n\nprint(is_palindrome(\"racecar\"))      # True\nprint(is_palindrome(\"A man a plan a canal Panama\"))  # True\n```\n\n## Example 2: Word Counter\n```python\ntext = \"Python is awesome. Python is powerful.\"\n\nwords = text.lower().split()\nword_count = {}\n\nfor word in words:\n    word = word.strip(\".,!?\")\n    word_count[word] = word_count.get(word, 0) + 1\n\nprint(word_count)  # {'python': 2, 'is': 2, 'awesome': 1, 'powerful': 1}\n```\n\n## Example 3: Email Validator\n```python\ndef is_valid_email(email):\n    return \"@\" in email and \".\" in email.split(\"@\")[1]\n\nprint(is_valid_email(\"user@example.com\"))  # True\nprint(is_valid_email(\"invalid.email\"))     # False\n```\n\n## Example 4: Title Case Converter\n```python\ntext = \"the quick brown fox\"\ntitle = text.title()\nprint(title)  # \"The Quick Brown Fox\"\n```\n\n## Example 5: Remove Duplicates\n```python\ntext = \"hello\"\nunique = \"\".join(sorted(set(text), key=text.index))\nprint(unique)  # \"helo\"\n```\n"}, {"id": "Python_Theory/08_Strings/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/08_Strings/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "08 Strings"], "content": "# Common String Errors\n\n## 1. TypeError: Can Only Concatenate str\n```python\n# WRONG\nage = 25\nmessage = \"I am \" + age + \" years old\"  # TypeError\n\n# CORRECT\nmessage = \"I am \" + str(age) + \" years old\"\n# OR\nmessage = f\"I am {age} years old\"\n```\n\n## 2. IndexError: String Index Out of Range\n```python\ntext = \"Hello\"\n# print(text[10])  # IndexError\n\n# CORRECT - Check length first\nif len(text) > 10:\n    print(text[10])\n```\n\n## 3. Immutability Error\n```python\ntext = \"Hello\"\n# text[0] = 'h'  # TypeError: 'str' object does not support item assignment\n\n# CORRECT\ntext = 'h' + text[1:]\n```\n\n## 4. Encoding/Decoding Errors\n```python\n# UnicodeDecodeError when reading files\nwith open(\"file.txt\", \"r\", encoding=\"utf-8\") as f:\n    content = f.read()\n```\n\n## 5. Strip vs Replace\n```python\ntext = \"  Hello  \"\n\n# strip() only removes from ends\nprint(text.strip())  # \"Hello\"\n\n# replace() removes all occurrences\nprint(text.replace(\" \", \"\"))  # \"Hello\"\n```\n"}, {"id": "Python_Theory/08_Strings/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/08_Strings/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "08 Strings"], "content": "# Practice Questions - Strings\n\n## Questions\n\n### Q1: Reverse a String\nWrite a function to reverse a string without using slicing.\n\n### Q2: Count Vowels\nCount the number of vowels in a string.\n\n### Q3: Remove Whitespace\nRemove all whitespace from a string.\n\n### Q4: Anagram Checker\nCheck if two strings are anagrams.\n\n### Q5: Caesar Cipher\nImplement a Caesar cipher that shifts each letter by 3 positions.\n\n---\n\n## Solutions\n\n### A1: Reverse String\n```python\ndef reverse_string(s):\n    result = \"\"\n    for char in s:\n        result = char + result\n    return result\n\nprint(reverse_string(\"Python\"))  # \"nohtyP\"\n```\n\n### A2: Count Vowels\n```python\ndef count_vowels(s):\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n\nprint(count_vowels(\"Hello World\"))  # 3\n```\n\n### A3: Remove Whitespace\n```python\ndef remove_whitespace(s):\n    return s.replace(\" \", \"\")\n\nprint(remove_whitespace(\"Hello World\"))  # \"HelloWorld\"\n```\n\n### A4: Anagram Checker\n```python\ndef is_anagram(s1, s2):\n    return sorted(s1.lower()) == sorted(s2.lower())\n\nprint(is_anagram(\"listen\", \"silent\"))  # True\nprint(is_anagram(\"hello\", \"world\"))    # False\n```\n\n### A5: Caesar Cipher\n```python\ndef caesar_cipher(text, shift=3):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            start = ord('A') if char.isupper() else ord('a')\n            shifted = chr((ord(char) - start + shift) % 26 + start)\n            result += shifted\n        else:\n            result += char\n    return result\n\nprint(caesar_cipher(\"Hello\"))  # \"Khoor\"\n```\n"}, {"id": "Python_Theory/09_Lists_Tuples_Sets_Dicts/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/01_Definition.md", "breadcrumbs": ["Python Theory", "09 Lists Tuples Sets Dicts"], "content": "# Python Data Structures\n\n## Overview\n\nPython has 4 built-in data structures for storing collections:\n\n### 1. List `[]`\n- **Ordered**, **mutable**, allows **duplicates**\n- Use when: You need an ordered collection that can change\n\n### 2. Tuple `()`\n- **Ordered**, **immutable**, allows **duplicates**\n- Use when: You need an ordered collection that won't change\n\n### 3. Set `{}`\n- **Unordered**, **mutable**, **no duplicates**\n- Use when: You need unique items and don't care about order\n\n### 4. Dictionary `{key: value}`\n- **Ordered** (Python 3.7+), **mutable**, keys must be **unique**\n- Use when: You need key-value pairs for fast lookups\n\n## Comparison Table\n\n| Feature | List | Tuple | Set | Dict |\n|---------|------|-------|-----|------|\n| Syntax | `[1, 2, 3]` | `(1, 2, 3)` | `{1, 2, 3}` | `{'a': 1}` |\n| Ordered | \u2713 | \u2713 | \u2717 | \u2713 (3.7+) |\n| Mutable | \u2713 | \u2717 | \u2713 | \u2713 |\n| Duplicates | \u2713 | \u2713 | \u2717 | Keys: \u2717 |\n| Indexing | \u2713 | \u2713 | \u2717 | By key |\n"}, {"id": "Python_Theory/09_Lists_Tuples_Sets_Dicts/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/02_Theory.md", "breadcrumbs": ["Python Theory", "09 Lists Tuples Sets Dicts"], "content": "# Lists - Theory and Operations\n\n## Creating Lists\n```python\n# Empty list\nempty = []\n\n# List with items\nnumbers = [1, 2, 3, 4, 5]\nmixed = [1, \"hello\", 3.14, True]\n\n# List comprehension\nsquares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]\n```\n\n## List Methods\n\n### Adding Elements\n```python\nfruits = [\"apple\", \"banana\"]\n\nfruits.append(\"cherry\")       # Add to end\nfruits.insert(1, \"orange\")    # Insert at index\nfruits.extend([\"grape\", \"kiwi\"])  # Add multiple\n```\n\n### Removing Elements\n```python\nfruits.remove(\"banana\")  # Remove first occurrence\npopped = fruits.pop()    # Remove and return last item\npopped = fruits.pop(0)   # Remove and return at index\nfruits.clear()           # Remove all\n```\n\n### Other Methods\n```python\nnumbers = [3, 1, 4, 1, 5]\n\nnumbers.sort()           # Sort in place\nnumbers.reverse()        # Reverse in place\ncount = numbers.count(1) # Count occurrences\nindex = numbers.index(4) # Find index\n```\n\n## List Slicing\n```python\nnums = [0, 1, 2, 3, 4, 5]\n\nprint(nums[1:4])    # [1, 2, 3]\nprint(nums[:3])     # [0, 1, 2]\nprint(nums[3:])     # [3, 4, 5]\nprint(nums[::2])    # [0, 2, 4] (every 2nd)\nprint(nums[::-1])   # [5, 4, 3, 2, 1, 0] (reverse)\n```\n\n## List Copying\n```python\noriginal = [1, 2, 3]\n\n# Shallow copy\ncopy1 = original.copy()\ncopy2 = original[:]\ncopy3 = list(original)\n\n# Deep copy (for nested lists)\nimport copy\nnested = [[1, 2], [3, 4]]\ndeep = copy.deepcopy(nested)\n```\n"}, {"id": "Python_Theory/09_Lists_Tuples_Sets_Dicts/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "09 Lists Tuples Sets Dicts"], "content": "# Tuples, Sets, and Dictionaries\n\n## Tuples - Immutable Sequences\n```python\n# Creating tuples\ncoords = (10, 20)\nsingle = (1,)  # Note the comma for single-element tuple\n\n# Tuple unpacking\nx, y = coords\n\n# Tuples are immutable\n# coords[0] = 15  # TypeError\n```\n\n## Sets - Unique Elements\n```python\n# Creating sets\nnumbers = {1, 2, 3, 3, 4}  # {1, 2, 3, 4} (duplicates removed)\nempty_set = set()  # Note: {} creates a dict, not a set\n\n# Set operations\nset1 = {1, 2, 3}\nset2 = {3, 4, 5}\n\nunion = set1 | set2         # {1, 2, 3, 4, 5}\nintersection = set1 & set2  # {3}\ndifference = set1 - set2    # {1, 2}\n\n# Set methods\nset1.add(4)\nset1.remove(2)  # Raises KeyError if not found\nset1.discard(2) # No error if not found\n```\n\n## Dictionaries - Key-Value Pairs\n```python\n# Creating dictionaries\nperson = {\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"city\": \"New York\"\n}\n\n# Accessing values\nprint(person[\"name\"])        # \"Alice\"\nprint(person.get(\"age\"))     # 30\nprint(person.get(\"job\", \"Unknown\"))  # \"Unknown\" (default)\n\n# Adding/Updating\nperson[\"job\"] = \"Engineer\"\nperson.update({\"age\": 31, \"country\": \"USA\"})\n\n# Removing\ndel person[\"city\"]\nage = person.pop(\"age\")\n\n# Iterating\nfor key in person:\n    print(key, person[key])\n\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n```\n\n## Dictionary Methods\n```python\nd = {\"a\": 1, \"b\": 2}\n\nkeys = d.keys()      # dict_keys(['a', 'b'])\nvalues = d.values()  # dict_values([1, 2])\nitems = d.items()    # dict_items([('a', 1), ('b', 2)])\n```\n"}, {"id": "Python_Theory/09_Lists_Tuples_Sets_Dicts/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "09 Lists Tuples Sets Dicts"], "content": "# Common Operations and Syntax\n\n## List Comprehensions\n```python\n# Basic\nsquares = [x**2 for x in range(10)]\n\n# With condition\nevens = [x for x in range(10) if x % 2 == 0]\n\n# Nested\nmatrix = [[i*j for j in range(3)] for i in range(3)]\n```\n\n## Dictionary Comprehensions\n```python\n# Basic\nsquares_dict = {x: x**2 for x in range(5)}\n\n# From two lists\nkeys = ['a', 'b', 'c']\nvalues = [1, 2, 3]\nd = {k: v for k, v in zip(keys, values)}\n```\n\n## Set Comprehensions\n```python\nunique_squares = {x**2 for x in [1, 1, 2, 2, 3, 3]}\n```\n\n## Nested Structures\n```python\n# List of dictionaries\nstudents = [\n    {\"name\": \"Alice\", \"grade\": 90},\n    {\"name\": \"Bob\", \"grade\": 85}\n]\n\n# Dictionary of lists\ngrades = {\n    \"Alice\": [90, 85, 92],\n    \"Bob\": [88, 90, 87]\n}\n```\n\n## Common Patterns\n```python\n# Enumerate\nfor i, value in enumerate(['a', 'b', 'c']):\n    print(i, value)\n\n# Zip\nnames = ['Alice', 'Bob']\nages = [25, 30]\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age}\")\n\n# Sorted\nsorted_list = sorted([3, 1, 4, 1, 5])\nsorted_dict = sorted(d.items(), key=lambda x: x[1])\n```\n"}, {"id": "Python_Theory/09_Lists_Tuples_Sets_Dicts/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/05_Examples.md", "breadcrumbs": ["Python Theory", "09 Lists Tuples Sets Dicts"], "content": "# Data Structure Examples\n\n## Example 1: Shopping Cart (List)\n```python\ncart = []\ncart.append({\"item\": \"Apple\", \"price\": 1.50, \"qty\": 3})\ncart.append({\"item\": \"Banana\", \"price\": 0.75, \"qty\": 6})\n\ntotal = sum(item[\"price\"] * item[\"qty\"] for item in cart)\nprint(f\"Total: ${total:.2f}\")\n```\n\n## Example 2: Phone Book (Dictionary)\n```python\nphonebook = {\n    \"Alice\": \"555-1234\",\n    \"Bob\": \"555-5678\"\n}\n\n# Add contact\nphonebook[\"Charlie\"] = \"555-9012\"\n\n# Lookup\nprint(phonebook.get(\"Alice\", \"Not found\"))\n```\n\n## Example 3: Remove Duplicates (Set)\n```python\nnumbers = [1, 2, 2, 3, 4, 4, 5]\nunique = list(set(numbers))\nprint(unique)  # [1, 2, 3, 4, 5]\n```\n\n## Example 4: Word Frequency (Dictionary)\n```python\ntext = \"the quick brown fox jumps over the lazy dog\"\nwords = text.split()\n\nfreq = {}\nfor word in words:\n    freq[word] = freq.get(word, 0) + 1\n\nprint(freq)  # {'the': 2, 'quick': 1, ...}\n```\n\n## Example 5: Matrix Operations (Nested Lists)\n```python\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Transpose\ntransposed = [[row[i] for row in matrix] for i in range(3)]\n```\n"}, {"id": "Python_Theory/09_Lists_Tuples_Sets_Dicts/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "09 Lists Tuples Sets Dicts"], "content": "# Common Data Structure Errors\n\n## 1. List Index Out of Range\n```python\nlst = [1, 2, 3]\n# print(lst[5])  # IndexError\n\n# CORRECT\nif len(lst) > 5:\n    print(lst[5])\n```\n\n## 2. KeyError in Dictionary\n```python\nd = {\"a\": 1}\n# print(d[\"b\"])  # KeyError\n\n# CORRECT\nprint(d.get(\"b\", \"Not found\"))\n```\n\n## 3. Modifying List While Iterating\n```python\n# WRONG\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    if num % 2 == 0:\n        numbers.remove(num)  # Skips elements!\n\n# CORRECT\nnumbers = [num for num in numbers if num % 2 != 0]\n```\n\n## 4. Mutable Default Arguments\n```python\n# WRONG\ndef add_item(item, lst=[]):\n    lst.append(item)\n    return lst\n\n# CORRECT\ndef add_item(item, lst=None):\n    if lst is None:\n        lst = []\n    lst.append(item)\n    return lst\n```\n\n## 5. Shallow vs Deep Copy\n```python\noriginal = [[1, 2], [3, 4]]\nshallow = original.copy()\nshallow[0][0] = 999  # Modifies original too!\n\n# CORRECT - Use deep copy\nimport copy\ndeep = copy.deepcopy(original)\n```\n"}, {"id": "Python_Theory/09_Lists_Tuples_Sets_Dicts/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/09_Lists_Tuples_Sets_Dicts/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "09 Lists Tuples Sets Dicts"], "content": "# Practice Questions - Data Structures\n\n## Questions\n\n### Q1: Merge Two Lists\nMerge two sorted lists into one sorted list.\n\n### Q2: Find Common Elements\nFind common elements between two lists.\n\n### Q3: Group Anagrams\nGroup words that are anagrams of each other.\n\n### Q4: Two Sum Problem\nFind two numbers in a list that add up to a target.\n\n### Q5: Nested Dictionary Access\nAccess a deeply nested value safely.\n\n---\n\n## Solutions\n\n### A1: Merge Sorted Lists\n```python\ndef merge_sorted(list1, list2):\n    return sorted(list1 + list2)\n\n# OR using merge algorithm\ndef merge(l1, l2):\n    result = []\n    i = j = 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] < l2[j]:\n            result.append(l1[i])\n            i += 1\n        else:\n            result.append(l2[j])\n            j += 1\n    result.extend(l1[i:])\n    result.extend(l2[j:])\n    return result\n```\n\n### A2: Common Elements\n```python\ndef find_common(list1, list2):\n    return list(set(list1) & set(list2))\n\nprint(find_common([1, 2, 3], [2, 3, 4]))  # [2, 3]\n```\n\n### A3: Group Anagrams\n```python\ndef group_anagrams(words):\n    groups = {}\n    for word in words:\n        key = ''.join(sorted(word))\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(word)\n    return list(groups.values())\n\nwords = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(group_anagrams(words))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n```\n\n### A4: Two Sum\n```python\ndef two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return None\n\nprint(two_sum([2, 7, 11, 15], 9))  # [0, 1]\n```\n\n### A5: Safe Nested Access\n```python\ndef safe_get(d, *keys):\n    for key in keys:\n        if isinstance(d, dict):\n            d = d.get(key)\n        else:\n            return None\n    return d\n\ndata = {\"a\": {\"b\": {\"c\": 123}}}\nprint(safe_get(data, \"a\", \"b\", \"c\"))  # 123\nprint(safe_get(data, \"a\", \"x\", \"c\"))  # None\n```\n"}, {"id": "Python_Theory/10_OOP_in_Python/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/10_OOP_in_Python/01_Definition.md", "breadcrumbs": ["Python Theory", "10 OOP in Python"], "content": "# Object-Oriented Programming (OOP) in Python\n\n## Definition\n\n**OOP** is a programming paradigm based on the concept of \"objects\" which contain data (attributes) and code (methods).\n\n## Core Concepts\n\n### 1. Class\nA blueprint for creating objects.\n\n### 2. Object\nAn instance of a class.\n\n### 3. The Four Pillars of OOP\n\n#### Encapsulation\nBundling data and methods that operate on that data within a single unit (class).\n\n#### Inheritance\nCreating new classes from existing ones, inheriting attributes and methods.\n\n#### Polymorphism\nThe ability to use a common interface for multiple forms (data types).\n\n#### Abstraction\nHiding complex implementation details and showing only necessary features.\n\n## Basic Class Syntax\n```python\nclass Dog:\n    # Class attribute\n    species = \"Canis familiaris\"\n    \n    # Constructor\n    def __init__(self, name, age):\n        # Instance attributes\n        self.name = name\n        self.age = age\n    \n    # Instance method\n    def bark(self):\n        return f\"{self.name} says Woof!\"\n\n# Creating objects\ndog1 = Dog(\"Buddy\", 3)\ndog2 = Dog(\"Lucy\", 5)\n\nprint(dog1.bark())  # \"Buddy says Woof!\"\n```\n"}, {"id": "Python_Theory/10_OOP_in_Python/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/10_OOP_in_Python/02_Theory.md", "breadcrumbs": ["Python Theory", "10 OOP in Python"], "content": "# OOP Theory - Inheritance and Polymorphism\n\n## Inheritance\n\n### Single Inheritance\n```python\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} barks\"\n\nclass Cat(Animal):\n    def speak(self):\n        return f\"{self.name} meows\"\n\ndog = Dog(\"Buddy\")\nprint(dog.speak())  # \"Buddy barks\"\n```\n\n### Multiple Inheritance\n```python\nclass Flyer:\n    def fly(self):\n        return \"Flying\"\n\nclass Swimmer:\n    def swim(self):\n        return \"Swimming\"\n\nclass Duck(Flyer, Swimmer):\n    pass\n\nduck = Duck()\nprint(duck.fly())   # \"Flying\"\nprint(duck.swim())  # \"Swimming\"\n```\n\n### Method Resolution Order (MRO)\n```python\nclass A:\n    def method(self):\n        print(\"A\")\n\nclass B(A):\n    def method(self):\n        print(\"B\")\n\nclass C(A):\n    def method(self):\n        print(\"C\")\n\nclass D(B, C):\n    pass\n\nd = D()\nd.method()  # \"B\" (follows MRO: D -> B -> C -> A)\nprint(D.mro())  # Shows resolution order\n```\n\n## Polymorphism\n\n### Method Overriding\n```python\nclass Shape:\n    def area(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14 * self.radius ** 2\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\n# Polymorphism in action\nshapes = [Circle(5), Rectangle(4, 6)]\nfor shape in shapes:\n    print(shape.area())\n```\n\n## `super()` Function\n```python\nclass Parent:\n    def __init__(self, name):\n        self.name = name\n\nclass Child(Parent):\n    def __init__(self, name, age):\n        super().__init__(name)  # Call parent constructor\n        self.age = age\n```\n"}, {"id": "Python_Theory/10_OOP_in_Python/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/10_OOP_in_Python/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "10 OOP in Python"], "content": "# Encapsulation and Special Methods\n\n## Encapsulation\n\n### Private Attributes (Name Mangling)\n```python\nclass BankAccount:\n    def __init__(self, balance):\n        self.__balance = balance  # Private attribute\n    \n    def deposit(self, amount):\n        if amount > 0:\n            self.__balance += amount\n    \n    def get_balance(self):\n        return self.__balance\n\naccount = BankAccount(1000)\n# print(account.__balance)  # AttributeError\nprint(account.get_balance())  # 1000\n```\n\n### Property Decorators\n```python\nclass Person:\n    def __init__(self, name):\n        self._name = name\n    \n    @property\n    def name(self):\n        return self._name\n    \n    @name.setter\n    def name(self, value):\n        if not value:\n            raise ValueError(\"Name cannot be empty\")\n        self._name = value\n\np = Person(\"Alice\")\nprint(p.name)  # Uses getter\np.name = \"Bob\"  # Uses setter\n```\n\n## Special Methods (Dunder Methods)\n\n### String Representation\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __str__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    def __repr__(self):\n        return f\"Point(x={self.x}, y={self.y})\"\n\np = Point(3, 4)\nprint(p)  # Uses __str__\n```\n\n### Operator Overloading\n```python\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\nv1 = Vector(1, 2)\nv2 = Vector(3, 4)\nv3 = v1 + v2  # Uses __add__\n```\n\n### Container Methods\n```python\nclass MyList:\n    def __init__(self):\n        self.items = []\n    \n    def __len__(self):\n        return len(self.items)\n    \n    def __getitem__(self, index):\n        return self.items[index]\n    \n    def __setitem__(self, index, value):\n        self.items[index] = value\n```\n"}, {"id": "Python_Theory/10_OOP_in_Python/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/10_OOP_in_Python/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "10 OOP in Python"], "content": "# Class Methods, Static Methods, and Abstract Classes\n\n## Class Methods\n```python\nclass Date:\n    def __init__(self, year, month, day):\n        self.year = year\n        self.month = month\n        self.day = day\n    \n    @classmethod\n    def from_string(cls, date_string):\n        year, month, day = map(int, date_string.split('-'))\n        return cls(year, month, day)\n\nd = Date.from_string(\"2024-12-09\")\n```\n\n## Static Methods\n```python\nclass Math:\n    @staticmethod\n    def add(x, y):\n        return x + y\n\nresult = Math.add(5, 3)  # No instance needed\n```\n\n## Abstract Base Classes\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14 * self.radius ** 2\n    \n    def perimeter(self):\n        return 2 * 3.14 * self.radius\n\n# shape = Shape()  # TypeError: Can't instantiate abstract class\ncircle = Circle(5)  # OK\n```\n\n## Dataclasses (Python 3.7+)\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n    \n    def distance_from_origin(self):\n        return (self.x**2 + self.y**2)**0.5\n\np = Point(3, 4)\nprint(p)  # Point(x=3, y=4)\n```\n"}, {"id": "Python_Theory/10_OOP_in_Python/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/10_OOP_in_Python/05_Examples.md", "breadcrumbs": ["Python Theory", "10 OOP in Python"], "content": "# OOP Examples\n\n## Example 1: Library Management System\n```python\nclass Book:\n    def __init__(self, title, author, isbn):\n        self.title = title\n        self.author = author\n        self.isbn = isbn\n        self.is_borrowed = False\n    \n    def borrow(self):\n        if not self.is_borrowed:\n            self.is_borrowed = True\n            return True\n        return False\n    \n    def return_book(self):\n        self.is_borrowed = False\n\nclass Library:\n    def __init__(self):\n        self.books = []\n    \n    def add_book(self, book):\n        self.books.append(book)\n    \n    def find_book(self, isbn):\n        for book in self.books:\n            if book.isbn == isbn:\n                return book\n        return None\n\n# Usage\nlib = Library()\nbook1 = Book(\"Python 101\", \"John Doe\", \"123\")\nlib.add_book(book1)\nbook1.borrow()\n```\n\n## Example 2: Employee Management\n```python\nclass Employee:\n    def __init__(self, name, salary):\n        self.name = name\n        self.salary = salary\n    \n    def give_raise(self, amount):\n        self.salary += amount\n\nclass Manager(Employee):\n    def __init__(self, name, salary, department):\n        super().__init__(name, salary)\n        self.department = department\n        self.team = []\n    \n    def add_team_member(self, employee):\n        self.team.append(employee)\n\nmanager = Manager(\"Alice\", 100000, \"Engineering\")\nemp1 = Employee(\"Bob\", 70000)\nmanager.add_team_member(emp1)\n```\n\n## Example 3: Game Character System\n```python\nclass Character:\n    def __init__(self, name, health):\n        self.name = name\n        self.health = health\n    \n    def take_damage(self, damage):\n        self.health -= damage\n        if self.health < 0:\n            self.health = 0\n    \n    def is_alive(self):\n        return self.health > 0\n\nclass Warrior(Character):\n    def __init__(self, name):\n        super().__init__(name, health=150)\n        self.armor = 20\n    \n    def take_damage(self, damage):\n        reduced_damage = max(0, damage - self.armor)\n        super().take_damage(reduced_damage)\n\nwarrior = Warrior(\"Conan\")\nwarrior.take_damage(30)  # Takes 10 damage (30 - 20 armor)\n```\n"}, {"id": "Python_Theory/10_OOP_in_Python/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/10_OOP_in_Python/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "10 OOP in Python"], "content": "# Common OOP Errors\n\n## 1. Forgetting `self`\n```python\n# WRONG\nclass Dog:\n    def bark():  # Missing self\n        print(\"Woof\")\n\n# CORRECT\nclass Dog:\n    def bark(self):\n        print(\"Woof\")\n```\n\n## 2. Not Calling Parent Constructor\n```python\n# WRONG\nclass Child(Parent):\n    def __init__(self, name, age):\n        self.age = age  # Parent's __init__ not called!\n\n# CORRECT\nclass Child(Parent):\n    def __init__(self, name, age):\n        super().__init__(name)\n        self.age = age\n```\n\n## 3. Mutable Class Attributes\n```python\n# WRONG\nclass MyClass:\n    items = []  # Shared across all instances!\n    \n    def add_item(self, item):\n        self.items.append(item)\n\n# CORRECT\nclass MyClass:\n    def __init__(self):\n        self.items = []  # Instance attribute\n```\n\n## 4. Circular Imports\n```python\n# file_a.py\nfrom file_b import ClassB\nclass ClassA:\n    pass\n\n# file_b.py\nfrom file_a import ClassA  # Circular!\nclass ClassB:\n    pass\n\n# SOLUTION: Use local imports or restructure\n```\n\n## 5. Modifying Immutable Objects\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def move(self, dx, dy):\n        # If Point should be immutable, return new instance\n        return Point(self.x + dx, self.y + dy)\n```\n"}, {"id": "Python_Theory/10_OOP_in_Python/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/10_OOP_in_Python/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "10 OOP in Python"], "content": "# Practice Questions - OOP\n\n## Questions\n\n### Q1: Create a Rectangle Class\nCreate a `Rectangle` class with width and height. Add methods for area and perimeter.\n\n### Q2: Implement a Stack\nCreate a `Stack` class with push, pop, and is_empty methods.\n\n### Q3: Bank Account with Inheritance\nCreate `SavingsAccount` and `CheckingAccount` classes inheriting from `BankAccount`.\n\n### Q4: Implement `__str__` and `__repr__`\nCreate a `Book` class with proper string representations.\n\n### Q5: Abstract Shape Class\nCreate an abstract `Shape` class and concrete `Circle` and `Square` classes.\n\n---\n\n## Solutions\n\n### A1: Rectangle Class\n```python\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nrect = Rectangle(5, 3)\nprint(rect.area())       # 15\nprint(rect.perimeter())  # 16\n```\n\n### A2: Stack Implementation\n```python\nclass Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        raise IndexError(\"Pop from empty stack\")\n    \n    def is_empty(self):\n        return len(self.items) == 0\n    \n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n        return None\n\nstack = Stack()\nstack.push(1)\nstack.push(2)\nprint(stack.pop())  # 2\n```\n\n### A3: Bank Account Inheritance\n```python\nclass BankAccount:\n    def __init__(self, balance=0):\n        self._balance = balance\n    \n    def deposit(self, amount):\n        self._balance += amount\n    \n    def get_balance(self):\n        return self._balance\n\nclass SavingsAccount(BankAccount):\n    def __init__(self, balance=0, interest_rate=0.02):\n        super().__init__(balance)\n        self.interest_rate = interest_rate\n    \n    def add_interest(self):\n        self._balance += self._balance * self.interest_rate\n\nclass CheckingAccount(BankAccount):\n    def __init__(self, balance=0, overdraft_limit=100):\n        super().__init__(balance)\n        self.overdraft_limit = overdraft_limit\n    \n    def withdraw(self, amount):\n        if self._balance - amount >= -self.overdraft_limit:\n            self._balance -= amount\n            return True\n        return False\n```\n\n### A4: String Representations\n```python\nclass Book:\n    def __init__(self, title, author, year):\n        self.title = title\n        self.author = author\n        self.year = year\n    \n    def __str__(self):\n        return f'\"{self.title}\" by {self.author}'\n    \n    def __repr__(self):\n        return f\"Book('{self.title}', '{self.author}', {self.year})\"\n\nbook = Book(\"1984\", \"George Orwell\", 1949)\nprint(str(book))   # \"1984\" by George Orwell\nprint(repr(book))  # Book('1984', 'George Orwell', 1949)\n```\n\n### A5: Abstract Shape\n```python\nfrom abc import ABC, abstractmethod\nimport math\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return math.pi * self.radius ** 2\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    \n    def area(self):\n        return self.side ** 2\n\nshapes = [Circle(5), Square(4)]\nfor shape in shapes:\n    print(f\"Area: {shape.area():.2f}\")\n```\n"}, {"id": "Python_Theory/11_Error_and_Exception_Handling/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/11_Error_and_Exception_Handling/01_Definition.md", "breadcrumbs": ["Python Theory", "11 Error and Exception Handling"], "content": "# Error and Exception Handling\n\n## Definition\n\n**Exceptions** are events that disrupt the normal flow of a program. **Exception handling** allows you to gracefully handle errors instead of crashing.\n\n## Exception Hierarchy\n```\nBaseException\n\u251c\u2500\u2500 SystemExit\n\u251c\u2500\u2500 KeyboardInterrupt\n\u2514\u2500\u2500 Exception\n    \u251c\u2500\u2500 ArithmeticError\n    \u2502   \u251c\u2500\u2500 ZeroDivisionError\n    \u2502   \u2514\u2500\u2500 OverflowError\n    \u251c\u2500\u2500 LookupError\n    \u2502   \u251c\u2500\u2500 IndexError\n    \u2502   \u2514\u2500\u2500 KeyError\n    \u251c\u2500\u2500 TypeError\n    \u251c\u2500\u2500 ValueError\n    \u251c\u2500\u2500 NameError\n    \u2514\u2500\u2500 ... (many more)\n```\n\n## Basic Try-Except\n```python\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n```\n\n## Multiple Exceptions\n```python\ntry:\n    value = int(input(\"Enter number: \"))\n    result = 10 / value\nexcept ValueError:\n    print(\"Invalid input!\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n```\n\n## Catching Multiple Exceptions\n```python\ntry:\n    # code\n    pass\nexcept (ValueError, TypeError) as e:\n    print(f\"Error: {e}\")\n```\n\n## The `else` Clause\n```python\ntry:\n    result = 10 / 2\nexcept ZeroDivisionError:\n    print(\"Error!\")\nelse:\n    print(f\"Result: {result}\")  # Runs if no exception\n```\n\n## The `finally` Clause\n```python\ntry:\n    file = open(\"data.txt\")\n    # process file\nexcept FileNotFoundError:\n    print(\"File not found\")\nfinally:\n    # Always executes\n    print(\"Cleanup code\")\n```\n"}, {"id": "Python_Theory/11_Error_and_Exception_Handling/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/11_Error_and_Exception_Handling/02_Theory.md", "breadcrumbs": ["Python Theory", "11 Error and Exception Handling"], "content": "# Raising and Custom Exceptions\n\n## Raising Exceptions\n```python\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Divisor cannot be zero\")\n    return a / b\n\ntry:\n    divide(10, 0)\nexcept ValueError as e:\n    print(e)\n```\n\n## Custom Exceptions\n```python\nclass InsufficientFundsError(Exception):\n    \"\"\"Raised when withdrawal exceeds balance\"\"\"\n    pass\n\nclass BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n    \n    def withdraw(self, amount):\n        if amount > self.balance:\n            raise InsufficientFundsError(\n                f\"Cannot withdraw {amount}, balance is {self.balance}\"\n            )\n        self.balance -= amount\n\naccount = BankAccount(100)\ntry:\n    account.withdraw(150)\nexcept InsufficientFundsError as e:\n    print(e)\n```\n\n## Re-raising Exceptions\n```python\ntry:\n    # some code\n    pass\nexcept ValueError as e:\n    print(\"Logging error...\")\n    raise  # Re-raise the same exception\n```\n\n## Exception Chaining\n```python\ntry:\n    # code\n    pass\nexcept ValueError as e:\n    raise TypeError(\"Type error occurred\") from e\n```\n"}, {"id": "Python_Theory/11_Error_and_Exception_Handling/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/11_Error_and_Exception_Handling/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "11 Error and Exception Handling"], "content": "# Exception Handling Best Practices\n\n## 1. Be Specific\n```python\n# BAD\ntry:\n    # code\n    pass\nexcept:  # Catches everything, even KeyboardInterrupt!\n    pass\n\n# GOOD\ntry:\n    # code\n    pass\nexcept ValueError:\n    pass\n```\n\n## 2. Use Context Managers\n```python\n# Automatically handles cleanup\nwith open(\"file.txt\") as f:\n    content = f.read()\n# File is automatically closed\n```\n\n## 3. Don't Silence Exceptions\n```python\n# BAD\ntry:\n    risky_operation()\nexcept:\n    pass  # Silent failure!\n\n# GOOD\ntry:\n    risky_operation()\nexcept Exception as e:\n    logger.error(f\"Operation failed: {e}\")\n    raise\n```\n\n## 4. EAFP vs LBYL\n\n### EAFP (Easier to Ask Forgiveness than Permission)\n```python\n# Pythonic\ntry:\n    value = my_dict[key]\nexcept KeyError:\n    value = default\n```\n\n### LBYL (Look Before You Leap)\n```python\n# Less Pythonic\nif key in my_dict:\n    value = my_dict[key]\nelse:\n    value = default\n```\n"}, {"id": "Python_Theory/11_Error_and_Exception_Handling/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/11_Error_and_Exception_Handling/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "11 Error and Exception Handling"], "content": "# Exception Handling Syntax\n\n## Complete Try-Except-Else-Finally\n```python\ntry:\n    # Code that might raise an exception\n    result = risky_operation()\nexcept SpecificError as e:\n    # Handle specific error\n    print(f\"Error: {e}\")\nexcept AnotherError:\n    # Handle another error\n    pass\nelse:\n    # Runs if NO exception occurred\n    print(\"Success!\")\nfinally:\n    # ALWAYS runs\n    cleanup()\n```\n\n## Assertion\n```python\ndef calculate_average(numbers):\n    assert len(numbers) > 0, \"List cannot be empty\"\n    return sum(numbers) / len(numbers)\n\n# Raises AssertionError if condition is False\n```\n\n## Context Manager Protocol\n```python\nclass FileManager:\n    def __init__(self, filename):\n        self.filename = filename\n    \n    def __enter__(self):\n        self.file = open(self.filename, 'r')\n        return self.file\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.file.close()\n        return False  # Don't suppress exceptions\n\nwith FileManager(\"data.txt\") as f:\n    content = f.read()\n```\n"}, {"id": "Python_Theory/11_Error_and_Exception_Handling/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/11_Error_and_Exception_Handling/05_Examples.md", "breadcrumbs": ["Python Theory", "11 Error and Exception Handling"], "content": "# Exception Handling Examples\n\n## Example 1: File Processing with Error Handling\n```python\ndef read_config(filename):\n    try:\n        with open(filename, 'r') as f:\n            return f.read()\n    except FileNotFoundError:\n        print(f\"Config file {filename} not found, using defaults\")\n        return \"{}\"\n    except PermissionError:\n        print(f\"No permission to read {filename}\")\n        return None\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        raise\n\nconfig = read_config(\"config.json\")\n```\n\n## Example 2: Input Validation\n```python\ndef get_positive_number():\n    while True:\n        try:\n            value = int(input(\"Enter a positive number: \"))\n            if value <= 0:\n                raise ValueError(\"Number must be positive\")\n            return value\n        except ValueError as e:\n            print(f\"Invalid input: {e}. Try again.\")\n\nnumber = get_positive_number()\n```\n\n## Example 3: API Request with Retry\n```python\nimport time\n\ndef fetch_data(url, max_retries=3):\n    for attempt in range(max_retries):\n        try:\n            # Simulated API call\n            response = make_request(url)\n            return response\n        except ConnectionError:\n            if attempt < max_retries - 1:\n                time.sleep(2 ** attempt)  # Exponential backoff\n                continue\n            else:\n                raise\n```\n"}, {"id": "Python_Theory/11_Error_and_Exception_Handling/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/11_Error_and_Exception_Handling/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "11 Error and Exception Handling"], "content": "# Common Exception Handling Errors\n\n## 1. Catching Too Broad\n```python\n# WRONG\ntry:\n    value = int(input())\nexcept:  # Catches KeyboardInterrupt, SystemExit, etc.\n    pass\n\n# CORRECT\ntry:\n    value = int(input())\nexcept ValueError:\n    pass\n```\n\n## 2. Empty Except Block\n```python\n# WRONG\ntry:\n    risky_code()\nexcept Exception:\n    pass  # Silently fails!\n\n# CORRECT\ntry:\n    risky_code()\nexcept Exception as e:\n    logger.error(f\"Error: {e}\")\n```\n\n## 3. Not Using Finally for Cleanup\n```python\n# WRONG\nfile = open(\"data.txt\")\ntry:\n    process(file)\nexcept:\n    pass\nfile.close()  # Might not execute if exception occurs!\n\n# CORRECT\nfile = open(\"data.txt\")\ntry:\n    process(file)\nfinally:\n    file.close()  # Always executes\n\n# BETTER\nwith open(\"data.txt\") as file:\n    process(file)\n```\n\n## 4. Raising Wrong Exception Type\n```python\n# WRONG\ndef divide(a, b):\n    if b == 0:\n        raise Exception(\"Division by zero\")  # Too generic\n\n# CORRECT\ndef divide(a, b):\n    if b == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n```\n"}, {"id": "Python_Theory/11_Error_and_Exception_Handling/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/11_Error_and_Exception_Handling/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "11 Error and Exception Handling"], "content": "# Practice Questions - Exception Handling\n\n## Questions\n\n### Q1: Safe Division\nWrite a function that safely divides two numbers, handling all possible errors.\n\n### Q2: File Reader\nCreate a function that reads a file and returns its content, with proper error handling.\n\n### Q3: Custom Exception\nCreate a custom `AgeError` exception and use it in an age validation function.\n\n### Q4: Retry Decorator\nWrite a decorator that retries a function up to 3 times if it raises an exception.\n\n### Q5: Context Manager\nImplement a context manager for a database connection.\n\n---\n\n## Solutions\n\n### A1: Safe Division\n```python\ndef safe_divide(a, b):\n    try:\n        return a / b\n    except ZeroDivisionError:\n        return \"Error: Division by zero\"\n    except TypeError:\n        return \"Error: Invalid types\"\n    except Exception as e:\n        return f\"Unexpected error: {e}\"\n\nprint(safe_divide(10, 2))   # 5.0\nprint(safe_divide(10, 0))   # Error: Division by zero\nprint(safe_divide(10, \"a\")) # Error: Invalid types\n```\n\n### A2: File Reader\n```python\ndef read_file_safe(filename):\n    try:\n        with open(filename, 'r') as f:\n            return f.read()\n    except FileNotFoundError:\n        return f\"Error: File '{filename}' not found\"\n    except PermissionError:\n        return f\"Error: No permission to read '{filename}'\"\n    except Exception as e:\n        return f\"Error reading file: {e}\"\n\ncontent = read_file_safe(\"data.txt\")\n```\n\n### A3: Custom Exception\n```python\nclass AgeError(Exception):\n    \"\"\"Raised when age is invalid\"\"\"\n    pass\n\ndef validate_age(age):\n    if not isinstance(age, int):\n        raise TypeError(\"Age must be an integer\")\n    if age < 0:\n        raise AgeError(\"Age cannot be negative\")\n    if age > 150:\n        raise AgeError(\"Age seems unrealistic\")\n    return True\n\ntry:\n    validate_age(-5)\nexcept AgeError as e:\n    print(f\"Invalid age: {e}\")\n```\n\n### A4: Retry Decorator\n```python\nimport time\n\ndef retry(max_attempts=3, delay=1):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_attempts - 1:\n                        raise\n                    print(f\"Attempt {attempt + 1} failed: {e}\")\n                    time.sleep(delay)\n        return wrapper\n    return decorator\n\n@retry(max_attempts=3)\ndef unreliable_function():\n    import random\n    if random.random() < 0.7:\n        raise ConnectionError(\"Failed\")\n    return \"Success\"\n```\n\n### A5: Context Manager\n```python\nclass DatabaseConnection:\n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.connection = None\n    \n    def __enter__(self):\n        print(f\"Connecting to {self.db_name}\")\n        self.connection = f\"Connection to {self.db_name}\"\n        return self.connection\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(f\"Closing connection to {self.db_name}\")\n        if exc_type is not None:\n            print(f\"Exception occurred: {exc_val}\")\n        return False  # Don't suppress exceptions\n\nwith DatabaseConnection(\"mydb\") as conn:\n    print(f\"Using {conn}\")\n```\n"}, {"id": "Python_Theory/12_File_Handling/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/12_File_Handling/01_Definition.md", "breadcrumbs": ["Python Theory", "12 File Handling"], "content": "# File Handling in Python\n\n## Definition\n\n**File handling** allows programs to create, read, update, and delete files. Python provides built-in functions for working with files.\n\n## File Modes\n\n| Mode | Description |\n|------|-------------|\n| `'r'` | Read (default) - Error if file doesn't exist |\n| `'w'` | Write - Creates new file or overwrites existing |\n| `'a'` | Append - Creates new file or appends to existing |\n| `'x'` | Exclusive creation - Error if file exists |\n| `'r+'` | Read and write |\n| `'b'` | Binary mode (e.g., `'rb'`, `'wb'`) |\n| `'t'` | Text mode (default) |\n\n## Basic File Operations\n\n### Opening and Closing\n```python\n# Manual close\nfile = open(\"data.txt\", \"r\")\ncontent = file.read()\nfile.close()\n\n# Using with statement (RECOMMENDED)\nwith open(\"data.txt\", \"r\") as file:\n    content = file.read()\n# File automatically closed\n```\n\n## File Object Methods\n\n### Reading\n```python\nwith open(\"data.txt\", \"r\") as f:\n    content = f.read()        # Read entire file\n    line = f.readline()       # Read one line\n    lines = f.readlines()     # Read all lines into list\n```\n\n### Writing\n```python\nwith open(\"output.txt\", \"w\") as f:\n    f.write(\"Hello, World!\\n\")\n    f.writelines([\"Line 1\\n\", \"Line 2\\n\"])\n```\n\n### Appending\n```python\nwith open(\"log.txt\", \"a\") as f:\n    f.write(\"New log entry\\n\")\n```\n"}, {"id": "Python_Theory/12_File_Handling/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/12_File_Handling/02_Theory.md", "breadcrumbs": ["Python Theory", "12 File Handling"], "content": "# File Paths and Directory Operations\n\n## Working with Paths\n\n### Using `os.path`\n```python\nimport os\n\n# Join paths\npath = os.path.join(\"folder\", \"subfolder\", \"file.txt\")\n\n# Get absolute path\nabs_path = os.path.abspath(\"file.txt\")\n\n# Check if exists\nexists = os.path.exists(\"file.txt\")\nis_file = os.path.isfile(\"file.txt\")\nis_dir = os.path.isdir(\"folder\")\n\n# Get file info\nsize = os.path.getsize(\"file.txt\")\nbasename = os.path.basename(\"/path/to/file.txt\")  # \"file.txt\"\ndirname = os.path.dirname(\"/path/to/file.txt\")    # \"/path/to\"\n```\n\n### Using `pathlib` (Modern Approach)\n```python\nfrom pathlib import Path\n\n# Create path object\npath = Path(\"folder\") / \"subfolder\" / \"file.txt\"\n\n# Check existence\nif path.exists():\n    print(\"File exists\")\n\n# Read/write\ncontent = path.read_text()\npath.write_text(\"Hello\")\n\n# Get parts\nprint(path.name)      # \"file.txt\"\nprint(path.stem)      # \"file\"\nprint(path.suffix)    # \".txt\"\nprint(path.parent)    # \"folder/subfolder\"\n```\n\n## Directory Operations\n```python\nimport os\n\n# Create directory\nos.mkdir(\"new_folder\")\nos.makedirs(\"path/to/folder\", exist_ok=True)  # Create nested\n\n# List directory\nfiles = os.listdir(\".\")\n\n# Walk directory tree\nfor root, dirs, files in os.walk(\".\"):\n    for file in files:\n        print(os.path.join(root, file))\n\n# Remove\nos.remove(\"file.txt\")      # Delete file\nos.rmdir(\"folder\")         # Delete empty directory\nimport shutil\nshutil.rmtree(\"folder\")    # Delete directory and contents\n```\n"}, {"id": "Python_Theory/12_File_Handling/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/12_File_Handling/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "12 File Handling"], "content": "# Binary Files and Special Formats\n\n## Binary Files\n```python\n# Read binary\nwith open(\"image.png\", \"rb\") as f:\n    data = f.read()\n\n# Write binary\nwith open(\"output.bin\", \"wb\") as f:\n    f.write(bytes([0, 1, 2, 3]))\n```\n\n## CSV Files\n```python\nimport csv\n\n# Write CSV\nwith open(\"data.csv\", \"w\", newline='') as f:\n    writer = csv.writer(f)\n    writer.writerow([\"Name\", \"Age\"])\n    writer.writerow([\"Alice\", 30])\n\n# Read CSV\nwith open(\"data.csv\", \"r\") as f:\n    reader = csv.reader(f)\n    for row in reader:\n        print(row)\n\n# Using DictReader/DictWriter\nwith open(\"data.csv\", \"r\") as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        print(row[\"Name\"], row[\"Age\"])\n```\n\n## JSON Files\n```python\nimport json\n\n# Write JSON\ndata = {\"name\": \"Alice\", \"age\": 30}\nwith open(\"data.json\", \"w\") as f:\n    json.dump(data, f, indent=2)\n\n# Read JSON\nwith open(\"data.json\", \"r\") as f:\n    data = json.load(f)\n```\n\n## Pickle (Python Objects)\n```python\nimport pickle\n\n# Save object\ndata = {\"key\": \"value\", \"list\": [1, 2, 3]}\nwith open(\"data.pkl\", \"wb\") as f:\n    pickle.dump(data, f)\n\n# Load object\nwith open(\"data.pkl\", \"rb\") as f:\n    data = pickle.load(f)\n```\n"}, {"id": "Python_Theory/12_File_Handling/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/12_File_Handling/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "12 File Handling"], "content": "# File Handling Methods and Best Practices\n\n## File Object Methods\n```python\nwith open(\"file.txt\", \"r\") as f:\n    # Position\n    pos = f.tell()        # Get current position\n    f.seek(0)             # Move to beginning\n    f.seek(0, 2)          # Move to end\n    \n    # Reading\n    char = f.read(1)      # Read 1 character\n    line = f.readline()   # Read one line\n    \n    # Iteration\n    for line in f:\n        print(line.strip())\n```\n\n## Context Managers for Multiple Files\n```python\nwith open(\"input.txt\", \"r\") as infile, open(\"output.txt\", \"w\") as outfile:\n    for line in infile:\n        outfile.write(line.upper())\n```\n\n## Buffering\n```python\n# Unbuffered\nwith open(\"file.txt\", \"w\", buffering=0) as f:\n    f.write(b\"data\")\n\n# Line buffered\nwith open(\"file.txt\", \"w\", buffering=1) as f:\n    f.write(\"data\\n\")\n\n# Custom buffer size\nwith open(\"file.txt\", \"w\", buffering=8192) as f:\n    f.write(\"data\")\n```\n\n## File Locking (Platform-specific)\n```python\nimport fcntl  # Unix only\n\nwith open(\"file.txt\", \"w\") as f:\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)  # Exclusive lock\n    f.write(\"data\")\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)  # Unlock\n```\n"}, {"id": "Python_Theory/12_File_Handling/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/12_File_Handling/05_Examples.md", "breadcrumbs": ["Python Theory", "12 File Handling"], "content": "# File Handling Examples\n\n## Example 1: Log File Analyzer\n```python\ndef analyze_log(filename):\n    error_count = 0\n    warning_count = 0\n    \n    with open(filename, \"r\") as f:\n        for line in f:\n            if \"ERROR\" in line:\n                error_count += 1\n            elif \"WARNING\" in line:\n                warning_count += 1\n    \n    return {\"errors\": error_count, \"warnings\": warning_count}\n\nstats = analyze_log(\"app.log\")\nprint(f\"Errors: {stats['errors']}, Warnings: {stats['warnings']}\")\n```\n\n## Example 2: CSV to JSON Converter\n```python\nimport csv\nimport json\n\ndef csv_to_json(csv_file, json_file):\n    data = []\n    \n    with open(csv_file, \"r\") as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            data.append(row)\n    \n    with open(json_file, \"w\") as f:\n        json.dump(data, f, indent=2)\n\ncsv_to_json(\"data.csv\", \"data.json\")\n```\n\n## Example 3: File Backup\n```python\nimport shutil\nfrom datetime import datetime\n\ndef backup_file(filename):\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    backup_name = f\"{filename}.backup_{timestamp}\"\n    shutil.copy2(filename, backup_name)\n    return backup_name\n\nbackup = backup_file(\"important.txt\")\n```\n\n## Example 4: Word Frequency Counter\n```python\nfrom collections import Counter\n\ndef word_frequency(filename):\n    with open(filename, \"r\") as f:\n        words = f.read().lower().split()\n    \n    return Counter(words).most_common(10)\n\ntop_words = word_frequency(\"document.txt\")\nfor word, count in top_words:\n    print(f\"{word}: {count}\")\n```\n"}, {"id": "Python_Theory/12_File_Handling/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/12_File_Handling/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "12 File Handling"], "content": "# Common File Handling Errors\n\n## 1. FileNotFoundError\n```python\n# WRONG\nf = open(\"nonexistent.txt\", \"r\")\n\n# CORRECT\ntry:\n    with open(\"file.txt\", \"r\") as f:\n        content = f.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\n```\n\n## 2. Not Closing Files\n```python\n# WRONG\nf = open(\"file.txt\", \"r\")\ncontent = f.read()\n# File not closed!\n\n# CORRECT\nwith open(\"file.txt\", \"r\") as f:\n    content = f.read()\n# Automatically closed\n```\n\n## 3. Encoding Issues\n```python\n# WRONG\nwith open(\"file.txt\", \"r\") as f:  # Uses system default encoding\n    content = f.read()\n\n# CORRECT\nwith open(\"file.txt\", \"r\", encoding=\"utf-8\") as f:\n    content = f.read()\n```\n\n## 4. Writing to Read-Only File\n```python\n# WRONG\nwith open(\"file.txt\", \"r\") as f:\n    f.write(\"data\")  # io.UnsupportedOperation\n\n# CORRECT\nwith open(\"file.txt\", \"w\") as f:\n    f.write(\"data\")\n```\n\n## 5. Not Handling Permissions\n```python\n# WRONG\nwith open(\"/root/file.txt\", \"w\") as f:  # PermissionError\n    f.write(\"data\")\n\n# CORRECT\ntry:\n    with open(\"/root/file.txt\", \"w\") as f:\n        f.write(\"data\")\nexcept PermissionError:\n    print(\"No permission to write\")\n```\n"}, {"id": "Python_Theory/12_File_Handling/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/12_File_Handling/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "12 File Handling"], "content": "# Practice Questions - File Handling\n\n## Questions\n\n### Q1: File Copy\nWrite a function to copy a file from source to destination.\n\n### Q2: Line Counter\nCount the number of lines in a text file.\n\n### Q3: Find and Replace\nReplace all occurrences of a word in a file.\n\n### Q4: Merge Files\nMerge multiple text files into one.\n\n### Q5: CSV Filter\nFilter CSV rows based on a condition.\n\n---\n\n## Solutions\n\n### A1: File Copy\n```python\ndef copy_file(source, destination):\n    try:\n        with open(source, \"rb\") as src, open(destination, \"wb\") as dst:\n            dst.write(src.read())\n        return True\n    except FileNotFoundError:\n        return False\n\ncopy_file(\"input.txt\", \"output.txt\")\n```\n\n### A2: Line Counter\n```python\ndef count_lines(filename):\n    try:\n        with open(filename, \"r\") as f:\n            return sum(1 for line in f)\n    except FileNotFoundError:\n        return 0\n\nlines = count_lines(\"document.txt\")\nprint(f\"Lines: {lines}\")\n```\n\n### A3: Find and Replace\n```python\ndef find_replace(filename, old, new):\n    with open(filename, \"r\") as f:\n        content = f.read()\n    \n    content = content.replace(old, new)\n    \n    with open(filename, \"w\") as f:\n        f.write(content)\n\nfind_replace(\"file.txt\", \"old_word\", \"new_word\")\n```\n\n### A4: Merge Files\n```python\ndef merge_files(input_files, output_file):\n    with open(output_file, \"w\") as outfile:\n        for filename in input_files:\n            with open(filename, \"r\") as infile:\n                outfile.write(infile.read())\n                outfile.write(\"\\n\")\n\nmerge_files([\"file1.txt\", \"file2.txt\"], \"merged.txt\")\n```\n\n### A5: CSV Filter\n```python\nimport csv\n\ndef filter_csv(input_file, output_file, condition):\n    with open(input_file, \"r\") as infile, open(output_file, \"w\", newline='') as outfile:\n        reader = csv.DictReader(infile)\n        writer = csv.DictWriter(outfile, fieldnames=reader.fieldnames)\n        \n        writer.writeheader()\n        for row in reader:\n            if condition(row):\n                writer.writerow(row)\n\n# Filter rows where age > 25\nfilter_csv(\"people.csv\", \"filtered.csv\", lambda row: int(row[\"age\"]) > 25)\n```\n"}, {"id": "Python_Theory/13_Iterators_and_Generators/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/13_Iterators_and_Generators/01_Definition.md", "breadcrumbs": ["Python Theory", "13 Iterators and Generators"], "content": "# Iterators and Generators\n\n## Definition\n\n### Iterator\nAn object that implements the iterator protocol (`__iter__()` and `__next__()`). Allows sequential access to elements.\n\n### Generator\nA special type of iterator created using functions with `yield`. Generates values on-the-fly, saving memory.\n\n## Iterators\n\n### Creating an Iterator\n```python\nclass Counter:\n    def __init__(self, max):\n        self.max = max\n        self.current = 0\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.current < self.max:\n            self.current += 1\n            return self.current\n        raise StopIteration\n\ncounter = Counter(3)\nfor num in counter:\n    print(num)  # 1, 2, 3\n```\n\n### Built-in Iterators\n```python\n# Lists, tuples, strings are iterable\nfor char in \"hello\":\n    print(char)\n\n# iter() and next()\nit = iter([1, 2, 3])\nprint(next(it))  # 1\nprint(next(it))  # 2\n```\n\n## Generators\n\n### Generator Functions\n```python\ndef countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\n\nfor num in countdown(5):\n    print(num)  # 5, 4, 3, 2, 1\n```\n\n### Generator Expressions\n```python\n# Like list comprehension but with ()\nsquares = (x**2 for x in range(10))\nprint(next(squares))  # 0\nprint(next(squares))  # 1\n```\n\n## Benefits\n- **Memory Efficient**: Generate values on-demand\n- **Lazy Evaluation**: Compute only when needed\n- **Infinite Sequences**: Can represent infinite data\n"}, {"id": "Python_Theory/13_Iterators_and_Generators/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/13_Iterators_and_Generators/02_Theory.md", "breadcrumbs": ["Python Theory", "13 Iterators and Generators"], "content": "# Advanced Iterator and Generator Patterns\n\n## `itertools` Module\n```python\nimport itertools\n\n# Infinite iterators\ncount = itertools.count(start=10, step=2)  # 10, 12, 14, ...\ncycle = itertools.cycle([1, 2, 3])         # 1, 2, 3, 1, 2, 3, ...\nrepeat = itertools.repeat(5, times=3)      # 5, 5, 5\n\n# Combinatoric iterators\nperms = itertools.permutations([1, 2, 3])\ncombs = itertools.combinations([1, 2, 3], 2)\n\n# Grouping\ndata = [('a', 1), ('a', 2), ('b', 3)]\nfor key, group in itertools.groupby(data, key=lambda x: x[0]):\n    print(key, list(group))\n```\n\n## Generator Pipelines\n```python\ndef read_large_file(filename):\n    with open(filename) as f:\n        for line in f:\n            yield line.strip()\n\ndef filter_lines(lines, keyword):\n    for line in lines:\n        if keyword in line:\n            yield line\n\ndef process_lines(lines):\n    for line in lines:\n        yield line.upper()\n\n# Pipeline\nlines = read_large_file(\"huge.txt\")\nfiltered = filter_lines(lines, \"ERROR\")\nprocessed = process_lines(filtered)\n\nfor line in processed:\n    print(line)\n```\n\n## `yield from`\n```python\ndef flatten(nested_list):\n    for item in nested_list:\n        if isinstance(item, list):\n            yield from flatten(item)\n        else:\n            yield item\n\nnested = [1, [2, 3, [4, 5]], 6]\nprint(list(flatten(nested)))  # [1, 2, 3, 4, 5, 6]\n```\n\n## Generator Methods\n```python\ndef echo():\n    while True:\n        value = yield\n        print(f\"Received: {value}\")\n\ngen = echo()\nnext(gen)  # Prime the generator\ngen.send(\"Hello\")  # Send value\ngen.close()  # Close generator\n```\n"}, {"id": "Python_Theory/13_Iterators_and_Generators/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/13_Iterators_and_Generators/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "13 Iterators and Generators"], "content": "# Iterator and Generator Use Cases\n\n## Memory-Efficient Data Processing\n```python\n# BAD - Loads entire file into memory\ndef process_file_bad(filename):\n    with open(filename) as f:\n        lines = f.readlines()  # All lines in memory!\n    return [line.upper() for line in lines]\n\n# GOOD - Processes line by line\ndef process_file_good(filename):\n    with open(filename) as f:\n        for line in f:  # Generator!\n            yield line.upper()\n```\n\n## Infinite Sequences\n```python\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\n# Get first 10 Fibonacci numbers\nfib = fibonacci()\nfirst_10 = [next(fib) for _ in range(10)]\n```\n\n## Custom Range\n```python\ndef custom_range(start, stop, step):\n    current = start\n    while current < stop:\n        yield current\n        current += step\n\nfor num in custom_range(0, 10, 2):\n    print(num)  # 0, 2, 4, 6, 8\n```\n\n## Stateful Iteration\n```python\ndef moving_average(data, window_size):\n    window = []\n    for value in data:\n        window.append(value)\n        if len(window) > window_size:\n            window.pop(0)\n        yield sum(window) / len(window)\n\ndata = [1, 2, 3, 4, 5]\nfor avg in moving_average(data, 3):\n    print(f\"{avg:.2f}\")\n```\n"}, {"id": "Python_Theory/13_Iterators_and_Generators/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/13_Iterators_and_Generators/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "13 Iterators and Generators"], "content": "# Iterator and Generator Syntax\n\n## Iterator Protocol\n```python\nclass MyIterator:\n    def __init__(self, data):\n        self.data = data\n        self.index = 0\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.index >= len(self.data):\n            raise StopIteration\n        value = self.data[self.index]\n        self.index += 1\n        return value\n```\n\n## Generator Function Syntax\n```python\ndef my_generator():\n    yield 1\n    yield 2\n    yield 3\n\n# Equivalent to\ndef my_generator_alt():\n    return iter([1, 2, 3])\n```\n\n## Generator Expression Syntax\n```python\n# List comprehension (creates list)\nsquares_list = [x**2 for x in range(10)]\n\n# Generator expression (creates generator)\nsquares_gen = (x**2 for x in range(10))\n```\n\n## `yield` vs `return`\n```python\ndef with_return():\n    return [1, 2, 3]  # Returns entire list\n\ndef with_yield():\n    yield 1\n    yield 2\n    yield 3  # Returns generator object\n```\n\n## Generator Delegation\n```python\ndef sub_generator():\n    yield 1\n    yield 2\n\ndef main_generator():\n    yield from sub_generator()\n    yield 3\n\nlist(main_generator())  # [1, 2, 3]\n```\n"}, {"id": "Python_Theory/13_Iterators_and_Generators/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/13_Iterators_and_Generators/05_Examples.md", "breadcrumbs": ["Python Theory", "13 Iterators and Generators"], "content": "# Iterator and Generator Examples\n\n## Example 1: File Chunker\n```python\ndef read_in_chunks(filename, chunk_size=1024):\n    with open(filename, 'rb') as f:\n        while True:\n            chunk = f.read(chunk_size)\n            if not chunk:\n                break\n            yield chunk\n\nfor chunk in read_in_chunks(\"large_file.bin\"):\n    process(chunk)\n```\n\n## Example 2: Batch Iterator\n```python\ndef batch(iterable, batch_size):\n    batch = []\n    for item in iterable:\n        batch.append(item)\n        if len(batch) == batch_size:\n            yield batch\n            batch = []\n    if batch:\n        yield batch\n\ndata = range(10)\nfor b in batch(data, 3):\n    print(b)  # [0, 1, 2], [3, 4, 5], [6, 7, 8], [9]\n```\n\n## Example 3: Prime Number Generator\n```python\ndef primes():\n    yield 2\n    primes_list = [2]\n    candidate = 3\n    while True:\n        is_prime = True\n        for p in primes_list:\n            if p * p > candidate:\n                break\n            if candidate % p == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes_list.append(candidate)\n            yield candidate\n        candidate += 2\n\n# Get first 10 primes\nprime_gen = primes()\nfirst_10 = [next(prime_gen) for _ in range(10)]\n```\n\n## Example 4: Tree Traversal\n```python\nclass Node:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n    \n    def __iter__(self):\n        if self.left:\n            yield from self.left\n        yield self.value\n        if self.right:\n            yield from self.right\n\ntree = Node(2, Node(1), Node(3))\nprint(list(tree))  # [1, 2, 3]\n```\n"}, {"id": "Python_Theory/13_Iterators_and_Generators/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/13_Iterators_and_Generators/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "13 Iterators and Generators"], "content": "# Common Iterator and Generator Errors\n\n## 1. Exhausted Generator\n```python\n# WRONG\ngen = (x for x in range(3))\nlist(gen)  # [0, 1, 2]\nlist(gen)  # [] - Generator exhausted!\n\n# CORRECT - Create new generator or use list\ndata = list(range(3))\n```\n\n## 2. Forgetting to Call `next()` or Iterate\n```python\n# WRONG\ngen = (x for x in range(3))\nprint(gen)  # <generator object>\n\n# CORRECT\nfor x in gen:\n    print(x)\n```\n\n## 3. StopIteration Not Handled\n```python\n# WRONG\nit = iter([1, 2])\nnext(it)\nnext(it)\nnext(it)  # StopIteration!\n\n# CORRECT\nit = iter([1, 2])\ntry:\n    while True:\n        print(next(it))\nexcept StopIteration:\n    pass\n```\n\n## 4. Modifying List While Iterating\n```python\n# WRONG\nnumbers = [1, 2, 3, 4]\nfor num in numbers:\n    if num % 2 == 0:\n        numbers.remove(num)  # Modifies during iteration!\n\n# CORRECT\nnumbers = [num for num in numbers if num % 2 != 0]\n```\n\n## 5. Not Returning `self` in `__iter__`\n```python\n# WRONG\nclass MyIterator:\n    def __iter__(self):\n        return None  # Should return self!\n\n# CORRECT\nclass MyIterator:\n    def __iter__(self):\n        return self\n```\n"}, {"id": "Python_Theory/13_Iterators_and_Generators/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/13_Iterators_and_Generators/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "13 Iterators and Generators"], "content": "# Practice Questions - Iterators and Generators\n\n## Questions\n\n### Q1: Range Generator\nImplement your own `range()` function using a generator.\n\n### Q2: Fibonacci Generator\nCreate a generator that yields Fibonacci numbers up to n.\n\n### Q3: Cycle Iterator\nCreate an iterator that cycles through a list indefinitely.\n\n### Q4: Filter Generator\nCreate a generator that filters even numbers from an iterable.\n\n### Q5: Zip Generator\nImplement your own `zip()` function using generators.\n\n---\n\n## Solutions\n\n### A1: Range Generator\n```python\ndef my_range(start, stop=None, step=1):\n    if stop is None:\n        start, stop = 0, start\n    \n    current = start\n    while (step > 0 and current < stop) or (step < 0 and current > stop):\n        yield current\n        current += step\n\nfor num in my_range(5):\n    print(num)  # 0, 1, 2, 3, 4\n```\n\n### A2: Fibonacci Generator\n```python\ndef fibonacci(n):\n    a, b = 0, 1\n    count = 0\n    while count < n:\n        yield a\n        a, b = b, a + b\n        count += 1\n\nprint(list(fibonacci(10)))\n# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```\n\n### A3: Cycle Iterator\n```python\nclass Cycle:\n    def __init__(self, iterable):\n        self.iterable = list(iterable)\n        self.index = 0\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if not self.iterable:\n            raise StopIteration\n        value = self.iterable[self.index]\n        self.index = (self.index + 1) % len(self.iterable)\n        return value\n\ncycle = Cycle([1, 2, 3])\nfor i, val in enumerate(cycle):\n    if i >= 10:\n        break\n    print(val)  # 1, 2, 3, 1, 2, 3, 1, 2, 3, 1\n```\n\n### A4: Filter Generator\n```python\ndef filter_even(iterable):\n    for item in iterable:\n        if item % 2 == 0:\n            yield item\n\nnumbers = range(10)\nevens = filter_even(numbers)\nprint(list(evens))  # [0, 2, 4, 6, 8]\n```\n\n### A5: Zip Generator\n```python\ndef my_zip(*iterables):\n    iterators = [iter(it) for it in iterables]\n    while True:\n        try:\n            yield tuple(next(it) for it in iterators)\n        except StopIteration:\n            return\n\nlist1 = [1, 2, 3]\nlist2 = ['a', 'b', 'c']\nprint(list(my_zip(list1, list2)))\n# [(1, 'a'), (2, 'b'), (3, 'c')]\n```\n"}, {"id": "Python_Theory/14_Decorators/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/14_Decorators/01_Definition.md", "breadcrumbs": ["Python Theory", "14 Decorators"], "content": "# Decorators in Python\n\n## Definition\n\nA **decorator** is a function that takes another function and extends its behavior without explicitly modifying it. Decorators use the `@` syntax.\n\n## Basic Decorator\n```python\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before function call\")\n        func()\n        print(\"After function call\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\n# Output:\n# Before function call\n# Hello!\n# After function call\n```\n\n## How Decorators Work\n```python\n# These are equivalent:\n@my_decorator\ndef func():\n    pass\n\n# Same as:\ndef func():\n    pass\nfunc = my_decorator(func)\n```\n\n## Decorators with Arguments\n```python\ndef decorator_with_args(func):\n    def wrapper(*args, **kwargs):\n        print(f\"Arguments: {args}, {kwargs}\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@decorator_with_args\ndef greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ngreet(\"Alice\", greeting=\"Hi\")\n```\n\n## Preserving Metadata\n```python\nfrom functools import wraps\n\ndef my_decorator(func):\n    @wraps(func)  # Preserves func.__name__, __doc__, etc.\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n```\n"}, {"id": "Python_Theory/14_Decorators/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/14_Decorators/02_Theory.md", "breadcrumbs": ["Python Theory", "14 Decorators"], "content": "# Decorator Patterns\n\n## Parameterized Decorators\n```python\ndef repeat(times):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()  # Prints \"Hello!\" 3 times\n```\n\n## Class Decorators\n```python\nclass CountCalls:\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"Call {self.count}\")\n        return self.func(*args, **kwargs)\n\n@CountCalls\ndef greet():\n    print(\"Hello!\")\n\ngreet()  # Call 1, Hello!\ngreet()  # Call 2, Hello!\n```\n\n## Stacking Decorators\n```python\n@decorator1\n@decorator2\ndef func():\n    pass\n\n# Equivalent to:\nfunc = decorator1(decorator2(func))\n```\n\n## Built-in Decorators\n```python\nclass MyClass:\n    @staticmethod\n    def static_method():\n        pass\n    \n    @classmethod\n    def class_method(cls):\n        pass\n    \n    @property\n    def my_property(self):\n        return self._value\n```\n"}, {"id": "Python_Theory/14_Decorators/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/14_Decorators/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "14 Decorators"], "content": "# Common Decorator Use Cases\n\n## Timing Decorator\n```python\nimport time\nfrom functools import wraps\n\ndef timer(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} took {end-start:.2f}s\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(1)\n```\n\n## Logging Decorator\n```python\ndef log(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__} returned {result}\")\n        return result\n    return wrapper\n```\n\n## Caching/Memoization\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n```\n\n## Authentication Decorator\n```python\ndef require_auth(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        if not is_authenticated():\n            raise PermissionError(\"Not authenticated\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@require_auth\ndef sensitive_operation():\n    pass\n```\n"}, {"id": "Python_Theory/14_Decorators/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/14_Decorators/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "14 Decorators"], "content": "# Decorator Syntax and Methods\n\n## Basic Syntax\n```python\ndef decorator(func):\n    def wrapper(*args, **kwargs):\n        # Before\n        result = func(*args, **kwargs)\n        # After\n        return result\n    return wrapper\n\n@decorator\ndef my_function():\n    pass\n```\n\n## With Parameters\n```python\ndef decorator_factory(param):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            # Use param\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@decorator_factory(\"value\")\ndef my_function():\n    pass\n```\n\n## Class-based Decorators\n```python\nclass Decorator:\n    def __init__(self, func):\n        self.func = func\n    \n    def __call__(self, *args, **kwargs):\n        # Decorator logic\n        return self.func(*args, **kwargs)\n```\n\n## functools.wraps\n```python\nfrom functools import wraps\n\ndef my_decorator(func):\n    @wraps(func)  # Preserves metadata\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n```\n"}, {"id": "Python_Theory/14_Decorators/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/14_Decorators/05_Examples.md", "breadcrumbs": ["Python Theory", "14 Decorators"], "content": "# Decorator Examples\n\n## Example 1: Retry Decorator\n```python\nimport time\nfrom functools import wraps\n\ndef retry(max_attempts=3, delay=1):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_attempts - 1:\n                        raise\n                    time.sleep(delay)\n        return wrapper\n    return decorator\n\n@retry(max_attempts=3)\ndef unreliable_api_call():\n    # May fail randomly\n    pass\n```\n\n## Example 2: Validation Decorator\n```python\ndef validate_positive(func):\n    @wraps(func)\n    def wrapper(x):\n        if x <= 0:\n            raise ValueError(\"Must be positive\")\n        return func(x)\n    return wrapper\n\n@validate_positive\ndef square_root(x):\n    return x ** 0.5\n```\n\n## Example 3: Rate Limiting\n```python\nimport time\n\ndef rate_limit(calls_per_second):\n    min_interval = 1.0 / calls_per_second\n    last_called = [0.0]\n    \n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            elapsed = time.time() - last_called[0]\n            if elapsed < min_interval:\n                time.sleep(min_interval - elapsed)\n            last_called[0] = time.time()\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@rate_limit(2)  # Max 2 calls per second\ndef api_call():\n    pass\n```\n"}, {"id": "Python_Theory/14_Decorators/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/14_Decorators/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "14 Decorators"], "content": "# Common Decorator Errors\n\n## 1. Forgetting to Return Wrapper\n```python\n# WRONG\ndef decorator(func):\n    def wrapper():\n        func()\n    # Missing return!\n\n# CORRECT\ndef decorator(func):\n    def wrapper():\n        func()\n    return wrapper\n```\n\n## 2. Not Using *args, **kwargs\n```python\n# WRONG\ndef decorator(func):\n    def wrapper():  # Can't accept arguments!\n        return func()\n    return wrapper\n\n# CORRECT\ndef decorator(func):\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n```\n\n## 3. Not Using @wraps\n```python\n# WRONG\ndef decorator(func):\n    def wrapper():\n        return func()\n    return wrapper\n# func.__name__ is now \"wrapper\"!\n\n# CORRECT\nfrom functools import wraps\n\ndef decorator(func):\n    @wraps(func)\n    def wrapper():\n        return func()\n    return wrapper\n```\n\n## 4. Decorator vs Decorator Factory Confusion\n```python\n# Decorator (no parameters)\n@my_decorator\ndef func():\n    pass\n\n# Decorator factory (with parameters)\n@my_decorator(param)\ndef func():\n    pass\n```\n"}, {"id": "Python_Theory/14_Decorators/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/14_Decorators/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "14 Decorators"], "content": "# Practice Questions - Decorators\n\n## Questions\n\n### Q1: Debug Decorator\nCreate a decorator that prints function name and arguments before calling it.\n\n### Q2: Cache Decorator\nImplement a simple caching decorator.\n\n### Q3: Timing Decorator\nCreate a decorator that measures execution time.\n\n### Q4: Validation Decorator\nCreate a decorator that validates function arguments are positive numbers.\n\n### Q5: Singleton Decorator\nCreate a decorator that makes a class a singleton.\n\n---\n\n## Solutions\n\n### A1: Debug Decorator\n```python\nfrom functools import wraps\n\ndef debug(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__} with args={args}, kwargs={kwargs}\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__} returned {result}\")\n        return result\n    return wrapper\n\n@debug\ndef add(a, b):\n    return a + b\n\nadd(3, 5)\n```\n\n### A2: Cache Decorator\n```python\ndef cache(func):\n    cached_results = {}\n    \n    @wraps(func)\n    def wrapper(*args):\n        if args in cached_results:\n            print(f\"Cache hit for {args}\")\n            return cached_results[args]\n        result = func(*args)\n        cached_results[args] = result\n        return result\n    return wrapper\n\n@cache\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n```\n\n### A3: Timing Decorator\n```python\nimport time\n\ndef timer(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} took {end-start:.4f} seconds\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(1)\n    return \"Done\"\n```\n\n### A4: Validation Decorator\n```python\ndef validate_positive(func):\n    @wraps(func)\n    def wrapper(*args):\n        for arg in args:\n            if not isinstance(arg, (int, float)) or arg <= 0:\n                raise ValueError(f\"All arguments must be positive numbers\")\n        return func(*args)\n    return wrapper\n\n@validate_positive\ndef multiply(a, b):\n    return a * b\n```\n\n### A5: Singleton Decorator\n```python\ndef singleton(cls):\n    instances = {}\n    \n    @wraps(cls)\n    def wrapper(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return wrapper\n\n@singleton\nclass Database:\n    def __init__(self):\n        print(\"Creating database connection\")\n\ndb1 = Database()  # Creates instance\ndb2 = Database()  # Returns same instance\nprint(db1 is db2)  # True\n```\n"}, {"id": "Python_Theory/15_Comprehensions/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/15_Comprehensions/01_Definition.md", "breadcrumbs": ["Python Theory", "15 Comprehensions"], "content": "# Comprehensions in Python\n\n## Definition\n\n**Comprehensions** provide a concise way to create sequences (lists, sets, dictionaries) from existing iterables. They're more readable and often faster than traditional loops.\n\n## List Comprehensions\n```python\n# Traditional loop\nsquares = []\nfor x in range(10):\n    squares.append(x**2)\n\n# List comprehension\nsquares = [x**2 for x in range(10)]\n```\n\n### With Condition\n```python\n# Even numbers only\nevens = [x for x in range(20) if x % 2 == 0]\n\n# With if-else\nresult = [x if x % 2 == 0 else -x for x in range(10)]\n```\n\n### Nested Comprehensions\n```python\n# Flatten 2D list\nmatrix = [[1, 2], [3, 4], [5, 6]]\nflat = [num for row in matrix for num in row]\n# [1, 2, 3, 4, 5, 6]\n\n# Create 2D list\nmatrix = [[i*j for j in range(3)] for i in range(3)]\n```\n\n## Set Comprehensions\n```python\n# Unique squares\nunique_squares = {x**2 for x in [1, 1, 2, 2, 3, 3]}\n# {1, 4, 9}\n```\n\n## Dictionary Comprehensions\n```python\n# Square dictionary\nsquares_dict = {x: x**2 for x in range(5)}\n# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n# Swap keys and values\noriginal = {'a': 1, 'b': 2}\nswapped = {v: k for k, v in original.items()}\n# {1: 'a', 2: 'b'}\n```\n\n## Generator Expressions\n```python\n# Like list comprehension but with ()\ngen = (x**2 for x in range(10))\n# Returns generator object, not list\n```\n"}, {"id": "Python_Theory/15_Comprehensions/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/15_Comprehensions/02_Theory.md", "breadcrumbs": ["Python Theory", "15 Comprehensions"], "content": "# Comprehension Theory and Patterns\n\n## Comprehension vs Loop Performance\n```python\nimport timeit\n\n# Loop\ndef with_loop():\n    result = []\n    for x in range(1000):\n        result.append(x**2)\n    return result\n\n# Comprehension\ndef with_comp():\n    return [x**2 for x in range(1000)]\n\n# Comprehensions are typically faster\n```\n\n## Conditional Logic in Comprehensions\n```python\n# Filter (if at end)\nevens = [x for x in range(10) if x % 2 == 0]\n\n# Transform (if-else in expression)\nresult = ['even' if x % 2 == 0 else 'odd' for x in range(10)]\n\n# Multiple conditions\nresult = [x for x in range(100) if x % 2 == 0 if x % 3 == 0]\n# Same as: if x % 2 == 0 and x % 3 == 0\n```\n\n## Nested Comprehensions\n```python\n# Cartesian product\npairs = [(x, y) for x in range(3) for y in range(3)]\n# [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]\n\n# Matrix transpose\nmatrix = [[1, 2, 3], [4, 5, 6]]\ntransposed = [[row[i] for row in matrix] for i in range(3)]\n# [[1, 4], [2, 5], [3, 6]]\n```\n\n## Walrus Operator in Comprehensions (Python 3.8+)\n```python\n# Compute once, use multiple times\nresults = [(y := x**2, y+1) for x in range(5)]\n# [(0, 1), (1, 2), (4, 5), (9, 10), (16, 17)]\n```\n"}, {"id": "Python_Theory/15_Comprehensions/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/15_Comprehensions/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "15 Comprehensions"], "content": "# Comprehension Use Cases\n\n## Data Transformation\n```python\n# Convert strings to integers\nstrings = ['1', '2', '3']\nnumbers = [int(s) for s in strings]\n\n# Extract specific fields\nusers = [{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}]\nnames = [user['name'] for user in users]\n```\n\n## Filtering\n```python\n# Filter by condition\nnumbers = range(20)\nevens = [x for x in numbers if x % 2 == 0]\n\n# Filter and transform\nwords = ['hello', 'world', 'python']\nupper_long = [w.upper() for w in words if len(w) > 5]\n```\n\n## Creating Lookup Tables\n```python\n# Index to value mapping\nindex_map = {i: chr(65+i) for i in range(26)}\n# {0: 'A', 1: 'B', ..., 25: 'Z'}\n\n# Invert dictionary\noriginal = {'a': 1, 'b': 2}\ninverted = {v: k for k, v in original.items()}\n```\n\n## Set Operations\n```python\n# Unique elements\nnumbers = [1, 2, 2, 3, 3, 4]\nunique = {x for x in numbers}\n\n# Set of squares\nsquares = {x**2 for x in range(10)}\n```\n\n## Generator Expressions for Memory Efficiency\n```python\n# Large dataset - use generator\nlarge_data = (process(x) for x in huge_dataset)\n\n# Process one at a time\nfor item in large_data:\n    handle(item)\n```\n"}, {"id": "Python_Theory/15_Comprehensions/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/15_Comprehensions/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "15 Comprehensions"], "content": "# Comprehension Syntax\n\n## List Comprehension Syntax\n```python\n[expression for item in iterable if condition]\n\n# Multiple for clauses\n[expression for item1 in iter1 for item2 in iter2]\n\n# Nested comprehension\n[[expression for item in iterable] for outer_item in outer_iterable]\n```\n\n## Dictionary Comprehension Syntax\n```python\n{key_expr: value_expr for item in iterable if condition}\n\n# From two lists\nkeys = ['a', 'b', 'c']\nvalues = [1, 2, 3]\nd = {k: v for k, v in zip(keys, values)}\n```\n\n## Set Comprehension Syntax\n```python\n{expression for item in iterable if condition}\n```\n\n## Generator Expression Syntax\n```python\n(expression for item in iterable if condition)\n\n# Note: Use () not []\n```\n\n## Comparison\n```python\n# List - Creates list immediately\nlist_comp = [x**2 for x in range(10)]\n\n# Generator - Lazy evaluation\ngen_exp = (x**2 for x in range(10))\n\n# Set - Unique elements\nset_comp = {x**2 for x in range(10)}\n\n# Dict - Key-value pairs\ndict_comp = {x: x**2 for x in range(10)}\n```\n"}, {"id": "Python_Theory/15_Comprehensions/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/15_Comprehensions/05_Examples.md", "breadcrumbs": ["Python Theory", "15 Comprehensions"], "content": "# Comprehension Examples\n\n## Example 1: FizzBuzz\n```python\nresult = ['FizzBuzz' if x % 15 == 0 else 'Fizz' if x % 3 == 0 else 'Buzz' if x % 5 == 0 else x \n          for x in range(1, 101)]\n```\n\n## Example 2: Word Lengths\n```python\nsentence = \"The quick brown fox jumps\"\nword_lengths = {word: len(word) for word in sentence.split()}\n# {'The': 3, 'quick': 5, 'brown': 5, 'fox': 3, 'jumps': 5}\n```\n\n## Example 3: Flatten Nested List\n```python\nnested = [[1, 2], [3, 4], [5, 6]]\nflat = [num for sublist in nested for num in sublist]\n# [1, 2, 3, 4, 5, 6]\n```\n\n## Example 4: Prime Numbers\n```python\nprimes = [x for x in range(2, 100) \n          if all(x % i != 0 for i in range(2, int(x**0.5) + 1))]\n```\n\n## Example 5: File Processing\n```python\n# Read and process lines\nwith open('data.txt') as f:\n    lines = [line.strip().upper() for line in f if line.strip()]\n```\n\n## Example 6: Matrix Operations\n```python\n# Create identity matrix\nn = 3\nidentity = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n# [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n```\n\n## Example 7: Group By\n```python\nfrom itertools import groupby\n\ndata = [('a', 1), ('a', 2), ('b', 3), ('b', 4)]\ngrouped = {k: [v for _, v in g] for k, g in groupby(data, key=lambda x: x[0])}\n# {'a': [1, 2], 'b': [3, 4]}\n```\n"}, {"id": "Python_Theory/15_Comprehensions/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/15_Comprehensions/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "15 Comprehensions"], "content": "# Common Comprehension Errors\n\n## 1. Too Complex\n```python\n# WRONG - Hard to read\nresult = [x**2 if x % 2 == 0 else x**3 if x % 3 == 0 else x \n          for x in range(100) if x > 10 if x < 90]\n\n# CORRECT - Use regular loop for complex logic\nresult = []\nfor x in range(11, 90):\n    if x % 2 == 0:\n        result.append(x**2)\n    elif x % 3 == 0:\n        result.append(x**3)\n    else:\n        result.append(x)\n```\n\n## 2. Modifying List While Iterating\n```python\n# WRONG\nnumbers = [1, 2, 3, 4]\n[numbers.remove(x) for x in numbers if x % 2 == 0]  # Unpredictable!\n\n# CORRECT\nnumbers = [x for x in numbers if x % 2 != 0]\n```\n\n## 3. Using List Comp for Side Effects\n```python\n# WRONG - Comprehensions should create new data\n[print(x) for x in range(10)]  # Creates useless list of None\n\n# CORRECT\nfor x in range(10):\n    print(x)\n```\n\n## 4. Forgetting Parentheses for Generator\n```python\n# List (memory intensive)\nbig_list = [x**2 for x in range(1000000)]\n\n# Generator (memory efficient)\nbig_gen = (x**2 for x in range(1000000))\n```\n\n## 5. Nested Comprehension Confusion\n```python\n# Order matters!\n# for x in range(3) for y in range(3)\n# is NOT the same as\n# for y in range(3) for x in range(3)\n\npairs1 = [(x, y) for x in range(3) for y in range(3)]\n# [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]\n```\n"}, {"id": "Python_Theory/15_Comprehensions/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/15_Comprehensions/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "15 Comprehensions"], "content": "# Practice Questions - Comprehensions\n\n## Questions\n\n### Q1: Square Even Numbers\nCreate a list of squares of even numbers from 0 to 20.\n\n### Q2: Word Lengths Dictionary\nCreate a dictionary mapping words to their lengths from a sentence.\n\n### Q3: Flatten and Filter\nFlatten a nested list and keep only positive numbers.\n\n### Q4: Cartesian Product\nCreate all pairs (x, y) where x is from [1, 2, 3] and y is from ['a', 'b'].\n\n### Q5: Prime Checker\nUse comprehension to find all primes between 2 and 50.\n\n---\n\n## Solutions\n\n### A1: Square Even Numbers\n```python\nsquares = [x**2 for x in range(21) if x % 2 == 0]\nprint(squares)\n# [0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400]\n```\n\n### A2: Word Lengths Dictionary\n```python\nsentence = \"Python is an amazing programming language\"\nword_lengths = {word: len(word) for word in sentence.split()}\nprint(word_lengths)\n# {'Python': 6, 'is': 2, 'an': 2, 'amazing': 7, 'programming': 11, 'language': 8}\n```\n\n### A3: Flatten and Filter\n```python\nnested = [[1, -2, 3], [-4, 5], [6, -7, 8]]\npositive = [num for sublist in nested for num in sublist if num > 0]\nprint(positive)\n# [1, 3, 5, 6, 8]\n```\n\n### A4: Cartesian Product\n```python\npairs = [(x, y) for x in [1, 2, 3] for y in ['a', 'b']]\nprint(pairs)\n# [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b'), (3, 'a'), (3, 'b')]\n```\n\n### A5: Prime Checker\n```python\nprimes = [x for x in range(2, 51) \n          if all(x % i != 0 for i in range(2, int(x**0.5) + 1))]\nprint(primes)\n# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n```\n\n## Bonus: Advanced Challenges\n\n### Matrix Transpose\n```python\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ntransposed = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nprint(transposed)\n# [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n```\n\n### Group by First Letter\n```python\nwords = ['apple', 'banana', 'apricot', 'blueberry', 'cherry']\ngrouped = {word[0]: [w for w in words if w[0] == word[0]] for word in words}\nprint(grouped)\n# {'a': ['apple', 'apricot'], 'b': ['banana', 'blueberry'], 'c': ['cherry']}\n```\n"}, {"id": "Python_Theory/16_Standard_Library_Overview/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/16_Standard_Library_Overview/01_Definition.md", "breadcrumbs": ["Python Theory", "16 Standard Library Overview"], "content": "# Python Standard Library Overview\n\n## Definition\n\nThe **Python Standard Library** is a collection of modules and packages that come pre-installed with Python. It provides tools for common programming tasks without requiring external dependencies.\n\n> \"Batteries Included\" - Python Philosophy\n\n## Key Categories\n\n### 1. Built-in Functions\n```python\n# Always available, no import needed\nlen([1, 2, 3])\nprint(\"Hello\")\ntype(42)\n```\n\n### 2. Text Processing\n- `string`: String constants and templates\n- `re`: Regular expressions\n- `textwrap`: Text wrapping and filling\n\n### 3. Data Types\n- `datetime`: Date and time handling\n- `collections`: Specialized container datatypes\n- `array`: Efficient arrays of numeric values\n\n### 4. Numeric and Mathematical\n- `math`: Mathematical functions\n- `random`: Random number generation\n- `statistics`: Statistical functions\n\n### 5. File and Directory Access\n- `os.path`: Path manipulations\n- `pathlib`: Object-oriented filesystem paths\n- `glob`: Unix-style pathname pattern expansion\n\n### 6. Data Persistence\n- `pickle`: Python object serialization\n- `json`: JSON encoder and decoder\n- `sqlite3`: SQLite database\n\n### 7. Internet Protocols\n- `urllib`: URL handling\n- `http`: HTTP modules\n- `email`: Email and MIME handling\n\n### 8. Development Tools\n- `unittest`: Unit testing framework\n- `pdb`: Python debugger\n- `timeit`: Measure execution time\n"}, {"id": "Python_Theory/16_Standard_Library_Overview/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/16_Standard_Library_Overview/02_Theory.md", "breadcrumbs": ["Python Theory", "16 Standard Library Overview"], "content": "# Essential Standard Library Modules\n\n## `collections` - Specialized Containers\n```python\nfrom collections import Counter, defaultdict, deque, namedtuple\n\n# Counter - Count occurrences\nwords = ['apple', 'banana', 'apple']\ncounts = Counter(words)  # Counter({'apple': 2, 'banana': 1})\n\n# defaultdict - Default values for missing keys\nd = defaultdict(list)\nd['key'].append(1)  # No KeyError!\n\n# deque - Double-ended queue\nqueue = deque([1, 2, 3])\nqueue.appendleft(0)  # [0, 1, 2, 3]\n\n# namedtuple - Tuple with named fields\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(10, 20)\nprint(p.x, p.y)\n```\n\n## `datetime` - Date and Time\n```python\nfrom datetime import datetime, timedelta\n\n# Current time\nnow = datetime.now()\n\n# Create specific date\ndate = datetime(2024, 12, 9, 14, 30)\n\n# Arithmetic\ntomorrow = now + timedelta(days=1)\n\n# Formatting\nformatted = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n```\n\n## `itertools` - Iterator Tools\n```python\nimport itertools\n\n# Infinite iterators\ncount = itertools.count(10, 2)  # 10, 12, 14, ...\ncycle = itertools.cycle([1, 2, 3])  # 1, 2, 3, 1, 2, 3, ...\n\n# Combinatorics\nperms = itertools.permutations([1, 2, 3])\ncombs = itertools.combinations([1, 2, 3], 2)\n\n# Grouping\ndata = [('a', 1), ('a', 2), ('b', 3)]\nfor key, group in itertools.groupby(data, key=lambda x: x[0]):\n    print(key, list(group))\n```\n\n## `functools` - Higher-Order Functions\n```python\nfrom functools import lru_cache, partial, reduce\n\n# Caching\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Partial application\nfrom operator import add\nadd_five = partial(add, 5)\nprint(add_five(10))  # 15\n\n# Reduce\nnumbers = [1, 2, 3, 4]\nsum_all = reduce(lambda x, y: x + y, numbers)  # 10\n```\n"}, {"id": "Python_Theory/16_Standard_Library_Overview/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/16_Standard_Library_Overview/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "16 Standard Library Overview"], "content": "# Common Standard Library Modules\n\n## `os` and `sys`\n```python\nimport os\nimport sys\n\n# Environment\nprint(os.environ.get('PATH'))\nprint(sys.platform)  # 'win32', 'linux', 'darwin'\n\n# Command line arguments\nprint(sys.argv)\n\n# Exit\nsys.exit(0)\n```\n\n## `re` - Regular Expressions\n```python\nimport re\n\n# Search\nmatch = re.search(r'\\d+', 'Order 123')\nif match:\n    print(match.group())  # '123'\n\n# Find all\nnumbers = re.findall(r'\\d+', 'Order 123, Item 456')\n# ['123', '456']\n\n# Replace\ntext = re.sub(r'\\d+', 'XXX', 'Order 123')\n# 'Order XXX'\n```\n\n## `random` - Random Numbers\n```python\nimport random\n\n# Random float [0.0, 1.0)\nrandom.random()\n\n# Random integer\nrandom.randint(1, 10)\n\n# Random choice\nrandom.choice(['apple', 'banana', 'cherry'])\n\n# Shuffle\nitems = [1, 2, 3, 4]\nrandom.shuffle(items)\n```\n\n## `json` - JSON Handling\n```python\nimport json\n\n# Serialize\ndata = {'name': 'Alice', 'age': 30}\njson_str = json.dumps(data)\n\n# Deserialize\ndata = json.loads(json_str)\n\n# File I/O\nwith open('data.json', 'w') as f:\n    json.dump(data, f)\n\nwith open('data.json', 'r') as f:\n    data = json.load(f)\n```\n"}, {"id": "Python_Theory/16_Standard_Library_Overview/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/16_Standard_Library_Overview/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "16 Standard Library Overview"], "content": "# Standard Library Methods and Tools\n\n## `pathlib` - Modern Path Handling\n```python\nfrom pathlib import Path\n\n# Create path\npath = Path('folder') / 'file.txt'\n\n# Check existence\nif path.exists():\n    content = path.read_text()\n\n# Iterate directory\nfor file in Path('.').glob('*.py'):\n    print(file)\n```\n\n## `argparse` - Command Line Arguments\n```python\nimport argparse\n\nparser = argparse.ArgumentParser(description='Process files')\nparser.add_argument('filename', help='Input file')\nparser.add_argument('--verbose', action='store_true')\n\nargs = parser.parse_args()\nprint(args.filename)\n```\n\n## `logging` - Logging Framework\n```python\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nlogger.debug(\"Debug message\")\nlogger.info(\"Info message\")\nlogger.warning(\"Warning message\")\nlogger.error(\"Error message\")\n```\n\n## `unittest` - Testing Framework\n```python\nimport unittest\n\nclass TestMath(unittest.TestCase):\n    def test_addition(self):\n        self.assertEqual(1 + 1, 2)\n    \n    def test_subtraction(self):\n        self.assertEqual(5 - 3, 2)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n"}, {"id": "Python_Theory/16_Standard_Library_Overview/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/16_Standard_Library_Overview/05_Examples.md", "breadcrumbs": ["Python Theory", "16 Standard Library Overview"], "content": "# Standard Library Examples\n\n## Example 1: Configuration File Parser\n```python\nimport configparser\n\nconfig = configparser.ConfigParser()\nconfig.read('config.ini')\n\n# Read values\ndb_host = config['database']['host']\ndb_port = config.getint('database', 'port')\n```\n\n## Example 2: CSV Processing\n```python\nimport csv\nfrom collections import Counter\n\ndef analyze_csv(filename):\n    with open(filename) as f:\n        reader = csv.DictReader(f)\n        ages = [int(row['age']) for row in reader]\n    \n    return {\n        'count': len(ages),\n        'average': sum(ages) / len(ages),\n        'min': min(ages),\n        'max': max(ages)\n    }\n```\n\n## Example 3: Web Scraping\n```python\nfrom urllib.request import urlopen\nimport json\n\ndef fetch_data(url):\n    with urlopen(url) as response:\n        data = response.read()\n    return json.loads(data)\n```\n\n## Example 4: Temporary Files\n```python\nimport tempfile\n\n# Temporary file\nwith tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n    f.write(\"Temporary data\")\n    temp_path = f.name\n\n# Temporary directory\nwith tempfile.TemporaryDirectory() as tmpdir:\n    # Use tmpdir\n    pass\n```\n\n## Example 5: Command Execution\n```python\nimport subprocess\n\n# Run command\nresult = subprocess.run(['ls', '-l'], capture_output=True, text=True)\nprint(result.stdout)\n```\n"}, {"id": "Python_Theory/16_Standard_Library_Overview/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/16_Standard_Library_Overview/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "16 Standard Library Overview"], "content": "# Common Standard Library Errors\n\n## 1. Import Errors\n```python\n# WRONG - Incorrect module name\nimport Collections  # ModuleNotFoundError\n\n# CORRECT\nimport collections\n```\n\n## 2. datetime Timezone Issues\n```python\n# WRONG - Naive datetime\nfrom datetime import datetime\nnow = datetime.now()  # No timezone info\n\n# CORRECT\nfrom datetime import datetime, timezone\nnow = datetime.now(timezone.utc)\n```\n\n## 3. json Serialization Errors\n```python\n# WRONG - Can't serialize datetime\nimport json\nfrom datetime import datetime\njson.dumps({'time': datetime.now()})  # TypeError\n\n# CORRECT\njson.dumps({'time': datetime.now().isoformat()})\n```\n\n## 4. pathlib vs os.path Mixing\n```python\n# WRONG - Mixing types\nfrom pathlib import Path\nimport os\npath = Path('file.txt')\nos.path.join(path, 'other')  # TypeError\n\n# CORRECT - Use one or the other\npath = Path('file.txt') / 'other'\n```\n\n## 5. Regular Expression Errors\n```python\n# WRONG - Unescaped special characters\nimport re\nre.search('.', 'test')  # Matches any character!\n\n# CORRECT\nre.search(r'\\.', 'test')  # Matches literal dot\n```\n"}, {"id": "Python_Theory/16_Standard_Library_Overview/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/16_Standard_Library_Overview/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "16 Standard Library Overview"], "content": "# Practice Questions - Standard Library\n\n## Questions\n\n### Q1: Counter Usage\nCount word frequency in a text using `Counter`.\n\n### Q2: Date Arithmetic\nCalculate the number of days between two dates.\n\n### Q3: JSON Processing\nRead a JSON file and extract specific fields.\n\n### Q4: Regular Expression\nExtract all email addresses from text.\n\n### Q5: Path Operations\nList all Python files in a directory recursively.\n\n---\n\n## Solutions\n\n### A1: Counter Usage\n```python\nfrom collections import Counter\n\ntext = \"the quick brown fox jumps over the lazy dog the fox\"\nwords = text.split()\nword_freq = Counter(words)\n\nprint(word_freq.most_common(3))\n# [('the', 3), ('fox', 2), ('quick', 1)]\n```\n\n### A2: Date Arithmetic\n```python\nfrom datetime import datetime\n\ndate1 = datetime(2024, 1, 1)\ndate2 = datetime(2024, 12, 31)\n\ndifference = date2 - date1\nprint(f\"Days: {difference.days}\")  # 365\n```\n\n### A3: JSON Processing\n```python\nimport json\n\nwith open('data.json') as f:\n    data = json.load(f)\n\n# Extract names\nnames = [item['name'] for item in data['users']]\nprint(names)\n```\n\n### A4: Regular Expression\n```python\nimport re\n\ntext = \"Contact us at info@example.com or support@test.org\"\nemails = re.findall(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b', text)\nprint(emails)\n# ['info@example.com', 'support@test.org']\n```\n\n### A5: Path Operations\n```python\nfrom pathlib import Path\n\npython_files = list(Path('.').rglob('*.py'))\nfor file in python_files:\n    print(file)\n```\n"}, {"id": "Python_Theory/17_Advanced_Topics/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/17_Advanced_Topics/01_Definition.md", "breadcrumbs": ["Python Theory", "17 Advanced Topics"], "content": "# Advanced Python Topics\n\n## Definition\n\n**Advanced Python topics** cover features and patterns that go beyond basic programming, including metaprogramming, concurrency, type hints, and performance optimization.\n\n## Key Advanced Concepts\n\n### 1. Type Hints (Python 3.5+)\n```python\nfrom typing import List, Dict, Optional, Union\n\ndef greet(name: str) -> str:\n    return f\"Hello, {name}\"\n\ndef process_items(items: List[int]) -> Dict[str, int]:\n    return {\"count\": len(items), \"sum\": sum(items)}\n```\n\n### 2. Context Managers\n```python\nclass DatabaseConnection:\n    def __enter__(self):\n        # Setup\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # Cleanup\n        return False\n```\n\n### 3. Metaclasses\n```python\nclass Meta(type):\n    def __new__(cls, name, bases, dct):\n        # Modify class creation\n        return super().__new__(cls, name, bases, dct)\n\nclass MyClass(metaclass=Meta):\n    pass\n```\n\n### 4. Descriptors\n```python\nclass Descriptor:\n    def __get__(self, obj, objtype=None):\n        return self.value\n    \n    def __set__(self, obj, value):\n        self.value = value\n```\n\n### 5. Async/Await (Coroutines)\n```python\nimport asyncio\n\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"Data\"\n\nasync def main():\n    result = await fetch_data()\n```\n\n### 6. Threading and Multiprocessing\n```python\nimport threading\nimport multiprocessing\n\n# Thread\nthread = threading.Thread(target=function)\nthread.start()\n\n# Process\nprocess = multiprocessing.Process(target=function)\nprocess.start()\n```\n"}, {"id": "Python_Theory/17_Advanced_Topics/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/17_Advanced_Topics/02_Theory.md", "breadcrumbs": ["Python Theory", "17 Advanced Topics"], "content": "# Async Programming and Concurrency\n\n## Asyncio Basics\n```python\nimport asyncio\n\nasync def say_hello():\n    print(\"Hello\")\n    await asyncio.sleep(1)\n    print(\"World\")\n\n# Run\nasyncio.run(say_hello())\n```\n\n## Concurrent Execution\n```python\nasync def task1():\n    await asyncio.sleep(1)\n    return \"Task 1\"\n\nasync def task2():\n    await asyncio.sleep(1)\n    return \"Task 2\"\n\nasync def main():\n    # Run concurrently\n    results = await asyncio.gather(task1(), task2())\n    print(results)\n\nasyncio.run(main())\n```\n\n## Threading\n```python\nimport threading\nimport time\n\ndef worker(name):\n    print(f\"{name} starting\")\n    time.sleep(2)\n    print(f\"{name} done\")\n\nthreads = []\nfor i in range(3):\n    t = threading.Thread(target=worker, args=(f\"Thread-{i}\",))\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()\n```\n\n## Multiprocessing\n```python\nfrom multiprocessing import Process, Pool\n\ndef square(n):\n    return n * n\n\n# Process\np = Process(target=square, args=(5,))\np.start()\np.join()\n\n# Pool\nwith Pool(4) as pool:\n    results = pool.map(square, range(10))\n```\n\n## Thread Safety\n```python\nimport threading\n\nlock = threading.Lock()\ncounter = 0\n\ndef increment():\n    global counter\n    with lock:\n        counter += 1\n```\n"}, {"id": "Python_Theory/17_Advanced_Topics/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/17_Advanced_Topics/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "17 Advanced Topics"], "content": "# Type Hints and Metaprogramming\n\n## Type Hints\n```python\nfrom typing import List, Dict, Optional, Union, Callable, TypeVar\n\n# Basic types\ndef greet(name: str, age: int) -> str:\n    return f\"{name} is {age}\"\n\n# Collections\ndef process(items: List[int]) -> Dict[str, int]:\n    return {\"sum\": sum(items)}\n\n# Optional\ndef find(name: str) -> Optional[str]:\n    return name if name else None\n\n# Union\ndef parse(value: Union[int, str]) -> int:\n    return int(value)\n\n# Callable\ndef apply(func: Callable[[int], int], x: int) -> int:\n    return func(x)\n\n# Generic\nT = TypeVar('T')\ndef first(items: List[T]) -> T:\n    return items[0]\n```\n\n## Metaclasses\n```python\nclass SingletonMeta(type):\n    _instances = {}\n    \n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=SingletonMeta):\n    pass\n\ndb1 = Database()\ndb2 = Database()\nprint(db1 is db2)  # True\n```\n\n## Descriptors\n```python\nclass Validator:\n    def __init__(self, min_value, max_value):\n        self.min_value = min_value\n        self.max_value = max_value\n    \n    def __set_name__(self, owner, name):\n        self.name = f\"_{name}\"\n    \n    def __get__(self, obj, objtype=None):\n        return getattr(obj, self.name)\n    \n    def __set__(self, obj, value):\n        if not self.min_value <= value <= self.max_value:\n            raise ValueError(f\"Value must be between {self.min_value} and {self.max_value}\")\n        setattr(obj, self.name, value)\n\nclass Person:\n    age = Validator(0, 150)\n    \n    def __init__(self, age):\n        self.age = age\n```\n"}, {"id": "Python_Theory/17_Advanced_Topics/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/17_Advanced_Topics/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "17 Advanced Topics"], "content": "# Advanced Syntax and Patterns\n\n## Context Manager Protocol\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef managed_resource():\n    # Setup\n    resource = acquire_resource()\n    try:\n        yield resource\n    finally:\n        # Cleanup\n        release_resource(resource)\n\nwith managed_resource() as r:\n    use(r)\n```\n\n## Property Decorators\n```python\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n    \n    @property\n    def radius(self):\n        return self._radius\n    \n    @radius.setter\n    def radius(self, value):\n        if value < 0:\n            raise ValueError(\"Radius must be positive\")\n        self._radius = value\n    \n    @property\n    def area(self):\n        return 3.14 * self._radius ** 2\n```\n\n## Slots\n```python\nclass Point:\n    __slots__ = ['x', 'y']  # Memory optimization\n    \n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n```\n\n## Abstract Base Classes\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        pass\n```\n\n## Dataclasses\n```python\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n    hobbies: list = field(default_factory=list)\n```\n"}, {"id": "Python_Theory/17_Advanced_Topics/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/17_Advanced_Topics/05_Examples.md", "breadcrumbs": ["Python Theory", "17 Advanced Topics"], "content": "# Advanced Python Examples\n\n## Example 1: Async Web Scraper\n```python\nimport asyncio\nimport aiohttp\n\nasync def fetch(session, url):\n    async with session.get(url) as response:\n        return await response.text()\n\nasync def main():\n    urls = ['http://example.com', 'http://example.org']\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n    return results\n```\n\n## Example 2: Custom Decorator with State\n```python\ndef count_calls(func):\n    def wrapper(*args, **kwargs):\n        wrapper.calls += 1\n        print(f\"Call {wrapper.calls}\")\n        return func(*args, **kwargs)\n    wrapper.calls = 0\n    return wrapper\n\n@count_calls\ndef greet():\n    print(\"Hello\")\n```\n\n## Example 3: Context Manager for Timing\n```python\nimport time\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer(name):\n    start = time.time()\n    yield\n    end = time.time()\n    print(f\"{name} took {end-start:.2f}s\")\n\nwith timer(\"Operation\"):\n    # Do work\n    time.sleep(1)\n```\n\n## Example 4: Thread Pool Executor\n```python\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef process(item):\n    return item * 2\n\nitems = range(10)\nwith ThreadPoolExecutor(max_workers=4) as executor:\n    results = list(executor.map(process, items))\n```\n\n## Example 5: Custom Iterator with State\n```python\nclass FibonacciIterator:\n    def __init__(self, max_count):\n        self.max_count = max_count\n        self.count = 0\n        self.a, self.b = 0, 1\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.count >= self.max_count:\n            raise StopIteration\n        self.count += 1\n        result = self.a\n        self.a, self.b = self.b, self.a + self.b\n        return result\n```\n"}, {"id": "Python_Theory/17_Advanced_Topics/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/17_Advanced_Topics/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "17 Advanced Topics"], "content": "# Common Advanced Python Errors\n\n## 1. Async/Await Errors\n```python\n# WRONG - Forgetting await\nasync def fetch():\n    return \"data\"\n\nasync def main():\n    result = fetch()  # Returns coroutine, not \"data\"!\n\n# CORRECT\nasync def main():\n    result = await fetch()\n```\n\n## 2. Thread Safety Issues\n```python\n# WRONG - Race condition\ncounter = 0\n\ndef increment():\n    global counter\n    counter += 1  # Not thread-safe!\n\n# CORRECT\nimport threading\n\nlock = threading.Lock()\ncounter = 0\n\ndef increment():\n    global counter\n    with lock:\n        counter += 1\n```\n\n## 3. Type Hint Misuse\n```python\n# WRONG - Runtime type checking doesn't happen automatically\ndef greet(name: str) -> str:\n    return name\n\ngreet(123)  # No error! Type hints are for static analysis\n\n# Use mypy or runtime validation if needed\n```\n\n## 4. Metaclass Conflicts\n```python\n# WRONG - Multiple metaclasses\nclass Meta1(type):\n    pass\n\nclass Meta2(type):\n    pass\n\nclass MyClass(metaclass=Meta1, metaclass=Meta2):  # Error!\n    pass\n```\n\n## 5. Descriptor Errors\n```python\n# WRONG - Forgetting __set_name__\nclass Descriptor:\n    def __get__(self, obj, objtype=None):\n        return getattr(obj, self.name)  # self.name not set!\n\n# CORRECT\nclass Descriptor:\n    def __set_name__(self, owner, name):\n        self.name = f\"_{name}\"\n```\n"}, {"id": "Python_Theory/17_Advanced_Topics/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/17_Advanced_Topics/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "17 Advanced Topics"], "content": "# Practice Questions - Advanced Topics\n\n## Questions\n\n### Q1: Async HTTP Requests\nCreate an async function that fetches multiple URLs concurrently.\n\n### Q2: Thread-Safe Counter\nImplement a thread-safe counter class.\n\n### Q3: Custom Context Manager\nCreate a context manager that logs entry and exit times.\n\n### Q4: Type-Hinted Function\nWrite a function with proper type hints for a generic sorting function.\n\n### Q5: Singleton Pattern\nImplement a singleton using a metaclass.\n\n---\n\n## Solutions\n\n### A1: Async HTTP Requests\n```python\nimport asyncio\n\nasync def fetch_url(url):\n    # Simulated fetch\n    await asyncio.sleep(1)\n    return f\"Content from {url}\"\n\nasync def fetch_all(urls):\n    tasks = [fetch_url(url) for url in urls]\n    return await asyncio.gather(*tasks)\n\nurls = ['http://example.com', 'http://example.org']\nresults = asyncio.run(fetch_all(urls))\n```\n\n### A2: Thread-Safe Counter\n```python\nimport threading\n\nclass ThreadSafeCounter:\n    def __init__(self):\n        self._value = 0\n        self._lock = threading.Lock()\n    \n    def increment(self):\n        with self._lock:\n            self._value += 1\n    \n    def value(self):\n        with self._lock:\n            return self._value\n```\n\n### A3: Custom Context Manager\n```python\nimport time\nfrom contextlib import contextmanager\n\n@contextmanager\ndef log_time(name):\n    start = time.time()\n    print(f\"{name} started\")\n    try:\n        yield\n    finally:\n        end = time.time()\n        print(f\"{name} finished in {end-start:.2f}s\")\n\nwith log_time(\"Operation\"):\n    time.sleep(1)\n```\n\n### A4: Type-Hinted Function\n```python\nfrom typing import List, TypeVar, Callable\n\nT = TypeVar('T')\n\ndef sort_by(items: List[T], key: Callable[[T], int]) -> List[T]:\n    return sorted(items, key=key)\n\n# Usage\nnumbers = [3, 1, 4, 1, 5]\nsorted_nums = sort_by(numbers, key=lambda x: x)\n```\n\n### A5: Singleton Pattern\n```python\nclass SingletonMeta(type):\n    _instances = {}\n    \n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=SingletonMeta):\n    def __init__(self):\n        print(\"Creating database connection\")\n\ndb1 = Database()  # Creates instance\ndb2 = Database()  # Returns same instance\nprint(db1 is db2)  # True\n```\n"}, {"id": "nunpy/numpy arry indexing/main.py", "title": "main", "type": "Code", "path": "nunpy/numpy arry indexing/main.py", "breadcrumbs": ["nunpy", "numpy arry indexing"], "content": "\"\"\"\n=============================================================================\n                    NUMPY ARRAY INDEXING - COMPLETE GUIDE\n=============================================================================\nIndexing is the method to select a single or a group of elements from an array.\nNumPy offers various indexing techniques for different use cases.\n=============================================================================\n\"\"\"\n\nimport numpy as np\n\n# =============================================================================\n# 1. BASIC INDEXING (Access single elements)\n# =============================================================================\nprint(\"=\" * 75)\nprint(\"1. BASIC INDEXING - Access single elements\")\nprint(\"=\" * 75)\n\n# 1D Array\narr1d = np.array([10, 20, 30, 40, 50])\nprint(f\"\\n1D Array: {arr1d}\")\nprint(f\"First element (index 0): {arr1d[0]}\")      # Output: 10\nprint(f\"Second element (index 1): {arr1d[1]}\")     # Output: 20\nprint(f\"Element at index 3: {arr1d[3]}\")           # Output: 40\n\n# 2D Array\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(f\"\\n2D Array:\\n{arr2d}\")\nprint(f\"Element at row 0, col 1: {arr2d[0, 1]}\")   # Output: 2\nprint(f\"Element at row 2, col 2: {arr2d[2, 2]}\")   # Output: 9\n\n# 3D Array\narr3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nprint(f\"\\n3D Array:\\n{arr3d}\")\nprint(f\"Element at [0, 1, 0]: {arr3d[0, 1, 0]}\")   # Output: 3\nprint(f\"Element at [1, 0, 1]: {arr3d[1, 0, 1]}\")   # Output: 6\n\n# =============================================================================\n# 2. NEGATIVE INDEXING (Access from the end)\n# =============================================================================\nprint(\"\\n\" + \"=\" * 75)\nprint(\"2. NEGATIVE INDEXING - Count from the end (last element is -1)\")\nprint(\"=\" * 75)\n\narr = np.array([10, 20, 30, 40, 50])\nprint(f\"\\nArray: {arr}\")\nprint(f\"Last element (index -1): {arr[-1]}\")       # Output: 50\nprint(f\"Second last element (index -2): {arr[-2]}\") # Output: 40\n\nprint(f\"\\n2D Array:\\n{arr2d}\")\nprint(f\"Last element of last row: {arr2d[-1, -1]}\") # Output: 9\nprint(f\"First element of last row: {arr2d[-1, 0]}\") # Output: 7\n\n# =============================================================================\n# 3. SLICING (Extract a range of elements)\n# =============================================================================\nprint(\"\\n\" + \"=\" * 75)\nprint(\"3. SLICING - Extract consecutive elements (start:stop:step)\")\nprint(\"=\" * 75)\n\narr = np.array([10, 20, 30, 40, 50, 60, 70])\nprint(f\"\\nArray: {arr}\")\nprint(f\"arr[1:4] (elements at index 1, 2, 3): {arr[1:4]}\")        # [20 30 40]\nprint(f\"arr[::2] (every 2nd element): {arr[::2]}\")                # [10 30 50 70]\nprint(f\"arr[::-1] (reverse array): {arr[::-1]}\")                  # [70 60 50 40 30 20 10]\nprint(f\"arr[2:] (from index 2 to end): {arr[2:]}\")                # [30 40 50 60 70]\nprint(f\"arr[:3] (first 3 elements): {arr[:3]}\")                   # [10 20 30]\n\n# 2D Slicing\nprint(f\"\\n2D Array:\\n{arr2d}\")\nprint(f\"arr2d[0:2, 1:3] (rows 0-1, columns 1-2):\\n{arr2d[0:2, 1:3]}\")  # [[2 3]\n                                                                       #  [5 6]]\nprint(f\"arr2d[:, 1] (all rows, column 1): {arr2d[:, 1]}\")         # [2 5 8]\nprint(f\"arr2d[1, :] (row 1, all columns): {arr2d[1, :]}\")         # [4 5 6]\n\n# =============================================================================\n# 4. BOOLEAN INDEXING (Filter elements using conditions)\n# =============================================================================\nprint(\"\\n\" + \"=\" * 75)\nprint(\"4. BOOLEAN INDEXING - Select elements matching a condition\")\nprint(\"=\" * 75)\n\narr = np.array([10, 20, 30, 40, 50, 60])\nprint(f\"\\nArray: {arr}\")\nprint(f\"Elements > 30: {arr[arr > 30]}\")            # [40 50 60]\nprint(f\"Elements == 30: {arr[arr == 30]}\")          # [30]\nprint(f\"Elements <= 25: {arr[arr <= 25]}\")          # [10 20]\n\n# Multiple conditions (use & for AND, | for OR)\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(f\"\\n2D Array:\\n{arr2d}\")\nprint(f\"Elements > 2 AND < 8: {arr2d[(arr2d > 2) & (arr2d < 8)]}\")  # [3 4 5 6 7]\nprint(f\"Elements == 2 OR == 5: {arr2d[(arr2d == 2) | (arr2d == 5)]}\")  # [2 5]\nprint(f\"Even elements (% 2 == 0): {arr2d[arr2d % 2 == 0]}\")        # [2 4 6 8]\n\n# =============================================================================\n# 5. FANCY INDEXING (Access multiple elements using index arrays)\n# =============================================================================\nprint(\"\\n\" + \"=\" * 75)\nprint(\"5. FANCY INDEXING - Access elements using index lists/arrays\")\nprint(\"=\" * 75)\n\narr = np.array([10, 20, 30, 40, 50])\nprint(f\"\\nArray: {arr}\")\nindices = [0, 2, 4]\nprint(f\"Access indices [0, 2, 4]: {arr[indices]}\")  # [10 30 50]\n\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(f\"\\n2D Array:\\n{arr2d}\")\nrow_indices = [0, 1, 2]\ncol_indices = [2, 1, 0]\nprint(f\"Fancy index with row_indices=[0,1,2], col_indices=[2,1,0]:\")\nprint(f\"Elements: {arr2d[row_indices, col_indices]}\")  # [3 5 7]\n\n# =============================================================================\n# 6. ELLIPSIS (...) INDEXING (Represent multiple colons)\n# =============================================================================\nprint(\"\\n\" + \"=\" * 75)\nprint(\"6. ELLIPSIS (...) INDEXING - Shorthand for multiple colons\")\nprint(\"=\" * 75)\n\narr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\nprint(f\"\\n3D Array shape (2, 2, 3):\\n{arr3d}\")\nprint(f\"arr3d[..., 0] (all elements, last column): {arr3d[..., 0]}\")  # [[1 4] [7 10]]\nprint(f\"arr3d[1, ...] (last block, all elements):\\n{arr3d[1, ...]}\")  # [[7 8 9] [10 11 12]]\nprint(f\"arr3d[..., 1] (all elements, middle column): {arr3d[..., 1]}\")  # [[2 5] [8 11]]\n\n# =============================================================================\n# 7. MODIFYING ELEMENTS (Update array values using indexing)\n# =============================================================================\nprint(\"\\n\" + \"=\" * 75)\nprint(\"7. MODIFYING ELEMENTS - Update values using indexing\")\nprint(\"=\" * 75)\n\n# Single element\narr = np.array([10, 20, 30, 40, 50])\nprint(f\"\\nOriginal 1D: {arr}\")\narr[2] = 999\nprint(f\"After arr[2] = 999: {arr}\")\n\n# Multiple elements via slicing\narr = np.array([10, 20, 30, 40, 50])\narr[1:4] = [100, 200, 300]\nprint(f\"After arr[1:4] = [100, 200, 300]: {arr}\")\n\n# 2D modification\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(f\"\\nOriginal 2D:\\n{arr2d}\")\narr2d[1, :] = [40, 50, 60]\nprint(f\"After arr2d[1, :] = [40, 50, 60]:\\n{arr2d}\")\n\n# Boolean indexing modification\narr = np.array([10, 20, 30, 40, 50])\narr[arr > 25] = 999\nprint(f\"\\nModify elements > 25 to 999: {arr}\")\n\n# =============================================================================\n# 8. COPY VS VIEW (Understanding data relationships)\n# =============================================================================\nprint(\"\\n\" + \"=\" * 75)\nprint(\"8. COPY VS VIEW - Understanding reference vs independent copy\")\nprint(\"=\" * 75)\n\noriginal = np.array([1, 2, 3, 4, 5])\n\n# View (reference to original data)\nview = original[1:4]\nprint(f\"\\nOriginal: {original}\")\nprint(f\"View (view = original[1:4]): {view}\")\noriginal[2] = 999\nprint(f\"After original[2] = 999:\")\nprint(f\"  Original: {original}\")\nprint(f\"  View: {view}\")  # View reflects the change!\n\n# Copy (independent data)\noriginal = np.array([1, 2, 3, 4, 5])\ncopy = original[1:4].copy()\nprint(f\"\\nOriginal: {original}\")\nprint(f\"Copy (copy = original[1:4].copy()): {copy}\")\noriginal[2] = 999\nprint(f\"After original[2] = 999:\")\nprint(f\"  Original: {original}\")\nprint(f\"  Copy: {copy}\")  # Copy is unchanged!\n\n# =============================================================================\n# 9. ADVANCED COMBINATIONS (Mix different indexing methods)\n# =============================================================================\nprint(\"\\n\" + \"=\" * 75)\nprint(\"9. ADVANCED COMBINATIONS - Mix different indexing techniques\")\nprint(\"=\" * 75)\n\narr3d = np.arange(24).reshape(2, 3, 4)\nprint(f\"\\n3D Array shape (2, 3, 4):\\n{arr3d}\")\n\n# Slice + basic indexing\nprint(f\"\\narr3d[0, 1:, 2] (block 0, rows 1+, col 2): {arr3d[0, 1:, 2]}\")\n\n# Slice + fancy indexing\nprint(f\"arr3d[0, [0, 2], 1:3]:\\n{arr3d[0, [0, 2], 1:3]}\")\n\n# Boolean + slicing\narr = np.array([10, 20, 30, 40, 50, 60])\nmask = arr > 20\nprint(f\"\\nArray: {arr}\")\nprint(f\"Elements > 20, then reverse: {arr[mask][::-1]}\")\n\nprint(\"\\n\" + \"=\" * 75)\nprint(\"INDEXING REFERENCE COMPLETE\")\nprint(\"=\" * 75)"}, {"id": "nunpy/numpy_creating arry/main.py", "title": "main", "type": "Code", "path": "nunpy/numpy_creating arry/main.py", "breadcrumbs": ["nunpy", "numpy creating arry"], "content": "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nprint(arr)\narr = np.array((1, 2, 3, 4, 5))\n\nprint(arr)\n# it give type of array\nprint(type(arr))\n# it give shape of array\nprint(arr.shape)\n#  it give datatype of array\nprint(arr.dtype)\n# it give dimension of array\nprint(arr.ndim)\n# type of array\n# 0d array\narr0d = np.array(42)\nprint(arr0d)\n# 1d array\narr1d = np.array([1, 2, 3, 4, 5])\nprint(arr1d)\n# 2d array\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2d)\n# 3d array\narr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\nprint(arr3d)\nprint(\"0d array dimension:\", arr0d.ndim)\nprint(\"1d array dimension:\", arr1d.ndim)\nprint(\"2d array dimension:\", arr2d.ndim)\nprint(\"3d array dimension:\", arr3d.ndim)\n\n\n#  higher dimension array\narr4d = np.array([[[[1, 2], [3, 4]], [[5, 6], [7, 8]]],\n                   [[[9, 10], [11, 12]], [[13, 14], [15, 16]]]])\nprint(arr4d)\nprint(\"4d array dimension:\", arr4d.ndim)\n\n# Higher Dimensional Array\n# it define minimum dimension of array\n# how it work\n# it will convert 1d array into 5d array\n\narr = np.array([1, 2, 3, 4], ndmin=5)\n\nprint(arr)\nprint('number of dimensions :', arr.ndim)\n"}, {"id": "nunpy/keypad.py", "title": "keypad", "type": "Code", "path": "nunpy/keypad.py", "breadcrumbs": ["nunpy"], "content": "class KeypadSequence:\n    def __init__(self):\n        self.keypad = {\n            'A': '2', 'B': '22', 'C': '222',\n            'D': '3', 'E': '33', 'F': '333',\n            'G': '4', 'H': '44', 'I': '444',\n            'J': '5', 'K': '55', 'L': '555',\n            'M': '6', 'N': '66', 'O': '666',\n            'P': '7', 'Q': '77', 'R': '777', 'S': '7777',\n            'T': '8', 'U': '88', 'V': '888',\n            'W': '9', 'X': '99', 'Y': '999', 'Z': '9999',\n            ' ': '0'\n        }\n\n    def convert(self, text):\n        result = \"\"\n        for char in text.upper():\n            result += self.keypad.get(char, \"\")\n        return result\n\n\n# Create instance and test\nkeypad = KeypadSequence()\nprint(keypad.convert(\"HELLO\"))  \nprint(keypad.convert(\"SONU\"))\n"}, {"id": "nunpy/new.py", "title": "new", "type": "Code", "path": "nunpy/new.py", "breadcrumbs": ["nunpy"], "content": "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nprint(arr)"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/all_pairs_shortest_paths_floyd_warshall.py", "title": "all pairs shortest paths floyd warshall", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/all_pairs_shortest_paths_floyd_warshall.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Floyd-Warshall Algorithm\nTopic: Advanced Graphs\n\nTheory:\n    All-Pairs Shortest Path.\n    Dynamic Programming approach.\n    Computes shortest path between every pair of vertices.\n    \n    Complexity: O(V^3).\n\"\"\"\n\ndef floyd_warshall(graph_matrix):\n    \"\"\"\n    Input: graph_matrix[i][j] = weight. infinity if no edge. 0 if i==j.\n    Returns: dist matrix with shortest paths.\n    \"\"\"\n    V = len(graph_matrix)\n    # Deep copy\n    dist = [row[:] for row in graph_matrix]\n    \n    for k in range(V): # Intermediate node\n        for i in range(V): # Source\n            for j in range(V): # Destination\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n                \n    return dist\n\ndef run_tests():\n    INF = float('inf')\n    # Graph:\n    # 0 -> 1 (5)\n    # 0 -> 3 (10)\n    # 1 -> 2 (3)\n    # 2 -> 3 (1)\n    \n    matrix = [\n        [0, 5, INF, 10],\n        [INF, 0, 3, INF],\n        [INF, INF, 0, 1],\n        [INF, INF, INF, 0]\n    ]\n    \n    res = floyd_warshall(matrix)\n    \n    # Path 0 -> 3:\n    # Direct: 10\n    # Via 1,2: 0->1(5) -> 2(3) -> 3(1) = 9\n    assert res[0][3] == 9\n    \n    print(\"[PASS] Floyd-Warshall\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/articulation_points_and_bridges.py", "title": "articulation points and bridges", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/articulation_points_and_bridges.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Articulation Points and Bridges\nTopic: Advanced Graphs\n\nTheory:\n    Articulation Point (Cut Vertex): Removing it increases connected components.\n    Bridge (Cut Edge): Removing it increases CCs.\n    \n    Algorithm: DFS based (Tarjan's logic variant).\n    - `disc`: discovery time.\n    - `low`: lowest point reachable via back-edge.\n    - Condition Bridge: `low[v] > disc[u]`\n    - Condition AP: `low[v] >= disc[u]` (plus root check)\n\"\"\"\n\nclass GraphBridges:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.time = 0\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def find_bridges(self):\n        disc = [-1] * self.V\n        low = [-1] * self.V\n        parent = [-1] * self.V\n        bridges = []\n        \n        def dfs(u):\n            disc[u] = self.time\n            low[u] = self.time\n            self.time += 1\n            \n            for v in self.adj[u]:\n                if v == parent[u]:\n                    continue\n                if disc[v] != -1:\n                    low[u] = min(low[u], disc[v])\n                else:\n                    parent[v] = u\n                    dfs(v)\n                    low[u] = min(low[u], low[v])\n                    if low[v] > disc[u]:\n                        bridges.append((u, v))\n        \n        for i in range(self.V):\n            if disc[i] == -1:\n                dfs(i)\n        return bridges\n\ndef run_tests():\n    # 0--1--2\n    # | /   |\n    # 3     4\n    #       |\n    #       5\n    g = GraphBridges(6)\n    g.add_edge(0, 1)\n    g.add_edge(1, 2)\n    g.add_edge(2, 0) # 0-1-2 Triangle\n    g.add_edge(0, 3) # 3 is leaf\n    g.add_edge(2, 4) # Bridge to 4\n    g.add_edge(4, 5) # Bridge to 5\n    \n    bridges = g.find_bridges()\n    # Expect (0,3), (2,4), (4,5) (Order varies)\n    \n    # Normalize for check\n    normalized = []\n    for u, v in bridges:\n        normalized.append(tuple(sorted((u, v))))\n        \n    assert (0, 3) in normalized\n    assert (2, 4) in normalized\n    assert (4, 5) in normalized\n    assert (0, 1) not in normalized # Cycle edge\n    \n    print(\"[PASS] Bridges detection\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/eulerian_and_hamiltonian_paths_basics.py", "title": "eulerian and hamiltonian paths basics", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/eulerian_and_hamiltonian_paths_basics.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Eulerian and Hamiltonian Paths\nTopic: Advanced Graphs\n\nTheory:\n    Eulerian Path: Visits every EDGE exactly once.\n    - Cond: 0 or 2 vertices have odd degree. All non-zero degree vertices connected.\n    \n    Eulerian Circuit: Starts and ends same vertex.\n    - Cond: All vertices have even degree.\n    \n    Hamiltonian Path: Visits every VERTEX exactly once.\n    - NP-Complete problem generally. Backtracking is best approach.\n\"\"\"\n\ndef is_eulerian_path_possible(n, edges):\n    degree = [0] * n\n    for u, v in edges:\n        degree[u] += 1\n        degree[v] += 1 # Undirected\n        \n    odd_count = 0\n    for d in degree:\n        if d % 2 != 0:\n            odd_count += 1\n            \n    if odd_count == 0:\n        return \"Circuit\"\n    elif odd_count == 2:\n        return \"Path\"\n    else:\n        return \"None\"\n\ndef run_tests():\n    # Square: 0-1, 1-2, 2-3, 3-0. All degree 2. Circuit.\n    edges_sq = [(0,1), (1,2), (2,3), (3,0)]\n    assert is_eulerian_path_possible(4, edges_sq) == \"Circuit\"\n    \n    # Line: 0-1-2. 0(1), 1(2), 2(1). Odd=2. Path.\n    edges_line = [(0,1), (1,2)]\n    assert is_eulerian_path_possible(3, edges_line) == \"Path\"\n\n    # Star: Center 0 con to 1,2,3. 0(3), others(1). Odd=4. None.\n    edges_star = [(0,1), (0,2), (0,3)]\n    assert is_eulerian_path_possible(4, edges_star) == \"None\"\n    \n    print(\"[PASS] Eulerian Logic\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/graphs_bfs_dfs.py", "title": "graphs bfs dfs", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/graphs_bfs_dfs.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Graph Traversals (BFS & DFS)\nTopic: Advanced Graphs\n\nTheory:\n    BFS (Breadth First Search):\n    - Uses Queue.\n    - Exploration level by level.\n    - Application: Shortest Path in unweighted graph.\n    - Complexity: O(V + E).\n\n    DFS (Depth First Search):\n    - Uses Stack (Recursion).\n    - Exploration deep into branches.\n    - Application: Cycle detection, Path finding, Topological Sort logic.\n    - Complexity: O(V + E).\n\"\"\"\n\nfrom collections import deque\n\nclass Graph:\n    def __init__(self, edges, bidirectional=True):\n        self.adj = {}\n        for u, v in edges:\n            self.add_edge(u, v, bidirectional)\n\n    def add_edge(self, u, v, bidirectional):\n        if u not in self.adj: self.adj[u] = []\n        if v not in self.adj: self.adj[v] = []\n        \n        self.adj[u].append(v)\n        if bidirectional:\n            self.adj[v].append(u)\n\n    def bfs(self, start):\n        visited = set()\n        queue = deque([start])\n        visited.add(start)\n        traversal = []\n        \n        while queue:\n            node = queue.popleft()\n            traversal.append(node)\n            \n            # Neighbors\n            for neighbor in self.adj.get(node, []):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        return traversal\n\n    def dfs(self, start):\n        visited = set()\n        traversal = []\n        self._dfs_recursive(start, visited, traversal)\n        return traversal\n\n    def _dfs_recursive(self, node, visited, traversal):\n        visited.add(node)\n        traversal.append(node)\n        \n        for neighbor in self.adj.get(node, []):\n            if neighbor not in visited:\n                self._dfs_recursive(neighbor, visited, traversal)\n\ndef run_tests():\n    # 0 -- 1\n    # |    |\n    # 2 -- 3 -- 4\n    edges = [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4)]\n    g = Graph(edges)\n    \n    bfs_res = g.bfs(0)\n    # BFS from 0: 0, then 1,2, then 3, then 4\n    # Note: Neighbor order depends on list, assume sorted insertion or specific order in test:\n    # Neighbors of 0: 1, 2\n    # Neighbors of 1: 0, 3\n    # Neighbors of 2: 0, 3\n    # Neighbors of 3: 1, 2, 4\n    assert bfs_res[0] == 0\n    assert 1 in bfs_res[1:3] and 2 in bfs_res[1:3]\n    assert 4 == bfs_res[-1]\n    \n    dfs_res = g.dfs(0)\n    assert dfs_res[0] == 0\n    assert len(dfs_res) == 5\n    \n    print(\"[PASS] BFS and DFS\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/minimum_spanning_tree_kruskal.py", "title": "minimum spanning tree kruskal", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/minimum_spanning_tree_kruskal.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Minimum Spanning Tree (Kruskal's Algorithm)\nTopic: Advanced Graphs\n\nTheory:\n    Finds MST of a connected, undirected, weighted graph.\n    Greedy approach:\n    1. Sort all edges by weight.\n    2. Add edge if it doesn't form a cycle (Use DSU).\n    \n    Complexity: O(E log E) or O(E log V).\n\"\"\"\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            if self.rank[root_i] < self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n            return True\n        return False\n\ndef kruskal(n, edges):\n    # edges: list of (u, v, weight)\n    # Sort by weight\n    edges.sort(key=lambda x: x[2])\n    \n    dsu = DSU(n)\n    mst = []\n    mst_weight = 0\n    \n    for u, v, w in edges:\n        if dsu.union(u, v):\n            mst.append((u, v, w))\n            mst_weight += w\n            \n    return mst, mst_weight\n\ndef run_tests():\n    # 0 --1-- 1\n    # |       |\n    # 3       1\n    # |       |\n    # 2 --1-- 3\n    \n    # Cycle 0-1-3-2-0.\n    edges = [\n        (0, 1, 1),\n        (1, 3, 1),\n        (2, 3, 1),\n        (0, 2, 3) # Expensive edge\n    ]\n    # Vertices: 0, 1, 2, 3 (n=4)\n    # MST should pick the three 1-weight edges. Total 3.\n    \n    mst, weight = kruskal(4, edges)\n    \n    assert weight == 3\n    assert len(mst) == 3\n    # Ensure expensive edge not in MST\n    assert (0, 2, 3) not in mst\n    \n    print(\"[PASS] Kruskal MST\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/minimum_spanning_tree_prim.py", "title": "minimum spanning tree prim", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/minimum_spanning_tree_prim.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Minimum Spanning Tree (Prim's Algorithm)\nTopic: Advanced Graphs\n\nTheory:\n    Greedy approach.\n    Start from a vertex, grow the tree by adding nearest vertex not yet in tree.\n    Uses Priority Queue.\n    \n    Complexity: O(E log V) with Binary Heap.\n\"\"\"\n\nimport heapq\n\ndef prim(n, graph):\n    # graph: {u: [(v, weight), ...]}\n    # n: number of vertices, assumed 0 to n-1\n    \n    start_node = 0\n    pq = [(0, start_node, -1)] # (weight, node, parent)\n    visited = [False] * n\n    mst_weight = 0\n    mst_edges = []\n    \n    while pq:\n        w, u, parent = heapq.heappop(pq)\n        \n        if visited[u]:\n            continue\n            \n        visited[u] = True\n        mst_weight += w\n        if parent != -1:\n            mst_edges.append((parent, u, w))\n            \n        for v, weight in graph.get(u, []):\n            if not visited[v]:\n                heapq.heappush(pq, (weight, v, u))\n                \n    return mst_edges, mst_weight\n\ndef run_tests():\n    # Same graph\n    # 0: (1,1), (2,3)\n    # 1: (0,1), (3,1)\n    # 2: (0,3), (3,1)\n    # 3: (1,1), (2,1)\n    \n    graph = {\n        0: [(1, 1), (2, 3)],\n        1: [(0, 1), (3, 1)],\n        2: [(0, 3), (3, 1)],\n        3: [(1, 1), (2, 1)]\n    }\n    \n    edges, weight = prim(4, graph)\n    \n    assert weight == 3\n    # Check edges exist\n    # 0-1 (1), 1-3 (1), 3-2 (1) is a valid path picking order\n    # Edges: (0,1,1), (1,3,1), (3,2,1)\n    \n    print(\"[PASS] Prim MST\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/shortest_paths_bellman_ford.py", "title": "shortest paths bellman ford", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/shortest_paths_bellman_ford.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Bellman-Ford Algorithm\nTopic: Advanced Graphs\n\nTheory:\n    Finds shortest paths from source to all vertices.\n    Can handle NEGATIVE weights.\n    Detects Negative Cycles.\n    \n    Algorithm: Relax all E edges, V-1 times.\n    \n    Complexity: O(V * E).\n\"\"\"\n\ndef bellman_ford(vertices, edges, start):\n    # edges: list of (u, v, weight)\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    \n    # Relax V-1 times\n    for _ in range(len(vertices) - 1):\n        for u, v, w in edges:\n            if distances[u] != float('inf') and distances[u] + w < distances[v]:\n                distances[v] = distances[u] + w\n                \n    # Detect negative cycle\n    for u, v, w in edges:\n        if distances[u] != float('inf') and distances[u] + w < distances[v]:\n            raise ValueError(\"Negative Cycle Detected\")\n            \n    return distances\n\ndef run_tests():\n    vertices = ['A', 'B', 'C']\n    edges = [\n        ('A', 'B', -1),\n        ('B', 'C', 2),\n        ('C', 'A', 4) # Cycle A->B->C->A cost: -1+2+4 = 5 (Positive cycle OK)\n    ]\n    \n    dists = bellman_ford(vertices, edges, 'A')\n    assert dists['B'] == -1\n    assert dists['C'] == 1\n    \n    # Negative Cycle Case\n    bad_edges = [\n        ('A', 'B', 1),\n        ('B', 'C', -5),\n        ('C', 'A', 2) # 1 - 5 + 2 = -2 (Negative Cycle)\n    ]\n    try:\n        bellman_ford(vertices, bad_edges, 'A')\n    except ValueError as e:\n        print(f\"Caught expected error: {e}\")\n\n    print(\"[PASS] Bellman-Ford\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/shortest_paths_dijkstra.py", "title": "shortest paths dijkstra", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/shortest_paths_dijkstra.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Dijkstra's Algorithm (Shortest Path)\nTopic: Advanced Graphs\n\nTheory:\n    Finds shortest paths from source to all other vertices in a weighted graph with NON-NEGATIVE weights.\n    Uses Priority Queue (Min-Heap).\n    \n    Complexity: O((V + E) log V) with Binary Heap.\n\"\"\"\n\nimport heapq\n\ndef dijkstra(graph, start):\n    # graph: dict {u: [(v, weight), ...]}\n    \n    # Priority Queue: stores (dist, u)\n    pq = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        \n        # Optimization: Early exit if we found a shorter path to u already\n        if d > distances[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            if distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                heapq.heappush(pq, (distances[v], v))\n                \n    return distances\n\ndef run_tests():\n    # A --1-- B\n    # |       |\n    # 4       2\n    # |       |\n    # C --3-- D\n    \n    graph = {\n        'A': [('B', 1), ('C', 4)],\n        'B': [('A', 1), ('D', 2)],\n        'C': [('A', 4), ('D', 3)],\n        'D': [('B', 2), ('C', 3)]\n    }\n    \n    dists = dijkstra(graph, 'A')\n    \n    assert dists['A'] == 0\n    assert dists['B'] == 1\n    assert dists['C'] == 4 # Direct path A->C\n    # Wait, A->B->D->C = 1 + 2 + 3 = 6. Direct is 4.\n    \n    assert dists['D'] == 3 # A->B->D = 1+2 = 3\n    \n    print(\"[PASS] Dijkstra Algorithm\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/strongly_connected_components_kosaraju.py", "title": "strongly connected components kosaraju", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/strongly_connected_components_kosaraju.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Strongly Connected Components (Kosaraju's Algorithm)\nTopic: Advanced Graphs\n\nTheory:\n    Finds SCCs in a directed graph.\n    Logic:\n    1. Perform DFS and store vertices in stack by finish time.\n    2. Transpose the graph (reverse edges).\n    3. Pop from stack and perform DFS on Transposed graph.\n    \n    Complexity: O(V + E).\n\"\"\"\n\nfrom collections import defaultdict\n\nclass KosarajuSCC:\n    def __init__(self, V):\n        self.V = V\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n    \n    def _fill_order(self, v, visited, stack):\n        visited.add(v)\n        for i in self.adj[v]:\n            if i not in visited:\n                self._fill_order(i, visited, stack)\n        stack.append(v)\n    \n    def _get_transpose(self):\n        g = KosarajuSCC(self.V)\n        for i in self.adj:\n            for j in self.adj[i]:\n                g.add_edge(j, i)\n        return g\n    \n    def _dfs_util(self, v, visited, component):\n        visited.add(v)\n        component.append(v)\n        for i in self.adj[v]:\n            if i not in visited:\n                self._dfs_util(i, visited, component)\n                \n    def get_sccs(self):\n        stack = []\n        visited = set()\n        \n        # 1. Fill Stack\n        for i in range(self.V):\n            if i not in visited:\n                self._fill_order(i, visited, stack)\n                \n        # 2. Transpose\n        gr = self._get_transpose()\n        \n        # 3. Process Stack\n        visited = set()\n        sccs = []\n        \n        while stack:\n            i = stack.pop()\n            if i not in visited:\n                component = []\n                gr._dfs_util(i, visited, component)\n                sccs.append(component)\n        return sccs\n\ndef run_tests():\n    # 0->2, 2->1, 1->0 (SCC 0,1,2)\n    # 0->3, 3->4 (SCC 3, 4 separate)\n    g = KosarajuSCC(5)\n    g.add_edge(0, 2)\n    g.add_edge(2, 1)\n    g.add_edge(1, 0)\n    g.add_edge(0, 3)\n    g.add_edge(3, 4)\n    \n    sccs = g.get_sccs()\n    \n    # Sort for checking\n    sccs = [sorted(c) for c in sccs]\n    # We expect [[0,1,2], [3], [4]] or similar order\n    assert [0, 1, 2] in sccs\n    assert [3] in sccs\n    assert [4] in sccs\n    \n    print(\"[PASS] Kosaraju SCC\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/strongly_connected_components_tarjan.py", "title": "strongly connected components tarjan", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/strongly_connected_components_tarjan.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Strongly Connected Components (Tarjan's Algorithm)\nTopic: Advanced Graphs\n\nTheory:\n    Finds SCCs in one DFS pass.\n    Maintains `discovery_time` and `low_link` value for each node.\n    \n    low_link[u] = lowest discovery time reachable from u (including back-edges in stack).\n    If low_link[u] == disc[u], u is root of an SCC.\n    \n    Complexity: O(V + E).\n\"\"\"\n\nclass TarjanSCC:\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for _ in range(V)]\n        self.time = 0\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        \n    def _scc_util(self, u, low, disc, stack_member, stack, start_node=None): \n        # Note: start_node not really needed inside, just standard logic\n        disc[u] = self.time\n        low[u] = self.time\n        self.time += 1\n        stack_member[u] = True\n        stack.append(u)\n        \n        for v in self.adj[u]:\n            if disc[v] == -1: # Not visited\n                self._scc_util(v, low, disc, stack_member, stack)\n                low[u] = min(low[u], low[v])\n            elif stack_member[v]: # Back-edge\n                low[u] = min(low[u], disc[v])\n                \n        # Head of SCC\n        if low[u] == disc[u]:\n            w = -1\n            component = []\n            while w != u:\n                w = stack.pop()\n                component.append(w)\n                stack_member[w] = False\n            self.sccs.append(component)\n\n    def find_sccs(self):\n        disc = [-1] * self.V\n        low = [-1] * self.V\n        stack_member = [False] * self.V\n        stack = []\n        self.sccs = []\n        \n        for i in range(self.V):\n            if disc[i] == -1:\n                self._scc_util(i, low, disc, stack_member, stack)\n        return self.sccs\n\ndef run_tests():\n    g = TarjanSCC(5)\n    g.add_edge(1, 0)\n    g.add_edge(0, 2)\n    g.add_edge(2, 1)\n    g.add_edge(0, 3)\n    g.add_edge(3, 4)\n    \n    sccs = g.find_sccs()\n    sccs = [sorted(c) for c in sccs]\n    \n    assert [0, 1, 2] in sccs\n    assert [3] in sccs\n    assert [4] in sccs\n    \n    print(\"[PASS] Tarjan SCC\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/topological_sort_kahn_and_dfs.py", "title": "topological sort kahn and dfs", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Advanced_Graphs/topological_sort_kahn_and_dfs.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Advanced Graphs"], "content": "\"\"\"\nTitle: Topological Sort (Kahn's and DFS)\nTopic: Advanced Graphs\n\nTheory:\n    Linear ordering of vertices in a DAG (Directed Acyclic Graph).\n    For every edge u -> v, u comes before v.\n    \n    Algorithms:\n    1. Kahn's (BFS): Uses in-degrees. Can detect cycles.\n    2. DFS: Use stack (finish time).\n    \n    Complexity: O(V + E).\n\"\"\"\n\nfrom collections import deque\n\ndef kahn_topological_sort(n, adj):\n    in_degree = [0] * n\n    for u in adj:\n        for v in adj[u]:\n            in_degree[v] += 1\n            \n    queue = deque([i for i in range(n) if in_degree[i] == 0])\n    topo_order = []\n    \n    while queue:\n        u = queue.popleft()\n        topo_order.append(u)\n        \n        for v in adj.get(u, []):\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n                \n    if len(topo_order) != n:\n        raise ValueError(\"Graph has a cycle!\")\n        \n    return topo_order\n\ndef run_tests():\n    # 5 -> 2, 5 -> 0\n    # 4 -> 0, 4 -> 1\n    # 2 -> 3\n    # 3 -> 1\n    \n    adj = {\n        5: [2, 0],\n        4: [0, 1],\n        2: [3],\n        3: [1],\n        0: [],\n        1: []\n    }\n    # n=6 (include 0,1,2,3,4,5)\n    \n    order = kahn_topological_sort(6, adj)\n    \n    # Valid order: 5 comes before 2 and 0. 4 comes before 0 and 1. \n    # One valid: 4, 5, 2, 3, 1, 0\n    # Or: 5, 4, 2, 3, 1, 0\n    \n    print(f\"Topo Order: {order}\")\n    \n    # Check dependencies\n    pos = {node: i for i, node in enumerate(order)}\n    assert pos[5] < pos[2]\n    assert pos[2] < pos[3]\n    assert pos[3] < pos[1]\n    \n    print(\"[PASS] Topological Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_n_queens.py", "title": "backtracking n queens", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_n_queens.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Backtracking"], "content": "\"\"\"\nTitle: N-Queens Problem\nTopic: Backtracking\n\nTheory:\n    Place N queens on NxN board such that no two queens attack each other.\n    Constraint: No row, column, or diagonal sharing.\n    \n    Complexity: O(N!).\n\"\"\"\n\ndef solve_n_queens(n):\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    solutions = []\n    \n    # Tracking sets for efficiency\n    cols = set()\n    diag1 = set() # (r - c)\n    diag2 = set() # (r + c)\n    \n    def backtrack(r):\n        if r == n:\n            solutions.append([\"\".join(row) for row in board])\n            return\n        \n        for c in range(n):\n            if c in cols or (r - c) in diag1 or (r + c) in diag2:\n                continue\n                \n            cols.add(c)\n            diag1.add(r - c)\n            diag2.add(r + c)\n            board[r][c] = 'Q'\n            \n            backtrack(r + 1)\n            \n            cols.remove(c)\n            diag1.remove(r - c)\n            diag2.remove(r + c)\n            board[r][c] = '.'\n            \n    backtrack(0)\n    return solutions\n\ndef run_tests():\n    # 4-Queens has 2 distinct solutions\n    sols = solve_n_queens(4)\n    assert len(sols) == 2\n    \n    print(\"[PASS] N-Queens\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_permutations_combinations.py", "title": "backtracking permutations combinations", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_permutations_combinations.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Backtracking"], "content": "\"\"\"\nTitle: Permutations and Combinations (Backtracking)\nTopic: Backtracking\n\nTheory:\n    Permutations: Order matters. (n!)\n    Combinations: Order does not matter. nCk.\n\"\"\"\n\ndef generate_permutations(nums):\n    res = []\n    \n    def backtrack(start):\n        if start == len(nums):\n            res.append(nums[:])\n            return\n        \n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start] # Backtrack\n            \n    backtrack(0)\n    return res\n\ndef generate_combinations(n, k):\n    res = []\n    \n    def backtrack(start, current):\n        if len(current) == k:\n            res.append(current[:])\n            return\n            \n        for i in range(start, n + 1):\n            current.append(i)\n            backtrack(i + 1, current)\n            current.pop()\n            \n    backtrack(1, [])\n    return res\n\ndef run_tests():\n    # Permutations of [1,2] -> [1,2], [2,1]\n    perms = generate_permutations([1, 2])\n    assert len(perms) == 2\n    \n    # Combinations of 4 choose 2 -> 6\n    # (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)\n    combs = generate_combinations(4, 2)\n    assert len(combs) == 6\n    \n    print(\"[PASS] Permutations and Combinations\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_rat_in_a_maze.py", "title": "backtracking rat in a maze", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_rat_in_a_maze.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Backtracking"], "content": "\"\"\"\nTitle: Rat in a Maze\nTopic: Backtracking\n\nTheory:\n    Find a path from source (0,0) to destination (N-1, N-1).\n    Movement allowed: Down, Right (or more).\n    Blockages: 0 (or specific value).\n    \n    Complexity: O(2^(N^2)).\n\"\"\"\n\ndef rat_in_maze(maze):\n    n = len(maze)\n    sol = [[0 for _ in range(n)] for _ in range(n)]\n    \n    if solve_maze_util(maze, 0, 0, sol, n) == False:\n        return []\n    return sol\n\ndef is_safe(maze, x, y, n):\n    return 0 <= x < n and 0 <= y < n and maze[x][y] == 1\n\ndef solve_maze_util(maze, x, y, sol, n):\n    if x == n - 1 and y == n - 1 and maze[x][y] == 1:\n        sol[x][y] = 1\n        return True\n        \n    if is_safe(maze, x, y, n):\n        if sol[x][y] == 1: return False # Already visited\n        \n        sol[x][y] = 1 # Mark\n        \n        # Move Forward (Down)\n        if solve_maze_util(maze, x + 1, y, sol, n): return True\n        # Move Forward (Right)\n        if solve_maze_util(maze, x, y + 1, sol, n): return True\n        \n        sol[x][y] = 0 # Backtrack\n        return False\n        \n    return False\n\ndef run_tests():\n    maze = [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1]\n    ]\n    path = rat_in_maze(maze)\n    # Expected path (1s): (0,0)->(1,0)->(1,1)->(2,1)->(3,1)->(3,2)->(3,3)\n    assert path[0][0] == 1\n    assert path[3][3] == 1\n    assert path[0][1] == 0\n    print(\"[PASS] Rat in Maze\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_subset_generation.py", "title": "backtracking subset generation", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_subset_generation.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Backtracking"], "content": "\"\"\"\nTitle: Subset Generation (Backtracking)\nTopic: Backtracking\n\nTheory:\n    Generate all subsets (Power Set) of a given set.\n    \n    Complexity: O(2^N).\n\"\"\"\n\ndef generate_subsets(nums):\n    res = []\n    \n    def backtrack(start, current_subset):\n        res.append(current_subset[:])\n        \n        for i in range(start, len(nums)):\n            current_subset.append(nums[i])\n            backtrack(i + 1, current_subset)\n            current_subset.pop()\n            \n    backtrack(0, [])\n    return res\n\ndef run_tests():\n    nums = [1, 2, 3]\n    subs = generate_subsets(nums)\n    # Expected length 2^3 = 8\n    # [], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]\n    assert len(subs) == 8\n    assert [] in subs\n    assert [1, 2, 3] in subs\n    \n    print(\"[PASS] Subset Generation\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_sudoku_solver.py", "title": "backtracking sudoku solver", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Backtracking/backtracking_sudoku_solver.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Backtracking"], "content": "\"\"\"\nTitle: Sudoku Solver\nTopic: Backtracking\n\nTheory:\n    Fill 9x9 grid so that each row, column, and 3x3 box contains digits 1-9.\n    \n    Complexity: Exponential.\n\"\"\"\n\ndef solve_sudoku(board):\n    \"\"\"\n    board: List[List[str]] ('.' for empty)\n    Modifies board in-place. Returns True if solved.\n    \"\"\"\n    for r in range(9):\n        for c in range(9):\n            if board[r][c] == '.':\n                for char in \"123456789\":\n                    if is_valid(board, r, c, char):\n                        board[r][c] = char\n                        if solve_sudoku(board):\n                            return True\n                        board[r][c] = '.' # Backtrack\n                return False\n    return True\n\ndef is_valid(board, r, c, char):\n    for i in range(9):\n        if board[r][i] == char: return False\n        if board[i][c] == char: return False\n        if board[3*(r//3) + i//3][3*(c//3) + i%3] == char: return False\n    return True\n\ndef run_tests():\n    board = [\n        [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n        [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n        [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n        [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n        [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n        [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n        [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n        [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n        [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n    ]\n    solve_sudoku(board)\n    assert board[0][2] != \".\"\n    print(\"[PASS] Sudoku Solver\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/recursion_basics_factorial_fibonacci.py", "title": "recursion basics factorial fibonacci", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/recursion_basics_factorial_fibonacci.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Recursion Basics (Factorial, Fibonacci)\nTopic: Algorithms Basics\n\nTheory:\n    Function calling itself.\n    Must have a Base Case to stop.\n    \n    Complexity:\n    - Factorial: O(n) | Stack: O(n).\n    - Fibonacci (Naive): O(2^n) | Stack: O(n).\n    \n    Pitfall: Maximum recursion depth (default 1000 in Python).\n\"\"\"\n\nimport sys\n\n# 1. Factorial\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)\n\n# 2. Fibonacci (Naive)\ndef fib_naive(n):\n    if n <= 1:\n        return n\n    return fib_naive(n-1) + fib_naive(n-2)\n\n# 3. Fibonacci (Memoized)\nmemo = {}\ndef fib_memo(n):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    res = fib_memo(n-1) + fib_memo(n-2)\n    memo[n] = res\n    return res\n\ndef run_tests():\n    assert factorial(5) == 120\n    assert fib_naive(6) == 8 # 0 1 1 2 3 5 8\n    \n    sys.setrecursionlimit(2000)\n    # fib_naive(50) would hang. fib_memo is instant.\n    assert fib_memo(50) == 12586269025\n    \n    print(\"[PASS] Recursion basics\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/recursion_tower_of_hanoi.py", "title": "recursion tower of hanoi", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/recursion_tower_of_hanoi.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Tower of Hanoi\nTopic: Algorithms Basics\n\nTheory:\n    Classic puzzle. Move n disks from Source to Destination using Auxiliary rod.\n    Rules:\n    1. Only one disk at a time.\n    2. No larger disk on top of smaller disk.\n    \n    Complexity: O(2^n).\n\"\"\"\n\ndef tower_of_hanoi(n, source, target, auxiliary, moves):\n    if n == 1:\n        moves.append(f\"Move disk 1 from {source} to {target}\")\n        return\n    \n    tower_of_hanoi(n - 1, source, auxiliary, target, moves)\n    moves.append(f\"Move disk {n} from {source} to {target}\")\n    tower_of_hanoi(n - 1, auxiliary, target, source, moves)\n\ndef run_tests():\n    moves = []\n    tower_of_hanoi(3, 'A', 'C', 'B', moves)\n    \"\"\"\n    Expected for 3:\n    1 A->C\n    2 A->B\n    1 C->B\n    3 A->C\n    1 B->A\n    2 B->C\n    1 A->C\n    \"\"\"\n    assert len(moves) == 7 # 2^3 - 1\n    assert moves[0] == \"Move disk 1 from A to C\"\n    assert moves[-1] == \"Move disk 1 from A to C\" # Actually depends on sequence, but disk 1 does land C last? \n    # Logic: Last move is disk 1 from A to C? No. The biggest disk moves A->C in middle.\n    \n    print(f\"Total moves for 3 disks: {len(moves)}\")\n    print(\"[PASS] Tower of Hanoi\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/searching_binary.py", "title": "searching binary", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/searching_binary.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Binary Search\nTopic: Algorithms Basics\n\nTheory:\n    Divide and Conquer. Repeatedly divide the search interval in half.\n    \n    Pre-condition: Array MUST be sorted.\n    \n    Complexity:\n    - Time: O(log n).\n    - Space: O(1) iterative, O(log n) recursive (stack).\n    \n    Pitfalls:\n    - Infinite loop if `mid` calculation is wrong or bounds don't update correctly.\n    - Overflow: `mid = (low + high) // 2` is safe in Python (auto-large ints), \n      but `low + (high - low) // 2` is safer in fixed-width languages.\n\"\"\"\n\ndef binary_search_iterative(arr, target):\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n            \n    return -1\n\ndef binary_search_recursive(arr, low, high, target):\n    if low > high:\n        return -1\n    \n    mid = (low + high) // 2\n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search_recursive(arr, mid + 1, high, target)\n    else:\n        return binary_search_recursive(arr, low, mid - 1, target)\n\ndef run_tests():\n    data = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n    \n    # Iterative\n    assert binary_search_iterative(data, 30) == 2\n    assert binary_search_iterative(data, 99) == -1\n    \n    # Recursive\n    assert binary_search_recursive(data, 0, len(data)-1, 70) == 6\n    assert binary_search_recursive(data, 0, len(data)-1, 5) == -1\n    \n    print(\"[PASS] Binary Search\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/searching_linear.py", "title": "searching linear", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/searching_linear.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Linear Search\nTopic: Algorithms Basics\n\nTheory:\n    Simplest search algorithm. Iterate through the list until target is found.\n    \n    Complexity:\n    - Time: O(n) worst case.\n    - Space: O(1).\n    \n    Data Requirements:\n    - Data does NOT need to be sorted.\n\"\"\"\n\ndef linear_search(arr, target):\n    \"\"\"\n    Returns index of target if found, else -1.\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\ndef run_tests():\n    data = [10, 50, 30, 70, 80, 20]\n    \n    assert linear_search(data, 30) == 2\n    assert linear_search(data, 99) == -1\n    assert linear_search([], 1) == -1\n    \n    print(\"[PASS] Linear Search\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/sorting_bubble.py", "title": "sorting bubble", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_bubble.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Bubble Sort\nTopic: Algorithms Basics\n\nTheory:\n    Repeatedly swap adjacent elements if they are in wrong order.\n    Largest elements \"bubble\" to the top (end) in each pass.\n    \n    Complexity:\n    - Time: O(n^2).\n    - Space: O(1).\n    \n    Optimization: Stop if no swaps occur in a pass.\n\"\"\"\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        # Last i elements are already in place\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        if not swapped:\n            break\n    return arr\n\ndef run_tests():\n    data = [64, 34, 25, 12, 22, 11, 90]\n    sorted_data = bubble_sort(data.copy())\n    assert sorted_data == sorted(data)\n    \n    print(\"[PASS] Bubble Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/sorting_counting.py", "title": "sorting counting", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_counting.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Counting Sort\nTopic: Algorithms Basics\n\nTheory:\n    Non-comparison based sort.\n    Counts the number of objects having distinct key values.\n    \n    Complexity:\n    - Time: O(n + k) where n is number of elements, k is the range of input.\n    - Space: O(n + k).\n    \n    Constraint:\n    - Efficient only when k is not significantly larger than n.\n    - Typically for positive integers.\n\"\"\"\n\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    # 1. Find range\n    max_val = max(arr)\n    min_val = min(arr) # Handle negatives by shifting if needed, here assuming >= 0 for simplicity or shift\n    \n    if min_val < 0:\n        raise ValueError(\"This simple implementation assumes non-negative integers\")\n\n    count = [0] * (max_val + 1)\n    output = [0] * len(arr)\n\n    # 2. Store count of each character\n    for num in arr:\n        count[num] += 1\n        \n    # 3. Change count[i] so that count[i] now contains actual position\n    for i in range(1, len(count)):\n        count[i] += count[i-1]\n        \n    # 4. Build output array (Stable)\n    i = len(arr) - 1\n    while i >= 0:\n        output[count[arr[i]] - 1] = arr[i]\n        count[arr[i]] -= 1\n        i -= 1\n        \n    return output\n\ndef run_tests():\n    data = [4, 2, 2, 8, 3, 3, 1]\n    res = counting_sort(data)\n    assert res == [1, 2, 2, 3, 3, 4, 8]\n    print(\"[PASS] Counting Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/sorting_heap.py", "title": "sorting heap", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_heap.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Heap Sort\nTopic: Algorithms Basics\n\nTheory:\n    Comparison based sorting technique based on Binary Heap data structure.\n    Usually we build a Max-Heap then extract elements one by one.\n    \n    Complexity:\n    - Time: O(n log n).\n    - Space: O(1) in-place.\n    \n    Not stable.\n\"\"\"\n\ndef heapify(arr, n, i):\n    largest = i\n    l = 2 * i + 1\n    r = 2 * i + 2\n    \n    if l < n and arr[l] > arr[largest]:\n        largest = l\n    \n    if r < n and arr[r] > arr[largest]:\n        largest = r\n        \n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n    \n    # Build max heap (rearrange array)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n        \n    # One by one extract elements\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[i], arr[0] = arr[0], arr[i]\n        # Call max heapify on reduced heap\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef run_tests():\n    data = [12, 11, 13, 5, 6, 7]\n    sorted_arr = heap_sort(data.copy())\n    assert sorted_arr == [5, 6, 7, 11, 12, 13]\n    print(\"[PASS] Heap Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/sorting_insertion.py", "title": "sorting insertion", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_insertion.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Insertion Sort\nTopic: Algorithms Basics\n\nTheory:\n    Build the final sorted array one item at a time.\n    Pick element, find its correct position in the sorted part, insert it.\n    \n    Good for: Small arrays, or Nearly sorted arrays.\n    Complexity: O(n^2) worst case, O(n) best case (if already sorted).\n\"\"\"\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        # Move elements of arr[0..i-1] that are greater than key\n        # to one position ahead of their current position\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\ndef run_tests():\n    data = [12, 11, 13, 5, 6]\n    sorted_data = insertion_sort(data.copy())\n    assert sorted_data == [5, 6, 11, 12, 13]\n    print(\"[PASS] Insertion Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/sorting_merge.py", "title": "sorting merge", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_merge.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Merge Sort\nTopic: Algorithms Basics\n\nTheory:\n    Divide and Conquer algorithm. \n    Divides input array into two halves, calls itself for the two halves, and then merges the two sorted halves.\n    \n    Complexity:\n    - Time: O(n log n) in all cases.\n    - Space: O(n) auxiliary space (not in-place typically).\n    \n    Stable: Yes.\n\"\"\"\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    return merge(left_sorted, right_sorted)\n\ndef merge(left, right):\n    sorted_arr = []\n    i = j = 0\n    \n    # Merge smaller elements\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            sorted_arr.append(left[i])\n            i += 1\n        else:\n            sorted_arr.append(right[j])\n            j += 1\n    \n    # Append any remaining\n    sorted_arr.extend(left[i:])\n    sorted_arr.extend(right[j:])\n    \n    return sorted_arr\n\ndef run_tests():\n    data = [38, 27, 43, 3, 9, 82, 10]\n    sorted_data = merge_sort(data)\n    assert sorted_data == [3, 9, 10, 27, 38, 43, 82]\n    print(\"[PASS] Merge Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/sorting_quick.py", "title": "sorting quick", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_quick.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Quick Sort\nTopic: Algorithms Basics\n\nTheory:\n    Divide and Conquer.\n    Picks an element as pivot and partitions the given array around the picked pivot.\n    \n    Partitions:\n    1. Lomuto: Pivot is typically last element. Easier to implement.\n    2. Hoare: Pivot is typically first/last. Faster in practice (fewer swaps).\n\n    Complexity:\n    - Time: O(n log n) average, O(n^2) worst case.\n    - Space: O(log n) stack space.\n    \n    Not Stable.\n\"\"\"\n\nimport random\n\ndef quick_sort(arr):\n    \"\"\"Recursive Quick Sort using Python list comprehensions (Not efficient space-wise but readable).\"\"\"\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quick_sort(left) + middle + quick_sort(right)\n\n# ==========================================\n# In-Place Implementation (Lomuto)\n# ==========================================\n\ndef quick_sort_inplace(arr, low, high):\n    if low < high:\n        pi = partition_lomuto(arr, low, high)\n        quick_sort_inplace(arr, low, pi - 1)\n        quick_sort_inplace(arr, pi + 1, high)\n\ndef partition_lomuto(arr, low, high):\n    pivot = arr[high]\n    i = (low - 1)\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef run_tests():\n    data = [10, 7, 8, 9, 1, 5]\n    \n    # 1. Pythonic\n    res = quick_sort(data)\n    assert res == [1, 5, 7, 8, 9, 10]\n    \n    # 2. In-Place\n    data_copy = data.copy()\n    quick_sort_inplace(data_copy, 0, len(data_copy)-1)\n    assert data_copy == [1, 5, 7, 8, 9, 10]\n    \n    print(\"[PASS] Quick Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/sorting_radix.py", "title": "sorting radix", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_radix.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Radix Sort\nTopic: Algorithms Basics\n\nTheory:\n    Digit by digit sorting starting from least significant digit to most significant.\n    Uses Counting Sort as a subroutine.\n    \n    Complexity:\n    - Time: O(d * (n + b)) where d is digits, n is elements, b is base (10).\n    - Avoids comparison.\n\"\"\"\n\ndef counting_sort_for_radix(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10 # Base 10\n    \n    for i in range(n):\n        index = arr[i] // exp\n        count[index % 10] += 1\n        \n    for i in range(1, 10):\n        count[i] += count[i - 1]\n        \n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n        \n    for i in range(len(arr)):\n        arr[i] = output[i]\n\ndef radix_sort(arr):\n    if not arr:\n        return arr\n    max_val = max(arr)\n    \n    exp = 1\n    while max_val // exp > 0:\n        counting_sort_for_radix(arr, exp)\n        exp *= 10\n    return arr\n\ndef run_tests():\n    data = [170, 45, 75, 90, 802, 24, 2, 66]\n    res = radix_sort(data.copy())\n    assert res == [2, 24, 45, 66, 75, 90, 170, 802]\n    print(\"[PASS] Radix Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Basics/sorting_selection.py", "title": "sorting selection", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Basics/sorting_selection.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Basics"], "content": "\"\"\"\nTitle: Selection Sort\nTopic: Algorithms Basics\n\nTheory:\n    Divide array into sorted and unsorted parts.\n    Repeatedly find the minimum element from unsorted part and put it at the beginning.\n    \n    Complexity: O(n^2) always.\n    Note: Can implement unstable if not careful, but usually unstable? Actually swap usually makes it unstable.\n    Pros: Minimizes number of swaps (O(n) swaps).\n\"\"\"\n\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap found minimum with first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\ndef run_tests():\n    data = [64, 25, 12, 22, 11]\n    sorted_data = selection_sort(data.copy())\n    assert sorted_data == [11, 12, 22, 25, 64]\n    print(\"[PASS] Selection Sort\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/bit_manipulation_basics.py", "title": "bit manipulation basics", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/bit_manipulation_basics.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Bit Manipulation and Math"], "content": "\"\"\"\nTitle: Bit Manipulation Basics\nTopic: Bit Manipulation and Math\n\nTheory:\n    Operations on bits directly.\n    & (AND): Both 1 -> 1\n    | (OR): Either 1 -> 1\n    ^ (XOR): Different -> 1\n    ~ (NOT): Invert bits (Two's complement in Python: ~x = -x-1)\n    << (Left Shift): Multiply by 2^k\n    >> (Right Shift): Divide by 2^k\n\"\"\"\n\ndef basic_ops(a, b):\n    print(f\"a={a} ({bin(a)}), b={b} ({bin(b)})\")\n    print(f\"a & b: {a & b} ({bin(a & b)})\")\n    print(f\"a | b: {a | b} ({bin(a | b)})\")\n    print(f\"a ^ b: {a ^ b} ({bin(a ^ b)})\")\n    print(f\"~a: {~a} ({bin(~a)})\")\n    print(f\"a << 1: {a << 1} ({bin(a << 1)})\")\n    print(f\"a >> 1: {a >> 1} ({bin(a >> 1)})\")\n\ndef swap_xor(a, b):\n    # Swap without temp variable\n    a = a ^ b\n    b = a ^ b\n    a = a ^ b\n    return a, b\n\ndef run_tests():\n    a, b = 10, 20\n    basic_ops(a, b)\n    \n    # Operations check\n    # 10: 1010\n    # 20: 10100\n    # 10&20: 00000 -> 0\n    assert (10 & 20) == 0\n    # 10|20: 11110 -> 30\n    assert (10 | 20) == 30\n    \n    # Swap\n    na, nb = swap_xor(10, 20)\n    assert na == 20\n    assert nb == 10\n    \n    print(\"[PASS] Bit Manipulation Basics\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/bit_tricks_and_hacks.py", "title": "bit tricks and hacks", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/bit_tricks_and_hacks.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Bit Manipulation and Math"], "content": "\"\"\"\nTitle: Bit Tricks and Hacks\nTopic: Bit Manipulation and Math\n\nTheory:\n    Useful O(1) properties.\n    1. Check if Power of 2: n & (n-1) == 0 (and n > 0).\n    2. Count Set Bits (Kernighan's Algo): Loop n = n & (n-1) increases count.\n    3. Clear lowest set bit: n & (n-1).\n    4. Get lowest set bit: n & -n.\n\"\"\"\n\ndef is_power_of_two(n):\n    return n > 0 and (n & (n - 1)) == 0\n\ndef count_set_bits(n):\n    count = 0\n    while n > 0:\n        n &= (n - 1)\n        count += 1\n    return count\n\ndef get_lowest_set_bit(n):\n    return n & -n\n\ndef run_tests():\n    # Power of 2\n    assert is_power_of_two(16) is True\n    assert is_power_of_two(18) is False\n    assert is_power_of_two(0) is False\n    \n    # Count bits\n    # 7 is 111 -> 3\n    assert count_set_bits(7) == 3\n    # 16 is 10000 -> 1\n    assert count_set_bits(16) == 1\n    \n    # Lowest set bit\n    # 12 is 1100. Lowest bit is at index 2 (value 4).\n    # -12 in two's complement...\n    assert get_lowest_set_bit(12) == 4\n    \n    print(\"[PASS] Bit Tricks\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/math_catalan_numbers.py", "title": "math catalan numbers", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/math_catalan_numbers.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Bit Manipulation and Math"], "content": "\"\"\"\nTitle: Catalan Numbers\nTopic: Bit Manipulation and Math\n\nTheory:\n    Sequence of natural numbers with many applications.\n    C_n = (2n)! / ((n+1)! * n!)\n    \n    Applications:\n    1. Number of correct bracket sequences of length 2n.\n    2. Number of BSTs with n nodes.\n    3. Number of triangulations of (n+2)-gon.\n\"\"\"\n\nimport math\n\ndef catalan_formula(n):\n    # C_n = (1 / n+1) * nCr(2n, n)\n    # nCr = (2n)! / (n! * (2n - n)!) = (2n)! / (n! * n!)\n    numerator = math.factorial(2 * n)\n    denominator = math.factorial(n + 1) * math.factorial(n)\n    return numerator // denominator\n\ndef catalan_dp(n):\n    # C_0 = 1\n    # C_n+1 = sum(C_i * C_{n-i}) for i=0 to n\n    if n == 0: return 1\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n            \n    return catalan[n]\n\ndef run_tests():\n    # C_3 = 5. ((), ()(), (())(), ... 5 BSTs with 3 nodes)\n    # C_4 = 14\n    assert catalan_formula(3) == 5\n    assert catalan_dp(3) == 5\n    \n    assert catalan_formula(4) == 14\n    \n    print(\"[PASS] Catalan Numbers\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/math_single_number_xor_patterns.py", "title": "math single number xor patterns", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Bit_Manipulation_and_Math/math_single_number_xor_patterns.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Bit Manipulation and Math"], "content": "\"\"\"\nTitle: Single Number Problem (Unique in Duplicates)\nTopic: Bit Manipulation and Math\n\nTheory:\n    Given array where every element appears twice except one. Find that one.\n    Solution: XOR sum of all elements.\n    x ^ x = 0.\n    x ^ 0 = x.\n    Associative.\n    \n    Complexity: O(N) time, O(1) space.\n\"\"\"\n\ndef find_single_number(nums):\n    res = 0\n    for n in nums:\n        res ^= n\n    return res\n\ndef find_two_single_numbers(nums):\n    \"\"\"\n    Every element appears twice except TWO numbers.\n    1. XOR all -> x ^ y.\n    2. Find a set bit in (x ^ y).\n    3. Divide elements into two groups based on that bit.\n    4. XOR each group to get x and y.\n    \"\"\"\n    xor_sum = 0\n    for n in nums:\n        xor_sum ^= n\n        \n    # Get rightmost set bit\n    right_bit = xor_sum & -xor_sum\n    \n    x, y = 0, 0\n    for n in nums:\n        if n & right_bit:\n            x ^= n\n        else:\n            y ^= n\n            \n    return x, y\n\ndef run_tests():\n    # 1\n    arr1 = [4, 1, 2, 1, 2]\n    assert find_single_number(arr1) == 4\n    \n    # 2\n    arr2 = [4, 5, 2, 4, 1, 1] # Unique: 5, 2\n    a, b = find_two_single_numbers(arr2)\n    assert set([a, b]) == {5, 2}\n    \n    print(\"[PASS] Single Number Problems\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_0_1_knapsack.py", "title": "dp 0 1 knapsack", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_0_1_knapsack.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: 0/1 Knapsack Problem\nTopic: Dynamic Programming\n\nTheory:\n    Given weights and values of n items, put these items in a knapsack of capacity W \n    to get the maximum total value.\n    Item can either be taken (1) or left (0).\n    \n    Recurrence:\n    K(n, W) = max(\n        val[n-1] + K(n-1, W-wt[n-1]),  // Include item\n        K(n-1, W)                      // Exclude item\n    )\n    \n    Complexity: O(N * W).\n\"\"\"\n\ndef knapsack_01(W, wt, val, n):\n    # dp[i][w] stores max value with i items and capacity w\n    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, W + 1):\n            if wt[i-1] <= w:\n                dp[i][w] = max(val[i-1] + dp[i-1][w-wt[i-1]], dp[i-1][w])\n            else:\n                dp[i][w] = dp[i-1][w]\n                \n    return dp[n][W]\n\ndef run_tests():\n    val = [60, 100, 120]\n    wt = [10, 20, 30]\n    W = 50\n    n = len(val)\n    # Expected: 20+30 weights (100+120=220)\n    assert knapsack_01(W, wt, val, n) == 220\n    print(\"[PASS] 0/1 Knapsack\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_coin_change.py", "title": "dp coin change", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_coin_change.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: Coin Change (Min Coins)\nTopic: Dynamic Programming\n\nTheory:\n    Find minimum number of coins to make a total amount V.\n    \n    Recurrence:\n    dp[v] = min(dp[v], dp[v - coin] + 1)\n    \n    Complexity: O(V * N).\n\"\"\"\n\ndef coin_change(coins, amount):\n    # Initialize with infinity\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n            \n    return dp[amount] if dp[amount] != float('inf') else -1\n\ndef run_tests():\n    coins = [1, 2, 5]\n    amount = 11\n    # 5 + 5 + 1 = 3 coins\n    assert coin_change(coins, amount) == 3\n    \n    assert coin_change([2], 3) == -1\n    \n    print(\"[PASS] Coin Change\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_edit_distance.py", "title": "dp edit distance", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_edit_distance.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: Edit Distance (Levenshtein Distance)\nTopic: Dynamic Programming\n\nTheory:\n    Minimum operations to convert one string to another.\n    Ops: Insert, Remove, Replace.\n    \n    Recurrence:\n    if S1[i] == S2[j]: dp[i][j] = dp[i-1][j-1]\n    else: dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) (Insert, Remove, Replace)\n    \n    Complexity: O(M * N).\n\"\"\"\n\ndef edit_distance(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j # Insert all\n            elif j == 0:\n                dp[i][j] = i # Remove all\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i][j-1],    # Insert\n                    dp[i-1][j],    # Remove\n                    dp[i-1][j-1]   # Replace\n                )\n    return dp[m][n]\n\ndef run_tests():\n    s1 = \"sunday\"\n    s2 = \"saturday\"\n    # Ops:\n    # 1. s(u)n -> s(a)t (Replace u->a, insert t?)\n    # sunday -> saturn... hard to trace manually, trusted algo usually.\n    # sunday (6) -> saturday (8)\n    # s==s, u->a, n->t, d->u, a->r, y->d, +a, +y (This path is messy)\n    # Correct path: s, u->a, n->t, d->u, a->r, y->d... no, y matches end?\n    # Actually:\n    # s u n d a y\n    # s a t u r d a y\n    # Cost is usually 3:\n    # 1. Replace n with r (surday)\n    # 2. Insert t (sturday)\n    # 3. Insert a (saturday)\n    \n    assert edit_distance(s1, s2) == 3 \n    print(\"[PASS] Edit Distance\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_longest_common_subsequence.py", "title": "dp longest common subsequence", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_longest_common_subsequence.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: Longest Common Subsequence (LCS)\nTopic: Dynamic Programming\n\nTheory:\n    Find the length of the longest subsequence present in both strings.\n    Subsequence: Order matters, continuity does not.\n    \n    Recurrence:\n    if S1[i] == S2[j]: 1 + LCS(i-1, j-1)\n    else: max(LCS(i-1, j), LCS(i, j-1))\n    \n    Complexity: O(M * N).\n\"\"\"\n\ndef lcs(X, Y):\n    m = len(X)\n    n = len(Y)\n    \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i-1] == Y[j-1]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                \n    return dp[m][n]\n\ndef run_tests():\n    s1 = \"AGGTAB\"\n    s2 = \"GXTXAYB\"\n    # LCS is \"GTAB\", length 4\n    assert lcs(s1, s2) == 4\n    print(\"[PASS] LCS\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_longest_increasing_subsequence.py", "title": "dp longest increasing subsequence", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_longest_increasing_subsequence.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: Longest Increasing Subsequence (LIS)\nTopic: Dynamic Programming\n\nTheory:\n    Find length of the longest subsequence that is strictly increasing.\n    \n    Approaches:\n    1. DP O(N^2): dp[i] = 1 + max(dp[j]) for j < i if arr[j] < arr[i].\n    2. Binary Search O(N log N): Patience sorting optimization (tail array).\n\"\"\"\n\nimport bisect\n\n# 1. DP Approach O(N^2)\ndef lis_dp(arr):\n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp) if arr else 0\n\n# 2. Binary Search Approach O(N log N)\ndef lis_binary_search(arr):\n    if not arr: return 0\n    tails = []\n    \n    for x in arr:\n        idx = bisect.bisect_left(tails, x)\n        if idx < len(tails):\n            tails[idx] = x\n        else:\n            tails.append(x)\n    return len(tails)\n\ndef run_tests():\n    arr = [10, 22, 9, 33, 21, 50, 41, 60]\n    # LIS: 10, 22, 33, 50, 60 or ...\n    # Length 5\n    \n    assert lis_dp(arr) == 5\n    assert lis_binary_search(arr) == 5\n    print(\"[PASS] LIS\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_matrix_chain_multiplication.py", "title": "dp matrix chain multiplication", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_matrix_chain_multiplication.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: Matrix Chain Multiplication\nTopic: Dynamic Programming\n\nTheory:\n    Given sequence of matrices, find most efficient way to multiply (parenthesize) them.\n    Cost is number of scalar multiplications.\n    \n    Recurrence:\n    m[i,j] = min(m[i,k] + m[k+1,j] + p[i-1]*p[k]*p[j]) for k in i to j-1.\n    \n    Complexity: O(N^3).\n\"\"\"\n\ndef matrix_chain_order(p):\n    n = len(p) - 1\n    m = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    for L in range(2, n + 1): # L is chain length\n        for i in range(1, n - L + 2):\n            j = i + L - 1\n            m[i][j] = float('inf')\n            \n            for k in range(i, j):\n                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]\n                if q < m[i][j]:\n                    m[i][j] = q\n                    \n    return m[1][n]\n\ndef run_tests():\n    # Matrices dimensions: 1x2, 2x3, 3x4\n    # p = [1, 2, 3, 4]\n    # (A*B)*C or A*(B*C)\n    # (1x2 * 2x3) -> 1x3, cost 1*2*3 = 6. Then (1x3 * 3x4) -> 1x4, cost 1*3*4=12. Total 18.\n    # A*(2x3 * 3x4) -> 2x4, cost 2*3*4 = 24. Then (1x2 * 2x4) -> 1x4, cost 1*2*4=8. Total 32.\n    # Min is 18.\n    \n    arr = [1, 2, 3, 4]\n    assert matrix_chain_order(arr) == 18\n    print(\"[PASS] Matrix Chain Multiplication\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_memoization_vs_tabulation.py", "title": "dp memoization vs tabulation", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_memoization_vs_tabulation.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: DP Intro (Memoization vs Tabulation)\nTopic: Dynamic Programming\n\nTheory:\n    DP solves problems by breaking them into overlapping subproblems.\n    \n    1. Memoization (Top-Down): Recursive. Caches results of function calls.\n    2. Tabulation (Bottom-Up): Iterative. Fills a table (array) from base cases up.\n    \n    Example: Fibonacci.\n\"\"\"\n\n# 1. Memoization\nmemo = {}\ndef fib_memo(n):\n    if n in memo: return memo[n]\n    if n <= 1: return n\n    memo[n] = fib_memo(n-1) + fib_memo(n-2)\n    return memo[n]\n\n# 2. Tabulation\ndef fib_tab(n):\n    if n <= 1: return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\n# 3. Space Optimized Tabulation\ndef fib_space_opt(n):\n    if n <= 1: return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef run_tests():\n    n = 10\n    expected = 55\n    assert fib_memo(n) == expected\n    assert fib_tab(n) == expected\n    assert fib_space_opt(n) == expected\n    \n    print(\"[PASS] DP Intro (Fibonacci)\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_subset_sum.py", "title": "dp subset sum", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_subset_sum.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: Subset Sum Problem\nTopic: Dynamic Programming\n\nTheory:\n    Determine if there is a subset of the given set with sum equal to given sum.\n    \n    Recurrence:\n    dp[i][j] = dp[i-1][j] (Excluding item) OR dp[i-1][j-item] (Including item)\n    \n    Complexity: O(N * Sum).\n\"\"\"\n\ndef is_subset_sum(arr, n, sum_val):\n    dp = [[False for _ in range(sum_val + 1)] for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True # Sum 0 is always possible (empty set)\n        \n    for i in range(1, n + 1):\n        for j in range(1, sum_val + 1):\n            if arr[i-1] <= j:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n                \n    return dp[n][sum_val]\n\ndef run_tests():\n    set_vals = [3, 34, 4, 12, 5, 2]\n    sum_val = 9\n    assert is_subset_sum(set_vals, len(set_vals), sum_val) is True\n    assert is_subset_sum(set_vals, len(set_vals), 30) is False # Maybe true?\n    # 34 too big. 3+4+12+5+2 = 26. So 30 impossible.\n    \n    print(\"[PASS] Subset Sum\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_unbounded_knapsack.py", "title": "dp unbounded knapsack", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Dynamic_Programming/dp_unbounded_knapsack.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Dynamic Programming"], "content": "\"\"\"\nTitle: Unbounded Knapsack\nTopic: Dynamic Programming\n\nTheory:\n    Similar to 0/1 Knapsack, but we can pick an item MULTIPLE times.\n    \n    Recurrence:\n    dp[w] = max(dp[w], dp[w-wt[i]] + val[i]) for all items.\n    \n    Complexity: O(N * W).\n\"\"\"\n\ndef unbounded_knapsack(W, n, val, wt):\n    dp = [0] * (W + 1)\n    \n    for w in range(W + 1):\n        for i in range(n):\n            if wt[i] <= w:\n                dp[w] = max(dp[w], dp[w - wt[i]] + val[i])\n                \n    return dp[W]\n\ndef run_tests():\n    W = 100\n    val = [10, 30, 20]\n    wt = [5, 10, 15]\n    n = len(val)\n    \n    # We can take item 1 (wt 10, val 30) 10 times -> val 300.\n    # Or item 0 (wt 5, val 10) 20 times -> val 200.\n    # Unbounded, so max is 300.\n    assert unbounded_knapsack(W, n, val, wt) == 300\n    print(\"[PASS] Unbounded Knapsack\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_closest_pair_of_points.py", "title": "geometry closest pair of points", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_closest_pair_of_points.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Geometry Algorithms"], "content": "\"\"\"\nTitle: Closest Pair of Points\nTopic: Geometry Algorithms\n\nTheory:\n    Find pair of points with minimum distance.\n    Divide and Conquer O(N log N).\n    \n    Base case: Brute force for small N.\n    Merge step: Check strip around dividing line.\n\"\"\"\n\nimport math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef dist(p1, p2):\n    return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)\n\ndef brute_force(P, n):\n    min_val = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            val = dist(P[i], P[j])\n            if val < min_val:\n                min_val = val\n    return min_val\n\ndef strip_closest(strip, size, d):\n    min_val = d\n    strip.sort(key=lambda p: p.y)\n    \n    for i in range(size):\n        for j in range(i + 1, size):\n            if (strip[j].y - strip[i].y) >= min_val:\n                break\n            d_val = dist(strip[i], strip[j])\n            if d_val < min_val:\n                min_val = d_val\n    return min_val\n\ndef closest_util(P, n):\n    if n <= 3:\n        return brute_force(P, n)\n        \n    mid = n // 2\n    mid_point = P[mid]\n    \n    dl = closest_util(P[:mid], mid)\n    dr = closest_util(P[mid:], n - mid)\n    d = min(dl, dr)\n    \n    strip = []\n    for i in range(n):\n        if abs(P[i].x - mid_point.x) < d:\n            strip.append(P[i])\n            \n    return min(d, strip_closest(strip, len(strip), d))\n\ndef closest(P, n):\n    P.sort(key=lambda p: p.x)\n    return closest_util(P, n)\n\ndef run_tests():\n    P = [Point(2, 3), Point(12, 30), Point(40, 50), Point(5, 1), Point(12, 10), Point(3, 4)]\n    # Closest: (2,3) and (3,4) dist ~1.414 OR (2,3) and (5,1) dist ~3.6\n    # Actually (2,3) and (3,4) is smallest.\n    \n    d = closest(P, len(P))\n    # dist((2,3), (3,4)) = sqrt(1+1) = 1.414\n    assert abs(d - 1.414213) < 0.001\n    print(\"[PASS] Closest Pair\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_convex_hull_graham_scan.py", "title": "geometry convex hull graham scan", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_convex_hull_graham_scan.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Geometry Algorithms"], "content": "\"\"\"\nTitle: Convex Hull (Graham Scan)\nTopic: Geometry Algorithms\n\nTheory:\n    Smallest convex polygon containing all points.\n    Graham Scan: O(N log N) by sorting polar angle.\n\"\"\"\n\nimport math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def __lt__(self, other):\n        # Sort by y, then x (for finding bottom-left)\n        if self.y != other.y:\n            return self.y < other.y\n        return self.x < other.x\n\ndef orientation(p, q, r):\n    val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n    if val == 0: return 0\n    return 1 if val > 0 else 2\n\ndef compare_polar(p0):\n    # Closure to compare p1, p2 relative to p0\n    def compare(p1):\n        if p1 == p0: return -1 # Ensure p0 is first\n        delta_y = p1.y - p0.y\n        delta_x = p1.x - p0.x\n        angle = math.atan2(delta_y, delta_x)\n        return angle\n        # Note: distance check needed for collinear points\n    return compare\n\ndef graham_scan(points):\n    n = len(points)\n    if n < 3: return points # Convex hull is the points themselves\n    \n    # 1. Find bottom-most left\n    min_idx = 0\n    for i in range(1, n):\n        if points[i] < points[min_idx]:\n            min_idx = i\n            \n    points[0], points[min_idx] = points[min_idx], points[0]\n    p0 = points[0]\n    \n    # 2. Sort by polar angle wrt p0\n    # Custom sort implementation would be complex in Python without cmp_to_key fully handling collinear\n    # Simplified logic: use atan2\n    remaining = points[1:]\n    remaining.sort(key=lambda p: math.atan2(p.y - p0.y, p.x - p0.x))\n    \n    stack = [p0]\n    for p in remaining:\n        while len(stack) > 1 and orientation(stack[-2], stack[-1], p) != 2: # 2 is CCW\n            stack.pop()\n        stack.append(p)\n        \n    return stack\n\ndef run_tests():\n    pts = [Point(0, 3), Point(1, 1), Point(2, 2), Point(4, 4), \n           Point(0, 0), Point(1, 2), Point(3, 1), Point(3, 3)]\n    \n    hull = graham_scan(pts)\n    # Expected: (0,0), (3,1), (4,4), (0,3) in CCW order\n    # Note: 4,4 is extreme top right. 0,3 extreme top left.\n    assert len(hull) >= 3\n    print(f\"Hull size: {len(hull)}\")\n    \n    print(\"[PASS] Convex Hull\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_line_intersection.py", "title": "geometry line intersection", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_line_intersection.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Geometry Algorithms"], "content": "\"\"\"\nTitle: Line Intersection\nTopic: Geometry Algorithms\n\nTheory:\n    Two lines (p1,q1) and (p2,q2) intersect if:\n    (p1, q1, p2) and (p1, q1, q2) have different orientations AND\n    (p2, q2, p1) and (p2, q2, q1) have different orientations.\n    \n    Special case: Collinear segments.\n\"\"\"\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef on_segment(p, q, r):\n    return (q.x <= max(p.x, r.x) and q.x >= min(p.x, r.x) and\n            q.y <= max(p.y, r.y) and q.y >= min(p.y, r.y))\n\ndef orientation(p, q, r):\n    val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n    if val == 0: return 0\n    return 1 if val > 0 else 2\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    \n    # General Case\n    if o1 != o2 and o3 != o4:\n        return True\n        \n    # Special Cases\n    if o1 == 0 and on_segment(p1, p2, q1): return True\n    if o2 == 0 and on_segment(p1, q2, q1): return True\n    if o3 == 0 and on_segment(p2, p1, q2): return True\n    if o4 == 0 and on_segment(p2, q1, q2): return True\n    \n    return False\n\ndef run_tests():\n    p1 = Point(1, 1)\n    q1 = Point(10, 1)\n    p2 = Point(1, 2)\n    q2 = Point(10, 2)\n    \n    assert do_intersect(p1, q1, p2, q2) == False # Parallel\n    \n    p3 = Point(5, 5)\n    q3 = Point(5, 0) # Vertical crossing both horizontal\n    assert do_intersect(p1, q1, p3, q3) == True\n    \n    print(\"[PASS] Line Intersection\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_point_line_basics.py", "title": "geometry point line basics", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_point_line_basics.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Geometry Algorithms"], "content": "\"\"\"\nTitle: Point and Line Basics\nTopic: Geometry Algorithms\n\nTheory:\n    Point: (x, y).\n    Line: ax + by + c = 0.\n    Distance: sqrt((x2-x1)^2 + (y2-y1)^2).\n    Orientation: (p, q, r). 0=Collinear, 1=Clockwise, 2=CounterClockwise.\n\"\"\"\n\nimport math\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def dist(self, other):\n        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n\ndef orientation(p, q, r):\n    \"\"\"\n    Returns:\n    0: Collinear\n    1: Clockwise\n    2: Counterclockwise\n    \"\"\"\n    val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\n    if val == 0: return 0\n    return 1 if val > 0 else 2\n\ndef run_tests():\n    p1 = Point(0, 0)\n    p2 = Point(4, 4)\n    p3 = Point(4, 0)\n    \n    # Distance\n    assert p1.dist(p3) == 4.0\n    \n    # Orientation 0,0 -> 4,4 -> 4,0 (Right turn) = Clockwise (1)\n    # (4-0)*(4-4) - (4-0)*(0-4) = 0 - (-16) = 16 > 0 -> 1\n    assert orientation(p1, p2, p3) == 1\n    \n    print(\"[PASS] Geometry Basics\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_polygon_area.py", "title": "geometry polygon area", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Geometry_Algorithms/geometry_polygon_area.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Geometry Algorithms"], "content": "\"\"\"\nTitle: Polygon Area (Shoelace Formula)\nTopic: Geometry Algorithms\n\nTheory:\n    Area = 0.5 * |sum(x_i * y_{i+1} - x_{i+1} * y_i)|\n\"\"\"\n\ndef polygon_area(X, Y, n):\n    area = 0.0\n    j = n - 1\n    \n    for i in range(n):\n        area += (X[j] + X[i]) * (Y[j] - Y[i])\n        j = i\n        \n    return abs(area / 2.0)\n\n# Note: Formula above is a variation (Trapezoid formula), equivalent to Shoelace.\n# Shoelace: (x1y2 + x2y3 ...) - (y1x2 + y2x3 ...)\n\ndef run_tests():\n    # Square (0,0), (4,0), (4,4), (0,4) -> Area 16\n    X = [0, 4, 4, 0]\n    Y = [0, 0, 4, 4]\n    \n    assert polygon_area(X, Y, 4) == 16.0\n    print(\"[PASS] Polygon Area\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_activity_selection.py", "title": "greedy activity selection", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_activity_selection.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Greedy"], "content": "\"\"\"\nTitle: Activity Selection Problem\nTopic: Greedy Algorithms\n\nTheory:\n    Select max number of activities that can be performed by a single person.\n    Assumption: Activities sorted by FINISH time.\n    If not sorted, sort them first.\n    \n    Greedy Choice: Always pick next activity that finishes earliest and is compatible.\n    Complexity: O(N log N) (due to sorting).\n\"\"\"\n\ndef max_activities(activities):\n    # format: (start, finish)\n    # Sort by finish time\n    activities.sort(key=lambda x: x[1])\n    \n    selected = [activities[0]]\n    last_finish = activities[0][1]\n    \n    for i in range(1, len(activities)):\n        start, finish = activities[i]\n        if start >= last_finish:\n            selected.append(activities[i])\n            last_finish = finish\n            \n    return selected\n\ndef run_tests():\n    # (start, finish)\n    acts = [(1, 2), (3, 4), (0, 6), (5, 7), (8, 9), (5, 9)]\n    # Sorted by finish:\n    # (1, 2), (3, 4), (0, 6), (5, 7), (8, 9), (5, 9) (Finish: 2, 4, 6, 7, 9, 9)\n    # 1. Pick (1,2). Finish 2.\n    # 2. Pick (3,4). Start 3 >= 2. Ok. Finish 4.\n    # 3. (0,6) Start 0 < 4. No.\n    # 4. (5,7) Start 5 >= 4. Ok. Finish 7.\n    # 5. (8,9) Start 8 >= 7. Ok. Finish 9.\n    # Total 4.\n    \n    res = max_activities(acts)\n    assert len(res) == 4\n    print(\"[PASS] Activity Selection\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_fractional_knapsack.py", "title": "greedy fractional knapsack", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_fractional_knapsack.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Greedy"], "content": "\"\"\"\nTitle: Fractional Knapsack\nTopic: Greedy Algorithms\n\nTheory:\n    Given weights and values, put items in knapsack of capacity W.\n    We CAN break items (take fraction).\n    \n    Greedy Strategy: Sort by Ratio (Value/Weight) Descending.\n    \n    Complexity: O(N log N).\n\"\"\"\n\nclass Item:\n    def __init__(self, value, weight):\n        self.value = value\n        self.weight = weight\n        self.ratio = value / weight\n\ndef fractional_knapsack(W, items):\n    items.sort(key=lambda x: x.ratio, reverse=True)\n    \n    total_val = 0.0\n    current_weight = 0\n    \n    for item in items:\n        if current_weight + item.weight <= W:\n            current_weight += item.weight\n            total_val += item.value\n        else:\n            remain = W - current_weight\n            total_val += item.value * (remain / item.weight)\n            break\n            \n    return total_val\n\ndef run_tests():\n    W = 50\n    items = [Item(60, 10), Item(100, 20), Item(120, 30)]\n    # Ratios: 6, 5, 4.\n    # Take Item 1 (60, 10). W left 40. Val 60.\n    # Take Item 2 (100, 20). W left 20. Val 160.\n    # Take 20/30 of Item 3. Val 160 + 120*(2/3) = 160+80 = 240.\n    \n    assert fractional_knapsack(W, items) == 240.0\n    print(\"[PASS] Fractional Knapsack\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_huffman_coding.py", "title": "greedy huffman coding", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_huffman_coding.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Greedy"], "content": "\"\"\"\nTitle: Huffman Coding\nTopic: Greedy Algorithms\n\nTheory:\n    Lossless data compression.\n    Assigns variable-length codes to characters based on frequencies.\n    More frequent chars -> Shorter codes.\n    Uses Min-Heap to build Huffman Tree.\n    \n    Complexity: O(N log N).\n\"\"\"\n\nimport heapq\n\nclass Node:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n\n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef build_huffman_tree(text):\n    freq = {}\n    for char in text:\n        freq[char] = freq.get(char, 0) + 1\n        \n    pq = [Node(char, f) for char, f in freq.items()]\n    heapq.heapify(pq)\n    \n    while len(pq) > 1:\n        left = heapq.heappop(pq)\n        right = heapq.heappop(pq)\n        \n        merged = Node(None, left.freq + right.freq)\n        merged.left = left\n        merged.right = right\n        \n        heapq.heappush(pq, merged)\n        \n    return pq[0]\n\ndef generate_codes(root, current_code, codes):\n    if root is None: return\n    \n    if root.char is not None:\n        codes[root.char] = current_code\n        return\n    \n    generate_codes(root.left, current_code + \"0\", codes)\n    generate_codes(root.right, current_code + \"1\", codes)\n\ndef run_tests():\n    text = \"aaabbc\"\n    # a:3, b:2, c:1\n    # Tree building...\n    # c(1), b(2) -> merge(3). (c left 0, b right 1) ?? depends on heap stability\n    # merge(3), a(3) -> root(6).\n    \n    root = build_huffman_tree(text)\n    codes = {}\n    generate_codes(root, \"\", codes)\n    \n    # 'a' (freq 3) should have short code (length 1 typically if others deeper)\n    # 'c' and 'b' should be longer.\n    assert len(codes['a']) < len(codes['c']) or len(codes['a']) == 1\n    \n    encoded = \"\".join(codes[char] for char in text)\n    print(f\"Codes: {codes}\")\n    print(f\"Encoded 'aaabbc': {encoded}\")\n    \n    print(\"[PASS] Huffman Coding\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_job_sequencing.py", "title": "greedy job sequencing", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Greedy/greedy_job_sequencing.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Greedy"], "content": "\"\"\"\nTitle: Job Sequencing Problem\nTopic: Greedy Algorithms\n\nTheory:\n    Given jobs with (deadline, profit). Each job takes 1 unit of time.\n    Maximize total profit such that all selected jobs finish before deadlines.\n    \n    Algorithm:\n    1. Sort by Profit (Desc).\n    2. Assign to latest possible time slot available before deadline.\n\"\"\"\n\ndef job_sequencing(jobs, max_deadline):\n    # jobs: list of (id, deadline, profit)\n    jobs.sort(key=lambda x: x[2], reverse=True)\n    \n    slots = [-1] * (max_deadline + 1)\n    total_profit = 0\n    job_order = []\n    \n    for job in jobs:\n        jid, deadline, profit = job\n        # Find free slot from deadline down to 1\n        for j in range(min(max_deadline, deadline), 0, -1):\n            if slots[j] == -1:\n                slots[j] = jid\n                total_profit += profit\n                break\n                \n    job_order = [x for x in slots if x != -1]\n    return job_order, total_profit\n\ndef run_tests():\n    # (id, deadline, profit)\n    jobs = [('a', 2, 100), ('b', 1, 19), ('c', 2, 27), ('d', 1, 25), ('e', 3, 15)]\n    # Sort: a(100), c(27), d(25), b(19), e(15)\n    \n    # 1. a(100) d=2. Slot 2 free? Yes. slots[2]=a.\n    # 2. c(27) d=2. Slot 2 taken. Slot 1 free? Yes. slots[1]=c.\n    # 3. d(25) d=1. Slot 1 taken. \n    # 4. b(19) d=1. Slot 1 taken.\n    # 5. e(15) d=3. Slot 3 free? Yes. slots[3]=e.\n    \n    # Order: c, a, e. Profit 27+100+15 = 142.\n    \n    order, profit = job_sequencing(jobs, 3)\n    assert profit == 142\n    assert set(order) == {'a', 'c', 'e'}\n    \n    print(\"[PASS] Job Sequencing\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/balanced_trees_avl_intro.py", "title": "balanced trees avl intro", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/balanced_trees_avl_intro.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: AVL Tree (Balanced BST)\nTopic: Data Structures\n\nTheory:\n    Self-balancing BST.\n    Balance Factor = Height(Left) - Height(Right).\n    Allowed BF: {-1, 0, 1}.\n    \n    Rotations: Left, Right, Left-Right, Right-Left.\n    \n    Complexity: O(log n) for insert/delete/search.\n\"\"\"\n\nclass AVLNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass AVLTree:\n    def get_height(self, root):\n        if not root: return 0\n        return root.height\n\n    def get_balance(self, root):\n        if not root: return 0\n        return self.get_height(root.left) - self.get_height(root.right)\n\n    def right_rotate(self, y):\n        x = y.left\n        T2 = x.right\n        \n        x.right = y\n        y.left = T2\n        \n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        return x\n\n    def left_rotate(self, x):\n        y = x.right\n        T2 = y.left\n        \n        y.left = x\n        x.right = T2\n        \n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        return y\n\n    def insert(self, root, key):\n        if not root:\n            return AVLNode(key)\n        \n        if key < root.val:\n            root.left = self.insert(root.left, key)\n        else:\n            root.right = self.insert(root.right, key)\n            \n        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))\n        \n        balance = self.get_balance(root)\n        \n        # Left Left\n        if balance > 1 and key < root.left.val:\n            return self.right_rotate(root)\n            \n        # Right Right\n        if balance < -1 and key > root.right.val:\n            return self.left_rotate(root)\n            \n        # Left Right\n        if balance > 1 and key > root.left.val:\n            root.left = self.left_rotate(root.left)\n            return self.right_rotate(root)\n            \n        # Right Left\n        if balance < -1 and key < root.right.val:\n            root.right = self.right_rotate(root.right)\n            return self.left_rotate(root)\n            \n        return root\n\n    def inorder(self, root):\n        res = []\n        if root:\n            res = self.inorder(root.left)\n            res.append(root.val)\n            res = res + self.inorder(root.right)\n        return res\n\ndef run_tests():\n    tree = AVLTree()\n    root = None\n    \n    # Inserting in sorted order would skew a normal BST (O(n))\n    # AVL should balance it (O(log n))\n    keys = [10, 20, 30, 40, 50, 25]\n    for k in keys:\n        root = tree.insert(root, k)\n        \n    # Preorder check for structure would be better, but inorder checks BST property\n    inorder = tree.inorder(root)\n    assert inorder == sorted(keys)\n    \n    # Check balance (Root should be 30 for this specific insertion set?)\n    # 10, 20, 30, 40, 50, 25\n    #      30\n    #     /  \\\n    #    20  40\n    #   /  \\   \\\n    #  10  25  50\n    assert root.val == 30 \n    \n    print(\"[PASS] AVL Tree insertion and balancing\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/disjoint_set_union_find.py", "title": "disjoint set union find", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/disjoint_set_union_find.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Disjoint Set Union (DSU)\nTopic: Data Structures\n\nTheory:\n    Efficiently manage disjoint sets and determine connectivity.\n    Operations:\n    - `find(x)`: Find representative of set containing x.\n    - `union(x, y)`: Merge sets containing x and y.\n    \n    Optimizations:\n    - Path Compression (Flatten tree during find).\n    - Union by Rank/Size (Attach smaller tree to larger).\n    \n    Complexity: O(alpha(n)) - Nearly constant time.\n\"\"\"\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, i):\n        if self.parent[i] != i:\n            # Path Compression\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        \n        if root_i != root_j:\n            # Union by Rank\n            if self.rank[root_i] < self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n            return True # Merged\n        return False # Already same set\n\ndef run_tests():\n    dsu = DSU(5)\n    # 0, 1, 2, 3, 4\n    \n    dsu.union(0, 1)\n    dsu.union(2, 3)\n    \n    assert dsu.find(0) == dsu.find(1)\n    assert dsu.find(2) == dsu.find(3)\n    assert dsu.find(0) != dsu.find(2)\n    \n    dsu.union(1, 2)\n    # Now all 0, 1, 2, 3 should be connected\n    assert dsu.find(0) == dsu.find(3)\n    \n    print(\"[PASS] DSU (Union Find)\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/hash_table_open_addressing.py", "title": "hash table open addressing", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/hash_table_open_addressing.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Hash Table (Collision Handling: Open Addressing)\nTopic: Data Structures\n\nTheory:\n    When collision occurs, probe for the next empty slot.\n    Probing methods: Linear Probing, Quadratic Probing, Double Hashing.\n    Here: Linear Probing.\n    \n    Deletion is tricky (requires \"Deleted\" marker).\n\"\"\"\n\nclass HashTableOA:\n    def __init__(self, capacity=10):\n        self.capacity = capacity\n        self.keys = [None] * capacity\n        self.values = [None] * capacity\n        self.size = 0\n\n    def _hash(self, key):\n        return hash(key) % self.capacity\n\n    def put(self, key, value):\n        if self.size == self.capacity:\n            raise Exception(\"Table Full (Resize not implemented)\")\n            \n        idx = self._hash(key)\n        \n        while self.keys[idx] is not None:\n            if self.keys[idx] == key:\n                self.values[idx] = value\n                return\n            idx = (idx + 1) % self.capacity\n            \n        self.keys[idx] = key\n        self.values[idx] = value\n        self.size += 1\n\n    def get(self, key):\n        idx = self._hash(key)\n        start_idx = idx\n        \n        while self.keys[idx] is not None:\n            if self.keys[idx] == key:\n                return self.values[idx]\n            idx = (idx + 1) % self.capacity\n            if idx == start_idx:\n                break\n        return None\n\ndef run_tests():\n    ht = HashTableOA(5)\n    ht.put(\"A\", 1)\n    ht.put(\"B\", 2)\n    \n    assert ht.get(\"A\") == 1\n    \n    # Test collision (hard to guarantee without known hash, but assuming Linear Probing works)\n    \n    print(\"[PASS] Hash Table (Open Addressing)\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/hash_table_with_collision_chaining.py", "title": "hash table with collision chaining", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/hash_table_with_collision_chaining.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Hash Table (Collision Handling: Chaining)\nTopic: Data Structures\n\nTheory:\n    Map Keys to Values using a hash function.\n    Collision: When two keys map to same index.\n    Chaining: Use a linked list at each index (bucket) to store multiple items.\n    \n    Complexity:\n    - Average key access: O(1 + load_factor).\n    - Worst case: O(n) (if all keys hash to same bucket).\n\"\"\"\n\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n\nclass HashTableChaining:\n    def __init__(self, capacity=10):\n        self.capacity = capacity\n        self.buckets = [None] * capacity\n\n    def _hash(self, key):\n        return hash(key) % self.capacity\n\n    def put(self, key, value):\n        idx = self._hash(key)\n        head = self.buckets[idx]\n        \n        # Check update\n        curr = head\n        while curr:\n            if curr.key == key:\n                curr.value = value\n                return\n            curr = curr.next\n            \n        # Insert at front\n        new_node = Node(key, value)\n        new_node.next = head\n        self.buckets[idx] = new_node\n\n    def get(self, key):\n        idx = self._hash(key)\n        curr = self.buckets[idx]\n        while curr:\n            if curr.key == key:\n                return curr.value\n            curr = curr.next\n        return None\n\ndef run_tests():\n    ht = HashTableChaining()\n    ht.put(\"Alice\", 100)\n    ht.put(\"Bob\", 90)\n    ht.put(\"Alice\", 101) # Update\n    \n    assert ht.get(\"Alice\") == 101\n    assert ht.get(\"Bob\") == 90\n    assert ht.get(\"Charlie\") is None\n    \n    print(\"[PASS] Hash Table (Chaining)\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/heaps_min_max_operations.py", "title": "heaps min max operations", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/heaps_min_max_operations.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Min/Max Heap Operations (Manual Implementation)\nTopic: Data Structures\n\nTheory:\n    Binary Heap using Array.\n    Parent(i) = (i-1)//2\n    Left(i) = 2*i + 1\n    Right(i) = 2*i + 2\n    \n    Max Heap: Parent >= Children\n\"\"\"\n\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def push(self, val):\n        self.heap.append(val)\n        self._sift_up(len(self.heap) - 1)\n\n    def pop(self):\n        if not self.heap:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        \n        root = self.heap[0]\n        self.heap[0] = self.heap.pop() # Move last to root\n        self._sift_down(0)\n        return root\n\n    def _sift_up(self, idx):\n        parent = (idx - 1) // 2\n        while idx > 0 and self.heap[idx] < self.heap[parent]:\n            self.heap[idx], self.heap[parent] = self.heap[parent], self.heap[idx]\n            idx = parent\n            parent = (idx - 1) // 2\n\n    def _sift_down(self, idx):\n        n = len(self.heap)\n        smallest = idx\n        l = 2 * idx + 1\n        r = 2 * idx + 2\n        \n        if l < n and self.heap[l] < self.heap[smallest]:\n            smallest = l\n        if r < n and self.heap[r] < self.heap[smallest]:\n            smallest = r\n            \n        if smallest != idx:\n            self.heap[idx], self.heap[smallest] = self.heap[smallest], self.heap[idx]\n            self._sift_down(smallest)\n\ndef run_tests():\n    h = MinHeap()\n    h.push(10)\n    h.push(5)\n    h.push(30)\n    h.push(2)\n    \n    # Heap: [2, 5, 30, 10] (One possible structure)\n    assert h.pop() == 2\n    assert h.pop() == 5\n    assert h.pop() == 10\n    assert h.pop() == 30\n    \n    print(\"[PASS] Min Heap manual implementation\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_circular.py", "title": "linked list circular", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_circular.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Circular Linked List\nTopic: Data Structures\n\nTheory:\n    The last node points back to the head (or another node) instead of None.\n    \n    Use case:\n    - Round Robin scheduling.\n    - Implementation of queues.\n    \n    Pitfall: Infinite loops during traversal if break condition not set correctly.\n\"\"\"\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            self.head.next = self.head\n        else:\n            curr = self.head\n            while curr.next != self.head:\n                curr = curr.next\n            curr.next = new_node\n            new_node.next = self.head\n\n    def to_list(self):\n        if not self.head:\n            return []\n        out = []\n        curr = self.head\n        while True:\n            out.append(curr.data)\n            curr = curr.next\n            if curr == self.head:\n                break\n        return out\n\ndef run_tests():\n    cll = CircularLinkedList()\n    cll.append(\"A\")\n    cll.append(\"B\")\n    cll.append(\"C\")\n    \n    assert cll.to_list() == [\"A\", \"B\", \"C\"]\n    \n    # Check cycle\n    head = cll.head\n    assert head.next.next.next == head\n    \n    print(\"[PASS] Circular Linked List\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_doubly.py", "title": "linked list doubly", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_doubly.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Doubly Linked List\nTopic: Data Structures\n\nTheory:\n    Nodes have `prev` and `next` pointers.\n    Allows traversal in both directions.\n    \n    Complexity:\n    - Delete given node: O(1) (if reference known)\n    - Extra space for `prev` pointer.\n\"\"\"\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        \n        last = self.head\n        while last.next:\n            last = last.next\n        \n        last.next = new_node\n        new_node.prev = last\n\n    def delete_node(self, node):\n        \"\"\"Assumes node belongs to this list.\"\"\"\n        if not node:\n            return\n\n        if node == self.head:\n            self.head = node.next\n\n        if node.next:\n            node.next.prev = node.prev\n        \n        if node.prev:\n            node.prev.next = node.next\n\n    def to_list_forward(self):\n        out = []\n        curr = self.head\n        while curr:\n            out.append(curr.data)\n            curr = curr.next\n        return out\n\ndef run_tests():\n    dll = DoublyLinkedList()\n    dll.append(10)\n    dll.append(20)\n    dll.append(30)\n    \n    assert dll.to_list_forward() == [10, 20, 30]\n    \n    # Delete middle node (20)\n    # Finding node manually for test\n    node_20 = dll.head.next \n    dll.delete_node(node_20)\n    \n    assert dll.to_list_forward() == [10, 30]\n    \n    # Check links\n    assert dll.head.next.data == 30\n    assert dll.head.next.prev.data == 10\n    \n    print(\"[PASS] Doubly Linked List\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_singly.py", "title": "linked list singly", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/linked_list_singly.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Singly Linked List\nTopic: Data Structures\n\nTheory:\n    Linear collection of nodes. Each node points to the next.\n    \n    Complexity:\n    - Access: O(n)\n    - Insert/Delete at beginning: O(1)\n    - Insert/Delete at end: O(n) (or O(1) if tail pointer maintained)\n\"\"\"\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        \n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def delete_value(self, key):\n        curr = self.head\n        \n        if curr and curr.data == key:\n            self.head = curr.next\n            curr = None\n            return\n\n        prev = None\n        while curr and curr.data != key:\n            prev = curr\n            curr = curr.next\n        \n        if curr is None:\n            return # key not found\n\n        prev.next = curr.next\n        curr = None\n\n    def to_list(self):\n        out = []\n        curr = self.head\n        while curr:\n            out.append(curr.data)\n            curr = curr.next\n        return out\n\ndef run_tests():\n    ll = SinglyLinkedList()\n    ll.append(1)\n    ll.append(2)\n    ll.prepend(0) # 0, 1, 2\n    \n    assert ll.to_list() == [0, 1, 2]\n    \n    ll.delete_value(1) # 0, 2\n    assert ll.to_list() == [0, 2]\n    \n    ll.delete_value(0) # 2\n    assert ll.to_list() == [2]\n    \n    print(\"[PASS] Singly Linked List\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/priority_queue_heapq.py", "title": "priority queue heapq", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/priority_queue_heapq.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Priority Queue (Heapq)\nTopic: Data Structures\n\nTheory:\n    Elements are popped based on priority (min or max).\n    Python `heapq` module implements a Min-Heap on top of a list.\n    \n    Complexity:\n    - Push: O(log n)\n    - Pop: O(log n)\n    - Peek: O(1)\n\"\"\"\n\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n        self.count = 0 \n        \n    def push(self, item, priority):\n        # heapq is min-heap.\n        # Store as tuple (priority, count, item) to handle comparison safely.\n        # 'count' breaks ties without comparing 'item' which might not be comparable.\n        heapq.heappush(self.heap, (priority, self.count, item))\n        self.count += 1\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"Pop from empty PQ\")\n        return heapq.heappop(self.heap)[2] # Return item\n\n    def is_empty(self):\n        return len(self.heap) == 0\n\ndef run_tests():\n    pq = PriorityQueue()\n    pq.push(\"Task Low\", 10)\n    pq.push(\"Task High\", 1)\n    pq.push(\"Task Med\", 5)\n    \n    # Expect 1, 5, 10\n    assert pq.pop() == \"Task High\"\n    assert pq.pop() == \"Task Med\"\n    assert pq.pop() == \"Task Low\"\n    \n    print(\"[PASS] Priority Queue (Min Heap)\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/queue_array_and_deque.py", "title": "queue array and deque", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/queue_array_and_deque.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Queue (FIFO)\nTopic: Data Structures\n\nTheory:\n    First In, First Out (FIFO).\n    Operations: enqueue, dequeue.\n    \n    Implementations:\n    1. `collections.deque`: Doubly Linked List based. O(1) ends.\n    2. `list`: Bad for queues! `pop(0)` is O(n).\n\"\"\"\n\nfrom collections import deque\n\nclass Queue:\n    def __init__(self):\n        self.items = deque()\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        if self.is_empty():\n            raise IndexError(\"Dequeue from empty queue\")\n        return self.items.popleft() # O(1)\n\n    def is_empty(self):\n        return len(self.items) == 0\n\ndef run_tests():\n    q = Queue()\n    q.enqueue(\"First\")\n    q.enqueue(\"Second\")\n    \n    assert q.dequeue() == \"First\"\n    assert q.dequeue() == \"Second\"\n    \n    print(\"[PASS] Queue implementation\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/stack_array_and_list.py", "title": "stack array and list", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/stack_array_and_list.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Stack (LIFO)\nTopic: Data Structures\n\nTheory:\n    Last In, First Out (LIFO).\n    Operations: push, pop, peek, is_empty.\n    \n    Implementations:\n    1. Python List: Simplest (`append`, `pop`). Dynamic array.\n    2. Arrays: Fixed size size logic (if simulation needed).\n    \n    Complexity:\n    - Push/Pop: O(1) amortized.\n\"\"\"\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"Pop from empty stack\")\n        return self.items.pop()\n\n    def peek(self):\n        if self.is_empty():\n            raise IndexError(\"Peek from empty stack\")\n        return self.items[-1]\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n    def size(self):\n        return len(self.items)\n\ndef run_tests():\n    s = Stack()\n    s.push(10)\n    s.push(20)\n    \n    assert s.peek() == 20\n    assert s.pop() == 20\n    assert s.pop() == 10\n    assert s.is_empty()\n    \n    try:\n        s.pop()\n    except IndexError:\n        print(\"Caught expected empty stack error\")\n    \n    print(\"[PASS] Stack implementation\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/trees_binary_tree_basics.py", "title": "trees binary tree basics", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/trees_binary_tree_basics.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Binary Tree Basics\nTopic: Data Structures\n\nTheory:\n    Hierarchical structure.\n    Traversals:\n    - Preorder (Root, Left, Right)\n    - Inorder (Left, Root, Right)\n    - Postorder (Left, Right, Root)\n    - Level Order (BFS)\n\"\"\"\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder_traversal(root):\n    res = []\n    if root:\n        res = inorder_traversal(root.left)\n        res.append(root.val)\n        res = res + inorder_traversal(root.right)\n    return res\n\ndef preorder_traversal(root):\n    res = []\n    if root:\n        res.append(root.val)\n        res = res + preorder_traversal(root.left)\n        res = res + preorder_traversal(root.right)\n    return res\n\ndef postorder_traversal(root):\n    res = []\n    if root:\n        res = res + postorder_traversal(root.left)\n        res = res + postorder_traversal(root.right)\n        res.append(root.val)\n    return res\n\ndef run_tests():\n    #      1\n    #     / \\\n    #    2   3\n    #   / \\\n    #  4   5\n    \n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    \n    assert inorder_traversal(root) == [4, 2, 5, 1, 3]\n    assert preorder_traversal(root) == [1, 2, 4, 5, 3]\n    assert postorder_traversal(root) == [4, 5, 2, 3, 1]\n    \n    print(\"[PASS] Binary Tree traversals\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/trees_bst_operations.py", "title": "trees bst operations", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Intermediate_Data_Structures/trees_bst_operations.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Intermediate Data Structures"], "content": "\"\"\"\nTitle: Binary Search Tree (BST)\nTopic: Data Structures\n\nTheory:\n    Properties:\n    - Left subtree keys < Root key\n    - Right subtree keys > Root key\n    \n    Complexity: O(h) where h is height.\n    Worst case O(n) (Skewed tree).\n\"\"\"\n\nclass TreeNode:\n    def __init__(self, val=0):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef insert(root, key):\n    if root is None:\n        return TreeNode(key)\n    \n    if key < root.val:\n        root.left = insert(root.left, key)\n    else:\n        root.right = insert(root.right, key)\n    return root\n\ndef search(root, key):\n    if root is None or root.val == key:\n        return root\n    \n    if key < root.val:\n        return search(root.left, key)\n    return search(root.right, key)\n\ndef run_tests():\n    root = None\n    keys = [50, 30, 20, 40, 70, 60, 80]\n    for k in keys:\n        root = insert(root, k)\n        \n    found = search(root, 60)\n    assert found is not None\n    assert found.val == 60\n    \n    not_found = search(root, 99)\n    assert not_found is None\n    \n    print(\"[PASS] BST Operations\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_chinese_remainder_theorem.py", "title": "number theory chinese remainder theorem", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_chinese_remainder_theorem.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Number Theory"], "content": "\"\"\"\nTitle: Chinese Remainder Theorem (CRT)\nTopic: Number Theory\n\nTheory:\n    Find x such that:\n    x = a1 (mod n1)\n    x = a2 (mod n2)\n    ...\n    Assumption: n1, n2... are pairwise coprime.\n    \n    Formula: x = sum(ai * Ni * mi) (mod N)\n    where N = prod(ni), Ni = N/ni, mi = inv(Ni, ni).\n\"\"\"\n\ndef mod_inverse(a, m):\n    # Minimal extended euclidean implementation\n    m0, x0, x1 = m, 0, 1\n    if m == 1: return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0: x1 += m0\n    return x1\n\ndef chinese_remainder_theorem(remainders, mods):\n    # x = remainders[i] mod mods[i]\n    total_product = 1\n    for m in mods:\n        total_product *= m\n        \n    result = 0\n    for r, m in zip(remainders, mods):\n        Ni = total_product // m\n        inv = mod_inverse(Ni, m)\n        result += r * Ni * inv\n        \n    return result % total_product\n\ndef run_tests():\n    # x = 2 mod 3\n    # x = 3 mod 5\n    # x = 2 mod 7\n    # 23 % 3 = 2. 23 % 5 = 3. 23 % 7 = 2.\n    assert chinese_remainder_theorem([2, 3, 2], [3, 5, 7]) == 23\n    print(\"[PASS] CRT\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_fast_exponentiation.py", "title": "number theory fast exponentiation", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_fast_exponentiation.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Number Theory"], "content": "\"\"\"\nTitle: Fast Exponentiation (Modular Exponentiation)\nTopic: Number Theory\n\nTheory:\n    Compute (base^exp) % mod efficiently.\n    O(log exp).\n    Using binary representation of exp.\n\"\"\"\n\ndef power(base, exp, mod):\n    res = 1\n    base = base % mod\n    while exp > 0:\n        if exp % 2 == 1: # Odd\n            res = (res * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return res\n\ndef run_tests():\n    # 2^10 = 1024. 1024 % 1000 = 24.\n    assert power(2, 10, 1000) == 24\n    print(\"[PASS] Fast Exponentiation\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_gcd_lcm_euclidean.py", "title": "number theory gcd lcm euclidean", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_gcd_lcm_euclidean.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Number Theory"], "content": "\"\"\"\nTitle: GCD and LCM (Euclidean Algorithm)\nTopic: Number Theory\n\nTheory:\n    GCD (Greatest Common Divisor): Largest number dividing both a and b.\n    LCM (Least Common Multiple): Smallest number divisible by both.\n    \n    Formula: a * b = GCD(a, b) * LCM(a, b).\n    \n    Euclidean Algorithm:\n    gcd(a, b) = gcd(b, a % b).\n\"\"\"\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    if a == 0 or b == 0: return 0\n    return abs(a * b) // gcd(a, b)\n\ndef gcd_extended(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm.\n    Returns (g, x, y) such that ax + by = g = gcd(a, b).\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    \n    g, x1, y1 = gcd_extended(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return g, x, y\n\ndef run_tests():\n    assert gcd(48, 18) == 6\n    assert lcm(4, 5) == 20\n    \n    g, x, y = gcd_extended(35, 15)\n    # 35x + 15y = 5.\n    # 35(1) + 15(-2) = 35 - 30 = 5.\n    assert g == 5\n    assert 35*x + 15*y == 5\n    \n    print(\"[PASS] GCD and LCM\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_modular_arithmetic.py", "title": "number theory modular arithmetic", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_modular_arithmetic.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Number Theory"], "content": "\"\"\"\nTitle: Modular Arithmetic\nTopic: Number Theory\n\nTheory:\n    (a + b) % m = ((a % m) + (b % m)) % m\n    (a * b) % m = ((a % m) * (b % m)) % m\n    \n    Modular Inverse:\n    (a / b) % m -> a * inv(b) % m.\n    inv(b) exists only if gcd(b, m) = 1.\n    If m is prime, inv(b) = b^(m-2) % m (Fermat's Little Theorem).\n\"\"\"\n\ndef mod_add(a, b, m):\n    return (a + b) % m\n\ndef mod_mul(a, b, m):\n    return (a * b) % m\n\ndef mod_inverse(a, m):\n    # Setup for extended GCD\n    def egcd(a, b):\n        if a == 0: return b, 0, 1\n        g, x1, y1 = egcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return g, x, y\n\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise ValueError(\"Inverse doesn't exist\")\n    return (x % m + m) % m\n\ndef run_tests():\n    # 3 * x = 1 (mod 11). x = 4. (3*4 = 12 = 1 mod 11)\n    assert mod_inverse(3, 11) == 4\n    \n    print(\"[PASS] Modular Arithmetic\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_prime_factorization.py", "title": "number theory prime factorization", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_prime_factorization.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Number Theory"], "content": "\"\"\"\nTitle: Prime Factorization\nTopic: Number Theory\n\nTheory:\n    Express a number as a product of prime numbers.\n    Trial division method: Check divisibility by d from 2 up to sqrt(n).\n\"\"\"\n\ndef prime_factorization(n):\n    factors = []\n    # 1. 2s\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n        \n    # 2. Odds starting 3\n    d = 3\n    while d * d <= n:\n        while n % d == 0:\n            factors.append(d)\n            n //= d\n        d += 2\n        \n    # 3. Remaining prime > 2\n    if n > 2:\n        factors.append(n)\n        \n    return factors\n\ndef run_tests():\n    assert prime_factorization(315) == [3, 3, 5, 7] # 9*5*7 = 45*7 = 315\n    print(\"[PASS] Prime Factorization\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_primes_sieve_of_eratosthenes.py", "title": "number theory primes sieve of eratosthenes", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Number_Theory/number_theory_primes_sieve_of_eratosthenes.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Number Theory"], "content": "\"\"\"\nTitle: Sieve of Eratosthenes (Primes)\nTopic: Number Theory\n\nTheory:\n    Generate all primes up to N efficiently.\n    Iteratively mark multiples of each prime as composite.\n    \n    Complexity: O(N log log N).\n\"\"\"\n\ndef sieve_of_eratosthenes(n):\n    primes = [True for _ in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if primes[p] == True:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n        \n    primes[0] = False\n    primes[1] = False # 1 is not prime\n    return [p for p in range(n + 1) if primes[p]]\n\ndef run_tests():\n    p = sieve_of_eratosthenes(30)\n    assert p == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    print(\"[PASS] Sieve of Eratosthenes\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/branch_and_bound_tsp.py", "title": "branch and bound tsp", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/branch_and_bound_tsp.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Paradigms Advanced"], "content": "\"\"\"\nTitle: Branch and Bound (TSP)\nTopic: Paradigms\n\nTheory:\n    Optimization problems.\n    Explore branches of state space tree.\n    Compute lower/upper bound. Prune if bound is worse than current best solution.\n    \n    Demo: TSP simplified logic explanation (Full TSP B&B is huge).\n\"\"\"\n\n# Very simplified B&B demonstration for Assignment Problem or similar\n# Implementing a small exhaustive search with pruning logic for TSP\n# 4 cities. \n\ndef tsp_bnb(graph):\n    n = len(graph)\n    visited = [False] * n\n    visited[0] = True\n    min_cost = [float('inf')]\n    \n    def backtrack(curr, count, cost):\n        if count == n and graph[curr][0] > 0:\n            min_cost[0] = min(min_cost[0], cost + graph[curr][0])\n            return\n\n        # Pruning\n        if cost >= min_cost[0]:\n            return\n\n        for i in range(n):\n            if not visited[i] and graph[curr][i] > 0:\n                visited[i] = True\n                backtrack(i, count + 1, cost + graph[curr][i])\n                visited[i] = False\n\n    backtrack(0, 1, 0)\n    return min_cost[0]\n\ndef run_tests():\n    # 0 --10-- 1\n    # |      / |\n    # 20   35  25\n    # |  /     |\n    # 3 --30-- 2\n    # Matrix:\n    #   0   1   2   3\n    # 0 0   10  15  20\n    # 1 10  0   35  25\n    # 2 15  35  0   30\n    # 3 20  25  30  0\n    \n    graph = [\n        [0, 10, 15, 20],\n        [10, 0, 35, 25],\n        [15, 35, 0, 30],\n        [20, 25, 30, 0]\n    ]\n    # Path: 0->1->3->2->0 = 10+25+30+15 = 80\n    # Path: 0->2->3->1->0 = 15+30+25+10 = 80\n    # Path: 0->1->2->3->0 = 10+35+30+20 = 95\n    \n    res = tsp_bnb(graph)\n    assert res == 80\n    print(\"[PASS] Branch and Bound TSP\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/divide_and_conquer_strategies.py", "title": "divide and conquer strategies", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/divide_and_conquer_strategies.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Paradigms Advanced"], "content": "\"\"\"\nTitle: Divide and Conquer Strategies\nTopic: Paradigms\n\nTheory:\n    Break problem into subproblems, solve them, and merge.\n    Examples: Merge Sort, Quick Sort, Binary Search.\n    \n    Demo: Maximum Subarray Sum (O(N log N) vs Kandane O(N)).\n\"\"\"\n\ndef max_crossing_sum(arr, l, m, h):\n    sm = 0\n    left_sum = float('-inf')\n    for i in range(m, l - 1, -1):\n        sm += arr[i]\n        if sm > left_sum:\n            left_sum = sm\n            \n    sm = 0\n    right_sum = float('-inf')\n    for i in range(m + 1, h + 1):\n        sm += arr[i]\n        if sm > right_sum:\n            right_sum = sm\n            \n    return left_sum + right_sum\n\ndef max_subarray_dc(arr, l, h):\n    if l == h:\n        return arr[l]\n        \n    m = (l + h) // 2\n    return max(\n        max_subarray_dc(arr, l, m),\n        max_subarray_dc(arr, m + 1, h),\n        max_crossing_sum(arr, l, m, h)\n    )\n\ndef run_tests():\n    arr = [-2, -5, 6, -2, -3, 1, 5, -6]\n    # Max subarray: 6, -2, -3, 1, 5 = 7.\n    assert max_subarray_dc(arr, 0, len(arr)-1) == 7\n    print(\"[PASS] Divide and Conquer Max Subarray\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/local_search_simulated_annealing.py", "title": "local search simulated annealing", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/local_search_simulated_annealing.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Paradigms Advanced"], "content": "\"\"\"\nTitle: Local Search (Simulated Annealing)\nTopic: Paradigms\n\nTheory:\n    Heuristic optimization.\n    Start with random solution. Move to neighbor.\n    If neighbor better, accept.\n    If neighbor worse, accept with prob exp(-delta/T).\n    Cool down T.\n\"\"\"\n\nimport math\nimport random\n\ndef objective_function(x):\n    # Min at x=0\n    return x**2\n\ndef simulated_annealing():\n    current_x = random.uniform(-10, 10)\n    current_cost = objective_function(current_x)\n    \n    temp = 100.0\n    cooling_rate = 0.99\n    \n    while temp > 0.1:\n        new_x = current_x + random.uniform(-1, 1)\n        new_cost = objective_function(new_x)\n        \n        if new_cost < current_cost:\n            current_x = new_x\n            current_cost = new_cost\n        else:\n            delta = new_cost - current_cost\n            prob = math.exp(-delta / temp)\n            if random.random() < prob:\n                current_x = new_x\n                current_cost = new_cost\n        \n        temp *= cooling_rate\n        \n    return current_x\n\ndef run_tests():\n    # Should be close to 0\n    res = simulated_annealing()\n    assert abs(res) < 2.0 # Allow some margin for heuristic\n    print(f\"Annealing Result: {res}\")\n    print(\"[PASS] Simulated Annealing\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/network_flow_edmonds_karp.py", "title": "network flow edmonds karp", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/network_flow_edmonds_karp.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Paradigms Advanced"], "content": "\"\"\"\nTitle: Edmonds-Karp Algorithm (Max Flow)\nTopic: Paradigms\n\nTheory:\n    Implementation of Ford-Fulkerson using BFS.\n    Guarantees shortest augmenting path (in terms of edges).\n    Complexity: O(V * E^2).\n\"\"\"\n\nfrom collections import deque\n\nclass GraphEK:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n        \n    def bfs(self, s, t, parent):\n        visited = [False] * self.ROW\n        queue = deque([s])\n        visited[s] = True\n        parent[s] = -1\n        \n        while queue:\n            u = queue.popleft()\n            for v, cap in enumerate(self.graph[u]):\n                if not visited[v] and cap > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n                    if v == t: return True\n        return False\n        \n    def edmonds_karp(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n        \n        while self.bfs(source, sink, parent):\n            path_flow = float('inf')\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n                \n            max_flow += path_flow\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n        return max_flow\n\ndef run_tests():\n    # Same graph\n    graph = [\n        [0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]\n    ]\n    g = GraphEK(graph)\n    assert g.edmonds_karp(0, 5) == 23\n    print(\"[PASS] Edmonds Karp\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/network_flow_ford_fulkerson.py", "title": "network flow ford fulkerson", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/network_flow_ford_fulkerson.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Paradigms Advanced"], "content": "\"\"\"\nTitle: Ford-Fulkerson Algorithm (Max Flow)\nTopic: Paradigms\n\nTheory:\n    Computes Max Flow in valid flow network.\n    Iteratively find augmenting paths in Residual Graph and add flow.\n    Uses DFS (which can be slow, O(E*f*), hence Edmonds-Karp is preferred).\n\"\"\"\n\nclass GraphFF:\n    def __init__(self, graph):\n        self.graph = graph\n        self.ROW = len(graph)\n        \n    def dfs(self, u, t, visited, parent):\n        visited[u] = True\n        if u == t: return True\n        \n        for v, capacity in enumerate(self.graph[u]):\n            if not visited[v] and capacity > 0:\n                parent[v] = u\n                if self.dfs(v, t, visited, parent):\n                    return True\n        return False\n        \n    def ford_fulkerson(self, source, sink):\n        parent = [-1] * self.ROW\n        max_flow = 0\n        \n        # While there is a path from s to t\n        while True:\n            visited = [False] * self.ROW\n            if not self.dfs(source, sink, visited, parent):\n                break\n                \n            path_flow = float('inf')\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, self.graph[parent[s]][s])\n                s = parent[s]\n                \n            max_flow += path_flow\n            \n            # Update residual graph\n            v = sink\n            while v != source:\n                u = parent[v]\n                self.graph[u][v] -= path_flow\n                self.graph[v][u] += path_flow\n                v = parent[v]\n                \n        return max_flow\n\ndef run_tests():\n    # 0 -> 1 (16), 0 -> 2 (13)\n    # 1 -> 2 (10), 1 -> 3 (12)\n    # 2 -> 1 (4), 2 -> 4 (14)\n    # 3 -> 2 (9), 3 -> 5 (20)\n    # 4 -> 3 (7), 4 -> 5 (4)\n    graph = [\n        [0, 16, 13, 0, 0, 0],\n        [0, 0, 10, 12, 0, 0],\n        [0, 4, 0, 0, 14, 0],\n        [0, 0, 9, 0, 0, 20],\n        [0, 0, 0, 7, 0, 4],\n        [0, 0, 0, 0, 0, 0]\n    ]\n    g = GraphFF(graph)\n    assert g.ford_fulkerson(0, 5) == 23\n    print(\"[PASS] Ford Fulkerson\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/randomized_algorithms_quicksort_select.py", "title": "randomized algorithms quicksort select", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Paradigms_Advanced/randomized_algorithms_quicksort_select.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Paradigms Advanced"], "content": "\"\"\"\nTitle: Randomized Algorithms (Quickselect)\nTopic: Paradigms\n\nTheory:\n    Quickselect: Find kth smallest element in O(N) average.\n    Uses Random Pivot Partitioning.\n\"\"\"\n\nimport random\n\ndef partition(arr, l, r):\n    pivot_idx = random.randint(l, r)\n    arr[r], arr[pivot_idx] = arr[pivot_idx], arr[r]\n    pivot = arr[r]\n    \n    i = l\n    for j in range(l, r):\n        if arr[j] <= pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    arr[i], arr[r] = arr[r], arr[i]\n    return i\n\ndef quickselect(arr, l, r, k):\n    if l <= r:\n        pi = partition(arr, l, r)\n        \n        if pi == k:\n            return arr[pi]\n        elif pi < k:\n            return quickselect(arr, pi + 1, r, k)\n        else:\n            return quickselect(arr, l, pi - 1, k)\n    return None\n\ndef run_tests():\n    arr = [10, 4, 5, 8, 6, 11, 26]\n    # Sorted: 4, 5, 6, 8, 10, 11, 26\n    # k=0 (smallest) -> 4\n    # k=3 (4th smallest) -> 8\n    \n    assert quickselect(arr.copy(), 0, len(arr)-1, 0) == 4\n    assert quickselect(arr.copy(), 0, len(arr)-1, 3) == 8\n    \n    print(\"[PASS] Quickselect\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Parallel_Concurrent/parallel_map_reduce_concept.py", "title": "parallel map reduce concept", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Parallel_Concurrent/parallel_map_reduce_concept.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Parallel Concurrent"], "content": "\"\"\"\nTitle: Map Reduce Concept\nTopic: Parallel and Concurrent Algorithms\n\nTheory:\n    Pattern:\n    1. Map: Process input elements independently -> (key, value) pairs.\n    2. Reduce: Aggregate values for same key.\n    \n    Python `multiprocessing.Pool.map` is a simplified Parallel Map.\n\"\"\"\n\nimport multiprocessing\nfrom functools import reduce\n\ndef mapper_word_count(text):\n    # Returns dictionary of word counts for a chunk\n    counts = {}\n    for word in text.split():\n        counts[word] = counts.get(word, 0) + 1\n    return counts\n\ndef reducer_merge(counts1, counts2):\n    # Merge two count dicts\n    result = counts1.copy()\n    for k, v in counts2.items():\n        result[k] = result.get(k, 0) + v\n    return result\n\ndef run_map_reduce():\n    texts = [\n        \"apple banana apple\",\n        \"banana cherry\",\n        \"apple cherry date\"\n    ]\n    \n    # 1. Parallel Map\n    with multiprocessing.Pool(3) as p:\n        mapped_results = p.map(mapper_word_count, texts)\n        \n    # 2. Reduce (Sequential merge here for simplicity)\n    final_counts = reduce(reducer_merge, mapped_results)\n    \n    assert final_counts['apple'] == 4 # Actually 3! \"apple\" in text1 (2), text3 (1) -> 3\n    # Wait, \"apple banana apple\" = 2. \"apple cherry date\" = 1. yes 3.\n    # What was I thinking? 2+1=3.\n    \n    assert final_counts['apple'] == 3\n    assert final_counts['banana'] == 2\n    \n    print(\"[PASS] Map Reduce\")\n\nif __name__ == \"__main__\":\n    run_map_reduce()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Parallel_Concurrent/parallel_multiprocessing_vs_threading_detailed.py", "title": "parallel multiprocessing vs threading detailed", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Parallel_Concurrent/parallel_multiprocessing_vs_threading_detailed.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Parallel Concurrent"], "content": "\"\"\"\nTitle: Multiprocessing vs Threading\nTopic: Parallel and Concurrent Algorithms\n\nTheory:\n    Key Differences:\n    - Threading: Shared memory, lower overhead, limited by GIL (CPU bound), good for I/O.\n    - Multiprocessing: Separate memory, higher overhead, bypasses GIL, good for CPU bound.\n\"\"\"\n\nimport time\nimport threading\nimport multiprocessing\n\ndef cpu_bound(n):\n    while n > 0:\n        n -= 1\n\ndef run_comparison():\n    COUNT = 10000000\n    \n    # Serial\n    start = time.time()\n    cpu_bound(COUNT)\n    cpu_bound(COUNT)\n    print(f\"Serial time: {time.time() - start:.4f}\")\n    \n    # Threading (Won't improve speed much due to GIL)\n    start = time.time()\n    t1 = threading.Thread(target=cpu_bound, args=(COUNT,))\n    t2 = threading.Thread(target=cpu_bound, args=(COUNT,))\n    t1.start(); t2.start()\n    t1.join(); t2.join()\n    print(f\"Threading time: {time.time() - start:.4f} (Often similar to serial)\")\n    \n    # Multiprocessing (Should be faster ~2x ideally)\n    if __name__ == \"__main__\": \n        # Only run MP logic if main\n        start = time.time()\n        p1 = multiprocessing.Process(target=cpu_bound, args=(COUNT,))\n        p2 = multiprocessing.Process(target=cpu_bound, args=(COUNT,))\n        p1.start(); p2.start()\n        p1.join(); p2.join()\n        print(f\"Multiprocessing time: {time.time() - start:.4f} (Better)\")\n\nif __name__ == \"__main__\":\n    # Note: MP requires if __name__ == \"__main__\"\n    run_comparison()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/bloom_filter_basics.py", "title": "bloom filter basics", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/bloom_filter_basics.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Rare Data Structures"], "content": "\"\"\"\nTitle: Bloom Filter\nTopic: Rare Data Structures\n\nTheory:\n    Probabilistic data structure for set membership.\n    False Positives possible. False Negatives IMPOSSIBLE.\n    Uses multiple hash functions and a bit array.\n\"\"\"\n\nimport hashlib\n\nclass BloomFilter:\n    def __init__(self, size, hash_count):\n        self.size = size\n        self.hash_count = hash_count\n        self.bit_array = [0] * size\n\n    def _get_hashes(self, item):\n        hashes = []\n        digest = hashlib.md5(str(item).encode('utf-8')).hexdigest()\n        # Create multiple fake independent hashes from one MD5\n        # (Simplified approach)\n        base = int(digest, 16)\n        for i in range(self.hash_count):\n            hashes.append((base + i * 1337) % self.size)\n        return hashes\n\n    def add(self, item):\n        for h in self._get_hashes(item):\n            self.bit_array[h] = 1\n\n    def contains(self, item):\n        for h in self._get_hashes(item):\n            if self.bit_array[h] == 0:\n                return False\n        return True # Possibly True\n\ndef run_tests():\n    bf = BloomFilter(100, 3)\n    bf.add(\"apple\")\n    bf.add(\"banana\")\n    \n    assert bf.contains(\"apple\")\n    assert bf.contains(\"banana\")\n    assert not bf.contains(\"cherry\") # Small chance of False Positive, but with 100 bits vs 2 items, practically 0\n    print(\"[PASS] Bloom Filter\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/cache_lru_implementation.py", "title": "cache lru implementation", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/cache_lru_implementation.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Rare Data Structures"], "content": "\"\"\"\nTitle: LRU Cache Implementation\nTopic: Rare Data Structures\n\nTheory:\n    Least Recently Used cache eviction policy.\n    Uses Hash Map + Doubly Linked List.\n    Get/Put: O(1).\n    Python's `OrderedDict` makes this trivial, but we implement manually or wrap it.\n\"\"\"\n\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key) # Mark as recently used\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False) # Remove first (least recent)\n\ndef run_tests():\n    lru = LRUCache(2)\n    lru.put(1, 1)\n    lru.put(2, 2)\n    assert lru.get(1) == 1 # 1 moved to end. Order: 2, 1\n    \n    lru.put(3, 3) # Evicts 2 (Least recent)\n    assert lru.get(2) == -1\n    \n    lru.put(4, 4) # Evicts 1 (Least recent, since 3 was put)\n    # Order was 1, 3. Now 3, 4.\n    assert lru.get(1) == -1\n    assert lru.get(3) == 3\n    assert lru.get(4) == 4\n    \n    print(\"[PASS] LRU Cache\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/list_skip_list.py", "title": "list skip list", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/list_skip_list.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Rare Data Structures"], "content": "\"\"\"\nTitle: Skip List\nTopic: Rare Data Structures\n\nTheory:\n    Probabilistic data structure. Alternative to balanced trees.\n    Multiple layers of linked lists.\n    Search/Insert/Delete: O(log n) average.\n    Space: O(n).\n\"\"\"\n\nimport random\n\nclass Node:\n    def __init__(self, key, level):\n        self.key = key\n        self.forward = [None] * (level + 1)\n\nclass SkipList:\n    def __init__(self, max_level, p):\n        self.max_level = max_level\n        self.p = p\n        self.header = Node(-1, max_level)\n        self.level = 0\n        \n    def random_level(self):\n        lvl = 0\n        while random.random() < self.p and lvl < self.max_level:\n            lvl += 1\n        return lvl\n\n    def insert(self, key):\n        update = [None] * (self.max_level + 1)\n        curr = self.header\n        \n        for i in range(self.level, -1, -1):\n            while curr.forward[i] and curr.forward[i].key < key:\n                curr = curr.forward[i]\n            update[i] = curr\n            \n        curr = curr.forward[0]\n        \n        if curr is None or curr.key != key:\n            rlevel = self.random_level()\n            if rlevel > self.level:\n                for i in range(self.level + 1, rlevel + 1):\n                    update[i] = self.header\n                self.level = rlevel\n                \n            new_node = Node(key, rlevel)\n            for i in range(rlevel + 1):\n                new_node.forward[i] = update[i].forward[i]\n                update[i].forward[i] = new_node\n\n    def search(self, key):\n        curr = self.header\n        for i in range(self.level, -1, -1):\n            while curr.forward[i] and curr.forward[i].key < key:\n                curr = curr.forward[i]\n        curr = curr.forward[0]\n        if curr and curr.key == key:\n            return True\n        return False\n\ndef run_tests():\n    sl = SkipList(3, 0.5)\n    sl.insert(3)\n    sl.insert(6)\n    sl.insert(7)\n    sl.insert(9)\n    # 3, 6, 7, 9\n    \n    assert sl.search(3)\n    assert sl.search(6)\n    assert not sl.search(10)\n    \n    print(\"[PASS] Skip List\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_fenwick_tree.py", "title": "tree fenwick tree", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_fenwick_tree.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Rare Data Structures"], "content": "\"\"\"\nTitle: Fenwick Tree (Binary Indexed Tree)\nTopic: Rare Data Structures\n\nTheory:\n    Prefix sums and updates in O(log n).\n    `update(i, delta)`: Adds delta to element at i.\n    `query(i)`: Returns sum from 0 to i.\n\"\"\"\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.tree = [0] * (size + 1)\n\n    def update(self, i, delta):\n        # 1-based indexing used internally often\n        i += 1 \n        while i < len(self.tree):\n            self.tree[i] += delta\n            i += i & (-i)\n\n    def query(self, i):\n        i += 1\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & (-i)\n        return s\n\ndef run_tests():\n    # [1, 2, 3, 4]\n    ft = FenwickTree(4)\n    data = [1, 2, 3, 4]\n    for i, x in enumerate(data):\n        ft.update(i, x)\n        \n    # Sum(0..2) = 1+2+3 = 6\n    assert ft.query(2) == 6\n    # Sum(0..3) = 10\n    assert ft.query(3) == 10\n    \n    # Update index 1 by +2 (becomes 4) -> [1, 4, 3, 4]\n    ft.update(1, 2)\n    # Sum(0..2) = 1+4+3 = 8\n    assert ft.query(2) == 8\n    \n    print(\"[PASS] Fenwick Tree\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_segment_tree.py", "title": "tree segment tree", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_segment_tree.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Rare Data Structures"], "content": "\"\"\"\nTitle: Segment Tree\nTopic: Rare Data Structures\n\nTheory:\n    Range Queries (Min, Max, Sum) with Updates.\n    Tree structure where leaves are array elements.\n    O(log n) per op.\n\"\"\"\n\nclass SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.tree = [0] * (4 * self.n)\n        self._build(data, 0, 0, self.n - 1)\n\n    def _build(self, data, node, start, end):\n        if start == end:\n            self.tree[node] = data[start]\n        else:\n            mid = (start + end) // 2\n            self._build(data, 2 * node + 1, start, mid)\n            self._build(data, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] # Sum Query Example\n\n    def update(self, idx, val):\n        self._update(0, 0, self.n - 1, idx, val)\n\n    def _update(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self._update(2 * node + 1, start, mid, idx, val)\n            else:\n                self._update(2 * node + 2, mid + 1, end, idx, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n\n    def query(self, l, r):\n        return self._query(0, 0, self.n - 1, l, r)\n\n    def _query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        p1 = self._query(2 * node + 1, start, mid, l, r)\n        p2 = self._query(2 * node + 2, mid + 1, end, l, r)\n        return p1 + p2\n\ndef run_tests():\n    data = [1, 3, 5, 7, 9, 11]\n    st = SegmentTree(data)\n    \n    # Sum(1..3) = 3+5+7 = 15\n    assert st.query(1, 3) == 15\n    \n    st.update(1, 10)\n    # Sum(1..3) = 10+5+7 = 22\n    assert st.query(1, 3) == 22\n    \n    print(\"[PASS] Segment Tree\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_treap.py", "title": "tree treap", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/Rare_Data_Structures/tree_treap.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "Rare Data Structures"], "content": "\"\"\"\nTitle: Treap (Tree + Heap)\nTopic: Rare Data Structures\n\nTheory:\n    Randomized Binary Search Tree.\n    Each node has a Key (BST property) and Priority (Heap property).\n    Priorities are random -> High probability of O(log n) height.\n    operations: Split and Merge.\n\"\"\"\n\nimport random\n\nclass TreapNode:\n    def __init__(self, key):\n        self.key = key\n        self.priority = random.random()\n        self.left = None\n        self.right = None\n\ndef split(root, key):\n    \"\"\"\n    Splits treap into two:\n    - Left: Keys <= key\n    - Right: Keys > key\n    \"\"\"\n    if root is None:\n        return None, None\n    \n    if root.key <= key:\n        right_split, remaining = split(root.right, key)\n        root.right = right_split\n        return root, remaining\n    else:\n        left_split, remaining = split(root.left, key)\n        root.left = remaining\n        return left_split, root\n\ndef merge(left, right):\n    \"\"\"\n    Merges two treaps (all keys in left < all keys in right).\n    \"\"\"\n    if left is None: return right\n    if right is None: return left\n    \n    if left.priority > right.priority: # Max Heap\n        left.right = merge(left.right, right)\n        return left\n    else:\n        right.left = merge(left, right.left)\n        return right\n\ndef insert(root, key):\n    if root is None:\n        return TreapNode(key)\n    \n    # Split by key\n    left, right = split(root, key)\n    # Insert new node in middle\n    new_node = TreapNode(key)\n    return merge(merge(left, new_node), right)\n\ndef traverse(root, res):\n    if root:\n        traverse(root.left, res)\n        res.append(root.key)\n        traverse(root.right, res)\n\ndef run_tests():\n    root = None\n    keys = [10, 20, 5, 80, 40]\n    for k in keys:\n        root = insert(root, k)\n        \n    res = []\n    traverse(root, res)\n    assert res == sorted(keys)\n    print(\"[PASS] Treap Insertion and Traversal\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_kmp_algorithm.py", "title": "strings kmp algorithm", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_kmp_algorithm.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "String Algorithms"], "content": "\"\"\"\nTitle: KMP Algorithm (Knuth-Morris-Pratt)\nTopic: String Algorithms\n\nTheory:\n    Pattern searching that avoids unnecessary comparisons using LPS array (Longest Prefix Suffix).\n    LPS[i] = length of the longest proper prefix of pat[0..i] that is also a suffix of pat[0..i].\n    \n    Complexity: O(N) time, O(M) space.\n\"\"\"\n\ndef compute_lps(pattern):\n    m = len(pattern)\n    lps = [0] * m\n    length = 0 # Length of previous longest prefix suffix\n    i = 1\n    \n    while i < m:\n        if pattern[i] == pattern[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\n\ndef kmp_search(text, pattern):\n    n = len(text)\n    m = len(pattern)\n    lps = compute_lps(pattern)\n    matches = []\n    \n    i = 0 # text index\n    j = 0 # pattern index\n    while i < n:\n        if pattern[j] == text[i]:\n            i += 1\n            j += 1\n        \n        if j == m:\n            matches.append(i - j)\n            j = lps[j - 1]\n        elif i < n and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return matches\n\ndef run_tests():\n    txt = \"ABABDABACDABABCABAB\"\n    pat = \"ABABCABAB\"\n    matches = kmp_search(txt, pat)\n    assert matches == [10]\n    print(\"[PASS] KMP Search\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_longest_palindromic_substring.py", "title": "strings longest palindromic substring", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_longest_palindromic_substring.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "String Algorithms"], "content": "\"\"\"\nTitle: Longest Palindromic Substring\nTopic: String Algorithms\n\nTheory:\n    Find the longest substring which is a palindrome.\n    Approaches:\n    1. DP: O(N^2).\n    2. Expand Around Center: O(N^2) but O(1) space.\n    3. Manacher's Algorithm: O(N) (Too complex for basic study repo usually, implementing Expand Center).\n\"\"\"\n\ndef longest_palindrome_expand(s):\n    if not s: return \"\"\n    start, end = 0, 0\n    \n    for i in range(len(s)):\n        # Odd length\n        len1 = expand_around_center(s, i, i)\n        # Even length\n        len2 = expand_around_center(s, i, i + 1)\n        max_len = max(len1, len2)\n        \n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n            \n    return s[start:end+1]\n\ndef expand_around_center(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1\n\ndef run_tests():\n    s = \"babad\"\n    res = longest_palindrome_expand(s)\n    # \"bab\" or \"aba\"\n    assert res in [\"bab\", \"aba\"]\n    \n    print(\"[PASS] Longest Palindrome\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_pattern_matching_naive.py", "title": "strings pattern matching naive", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_pattern_matching_naive.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "String Algorithms"], "content": "\"\"\"\nTitle: Naive Pattern Searching\nTopic: String Algorithms\n\nTheory:\n    Slide the pattern over text one by one and check for a match.\n    \n    Complexity: O(M * (N - M + 1)) -> O(N*M) worst case.\n    Best case (no match): O(N).\n\"\"\"\n\ndef naive_search(text, pattern):\n    n = len(text)\n    m = len(pattern)\n    matches = []\n    \n    for i in range(n - m + 1):\n        if text[i : i + m] == pattern:\n            matches.append(i)\n    return matches\n\ndef run_tests():\n    txt = \"AABAACAADAABAABA\"\n    pat = \"AABA\"\n    # Matches at 0, 9, 12\n    res = naive_search(txt, pat)\n    assert res == [0, 9, 12]\n    print(\"[PASS] Naive Pattern Search\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_rabin_karp.py", "title": "strings rabin karp", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_rabin_karp.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "String Algorithms"], "content": "\"\"\"\nTitle: Rabin-Karp Algorithm\nTopic: String Algorithms\n\nTheory:\n    Uses Rolling Hash to find exact matches.\n    Calculate hash of pattern and first window of text.\n    Slide window, update hash in O(1).\n    \n    Complexity: O(N + M) average. O(NM) worst case (Hash collisions).\n\"\"\"\n\ndef rabin_karp(text, pattern):\n    d = 256 # Alphabets\n    q = 101 # Prime number\n    n = len(text)\n    m = len(pattern)\n    p = 0 # hash for pattern\n    t = 0 # hash for text\n    h = 1\n    matches = []\n    \n    # h = pow(d, m-1) % q\n    for i in range(m - 1):\n        h = (h * d) % q\n        \n    for i in range(m):\n        p = (d * p + ord(pattern[i])) % q\n        t = (d * t + ord(text[i])) % q\n        \n    for i in range(n - m + 1):\n        if p == t:\n            if text[i:i+m] == pattern:\n                matches.append(i)\n        \n        if i < n - m:\n            t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q\n            if t < 0:\n                t = t + q\n    return matches\n\ndef run_tests():\n    txt = \"GEEKS FOR GEEKS\"\n    pat = \"GEEK\"\n    matches = rabin_karp(txt, pat)\n    assert matches == [0, 10]\n    print(\"[PASS] Rabin-Karp\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_suffix_tree_intro.py", "title": "strings suffix tree intro", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_suffix_tree_intro.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "String Algorithms"], "content": "\"\"\"\nTitle: Suffix Tree (Intro)\nTopic: String Algorithms\n\nTheory:\n    Compressed Trie of all suffixes of the given text.\n    Extremely powerful (Pattern matching O(M), Longest Repeating Substr, etc).\n    \n    Implementation note: Full O(N) Ukkonen's algo is very complex.\n    Here we implement a Naive Suffix Tree (O(N^2)) for educational purpose.\n\"\"\"\n\nclass SuffixTrieNode:\n    def __init__(self):\n        self.children = {}\n        self.indexes = [] # Store starting indexes of suffixes passing through\n\n    def insert(self, suffix, idx):\n        self.indexes.append(idx)\n        if not suffix:\n            return\n        first = suffix[0]\n        if first not in self.children:\n            self.children[first] = SuffixTrieNode()\n        self.children[first].insert(suffix[1:], idx)\n\n    def search(self, pattern):\n        if not pattern:\n            return self.indexes\n        first = pattern[0]\n        if first in self.children:\n            return self.children[first].search(pattern[1:])\n        return []\n\nclass NaiveSuffixTree:\n    def __init__(self, text):\n        self.root = SuffixTrieNode()\n        for i in range(len(text)):\n            self.root.insert(text[i:], i)\n\ndef run_tests():\n    txt = \"banana\"\n    # Suffixes: banana, anana, nana, ana, na, a\n    st = NaiveSuffixTree(txt)\n    \n    # Search \"ana\"\n    idxs = st.root.search(\"ana\")\n    idxs.sort()\n    # \"ana\" starts at 1 (anana), 3 (ana)\n    assert idxs == [1, 3]\n    \n    print(\"[PASS] Suffix Tree Naive\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_trie_basics.py", "title": "strings trie basics", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_trie_basics.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "String Algorithms"], "content": "\"\"\"\nTitle: Trie (Prefix Tree)\nTopic: String Algorithms\n\nTheory:\n    Tree data structure used for storing strings efficiently.\n    Each node represents a character.\n    Useful for: Autocomplete, Spell Checker.\n    \n    Complexity: Insert/Search O(K) where K is key length.\n\"\"\"\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def starts_with(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\ndef run_tests():\n    t = Trie()\n    t.insert(\"apple\")\n    assert t.search(\"apple\") is True\n    assert t.search(\"app\") is False\n    assert t.starts_with(\"app\") is True\n    \n    t.insert(\"app\")\n    assert t.search(\"app\") is True\n    \n    print(\"[PASS] Trie Basics\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_z_algorithm.py", "title": "strings z algorithm", "type": "Code", "path": "python/PythonMasteryRepo/Algorithms/String_Algorithms/strings_z_algorithm.py", "breadcrumbs": ["python", "PythonMasteryRepo", "Algorithms", "String Algorithms"], "content": "\"\"\"\nTitle: Z Algorithm\nTopic: String Algorithms\n\nTheory:\n    Linear time pattern matching.\n    Z-array: Z[i] is the length of the longest substring starting from S[i] which is also a prefix of S.\n    Concat P + \"$\" + T. If Z[i] == len(P), occurrence found.\n    \n    Complexity: O(M + N).\n\"\"\"\n\ndef get_z_array(string):\n    n = len(string)\n    z = [0] * n\n    l, r = 0, 0\n    \n    for i in range(1, n):\n        if i > r:\n            l, r = i, i\n            while r < n and string[r] == string[r - l]:\n                r += 1\n            z[i] = r - l\n            r -= 1\n        else:\n            k = i - l\n            if z[k] < r - i + 1:\n                z[i] = z[k]\n            else:\n                l = i\n                while r < n and string[r] == string[r - l]:\n                    r += 1\n                z[i] = r - l\n                r -= 1\n    return z\n\ndef z_search(text, pattern):\n    concat = pattern + \"$\" + text\n    l = len(concat)\n    z = get_z_array(concat)\n    matches = []\n    \n    for i in range(l):\n        if z[i] == len(pattern):\n            matches.append(i - len(pattern) - 1)\n    return matches\n\ndef run_tests():\n    txt = \"BAABAXAABA\"\n    pat = \"AABA\"\n    matches = z_search(txt, pat)\n    assert matches == [1, 7]\n    print(\"[PASS] Z Algorithm\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Abstraction/abstract_base_classes_abc.py", "title": "abstract base classes abc", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Abstraction/abstract_base_classes_abc.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Abstraction"], "content": "\"\"\"\nTitle: Abstract Base Classes (ABCs)\nTopic: Abstraction\n\nTheory:\n    ABCs define a blueprint for a class. They generally cannot be instantiated.\n    They force subclasses to implement specific methods using `@abstractmethod`.\n\n    Module: `abc`\n    Class: `ABC`\n\"\"\"\n\nfrom abc import ABC, abstractmethod\n\nclass PaymentGateway(ABC):\n    \n    @abstractmethod\n    def authorize(self, amount):\n        pass\n\n    @abstractmethod\n    def charge(self, amount):\n        pass\n    \n    # Concrete method in ABC is allowed\n    def common_log(self, msg):\n        return f\"LOG: {msg}\"\n\nclass Stripe(PaymentGateway):\n    def authorize(self, amount):\n        return f\"Stripe authorized {amount}\"\n\n    def charge(self, amount):\n        return f\"Stripe charged {amount}\"\n\nclass BadGateway(PaymentGateway):\n    # Missing 'charge' implementation\n    def authorize(self, amount):\n        pass\n\ndef run_tests():\n    s = Stripe()\n    assert s.authorize(100) == \"Stripe authorized 100\"\n    assert s.common_log(\"Test\") == \"LOG: Test\"\n\n    try:\n        b = BadGateway()\n    except TypeError as e:\n        print(f\"Caught expected error: {e}\")\n        # \"Can't instantiate abstract class BadGateway with abstract method charge\"\n\n    print(\"[PASS] ABC implementation\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Abstraction/interfaces_via_protocols.py", "title": "interfaces via protocols", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Abstraction/interfaces_via_protocols.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Abstraction"], "content": "\"\"\"\nTitle: Interfaces via Protocols\nTopic: Abstraction\n\nTheory:\n    Python doesn't have an `interface` keyword. \n    Traditionally, ABCs with ONLY abstract methods act as Interfaces.\n    Modern approach: `typing.Protocol`, which allows for \"Implicit Interfaces\" (Go-style).\n\n    Here we show ABC-as-Interface vs Protocol-as-Interface.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Protocol\n\n# ==========================================\n# 1. ABC as Interface (Explicit)\n# ==========================================\n\nclass IRepository(ABC):\n    @abstractmethod\n    def save(self, obj): pass\n    \n    @abstractmethod\n    def get(self, id): pass\n\nclass SQLRepo(IRepository):\n    def save(self, obj): return \"Saved SQL\"\n    def get(self, id): return \"Got SQL\"\n\n# ==========================================\n# 2. Protocol as Interface (Implicit)\n# ==========================================\n\nclass Mailer(Protocol):\n    def send(self, to: str, body: str) -> None:\n        ...\n\nclass SmtpService:\n    # No inheritance from Mailer needed\n    def send(self, to: str, body: str) -> None:\n        print(f\"Sending email to {to}\")\n\ndef trigger_email(service: Mailer):\n    service.send(\"admin@test.com\", \"Alert\")\n\n# ==========================================\n# Tests\n# ==========================================\n\ndef run_tests():\n    # ABC\n    repo = SQLRepo()\n    assert isinstance(repo, IRepository)\n    \n    # Protocol\n    smtp = SmtpService()\n    # Runtime check for protocol is messy without @runtime_checkable, \n    # but static type check works.\n    trigger_email(smtp) # Works\n    \n    print(\"[PASS] Interface patterns\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Abstraction/partial_implementation_andcontract_enforcement.py", "title": "partial implementation andcontract enforcement", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Abstraction/partial_implementation_andcontract_enforcement.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Abstraction"], "content": "\"\"\"\nTitle: Partial Implementation and Contract Enforcement\nTopic: Abstraction\n\nTheory:\n    ABCs can provide partial implementation.\n    This is known as the \"Template Method Pattern\" (not to be confused with C++ Templates).\n    \n    The Base class controls the algorithm structure, but delegates specific steps to subclasses.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\n\nclass DataProcessor(ABC):\n    \n    def process_pipeline(self, data):\n        \"\"\"The Template Method: Defines the skeleton.\"\"\"\n        data = self.read_data(data)\n        data = self.clean_data(data)\n        result = self.analyze_data(data)\n        self.save_result(result)\n        return result\n\n    @abstractmethod\n    def read_data(self, source):\n        pass\n\n    def clean_data(self, data):\n        \"\"\"Hook method with default implementation.\"\"\"\n        print(\"Default cleaning (strip whitespace)\")\n        return data.strip() if isinstance(data, str) else data\n\n    @abstractmethod\n    def analyze_data(self, data):\n        pass\n\n    @abstractmethod\n    def save_result(self, result):\n        pass\n\n\nclass TextProcessor(DataProcessor):\n    def read_data(self, source):\n        return f\"  {source}  \"\n\n    def analyze_data(self, data):\n        return len(data)\n\n    def save_result(self, result):\n        print(f\"Saved count: {result}\")\n\n\ndef run_tests():\n    p = TextProcessor()\n    # flow: read(\"Raw\") -> \"  Raw  \" -> clean -> \"Raw\" -> analyze -> 3 -> save\n    res = p.process_pipeline(\"Raw\")\n    assert res == 3 # Length of \"Raw\"\n    \n    print(\"[PASS] Partial implementation / Template method\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/callable_objects_and_functors.py", "title": "callable objects and functors", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/callable_objects_and_functors.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Callable Objects (Functors)\nTopic: Advanced OOP\n\nTheory:\n    Any object that implements `__call__` can be called like a function.\n    `obj()` translates to `obj.__call__()`.\n    \n    Use cases:\n    - Stateful functions (decorators, callbacks).\n    - Caching/Memoization objects.\n\"\"\"\n\nclass Multiplier:\n    def __init__(self, factor):\n        self.factor = factor\n\n    def __call__(self, value):\n        \"\"\"Allows instance to be called like a function.\"\"\"\n        return value * self.factor\n\nclass CallCounter:\n    def __init__(self):\n        self.count = 0\n    \n    def __call__(self):\n        self.count += 1\n        return self.count\n\ndef run_tests():\n    # 1. Multiplier\n    double = Multiplier(2)\n    triple = Multiplier(3)\n    \n    assert double(10) == 20\n    assert triple(10) == 30\n    \n    # 2. Counter (Stateful)\n    c = CallCounter()\n    assert c() == 1\n    assert c() == 2\n    assert c.count == 2\n    \n    print(\"[PASS] Callable objects verified\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/composition_over_inheritance.py", "title": "composition over inheritance", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/composition_over_inheritance.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Composition over Inheritance\nTopic: Advanced OOP\n\nTheory:\n    \"Has-a\" relationship (Composition) is often more flexible than \"Is-a\" (Inheritance).\n    \n    Inheritance: Tight coupling. Subclass depends on Base internals.\n    Composition: Loose coupling. Object holds reference to another object and delegates tasks.\n    \n    Guideline: Prefer Composition for code reuse. Use Inheritance for polymorphism (Is-a).\n\"\"\"\n\n# ==========================================\n# 1. Inheritance (Rigid)\n# ==========================================\n\nclass Engine:\n    def start(self): return \"Vroom\"\n\nclass CarWithInheritance(Engine):\n    # Car IS-A Engine? No. Bad design.\n    def drive(self):\n        return f\"{self.start()} and go\"\n\n# ==========================================\n# 2. Composition (Flexible)\n# ==========================================\n\nclass ElectricEngine:\n    def start(self): return \"Silent hum\"\n\nclass CarWithComposition:\n    def __init__(self, engine):\n        self.engine = engine # Has-a Engine\n    \n    def drive(self):\n        return f\"{self.engine.start()} and go\"\n\ndef run_tests():\n    # Inheritance\n    c1 = CarWithInheritance()\n    assert c1.drive() == \"Vroom and go\"\n    \n    # Composition - Easy to swap behavior\n    v8 = Engine()\n    tesla_motor = ElectricEngine()\n    \n    c_gas = CarWithComposition(v8)\n    c_ev = CarWithComposition(tesla_motor)\n    \n    assert c_gas.drive() == \"Vroom and go\"\n    assert c_ev.drive() == \"Silent hum and go\"\n    \n    print(\"[PASS] Composition over Inheritance\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/context_manager_protocol.py", "title": "context manager protocol", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/context_manager_protocol.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Context Manager Protocol\nTopic: Advanced OOP\n\nTheory:\n    Context managers manage resources (files, locks, connections) using `with` statement.\n    \n    KEY METHODS:\n    - `__enter__(self)`: Setup resource, return object (as `as var`).\n    - `__exit__(self, exc_type, exc_val, exc_tb)`: Cleanup. Handles exceptions returning True suppresses them.\n\n    Alternative: `contextlib.contextmanager` decorator for function-based managers.\n\"\"\"\n\nclass ManagedFile:\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = None\n\n    def __enter__(self):\n        print(f\"Opening {self.filename}...\")\n        self.file = open(self.filename, 'w')\n        return self.file\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.file:\n            self.file.close()\n        print(f\"Closed {self.filename}.\")\n        \n        if exc_type:\n            print(f\"Exception handled: {exc_val}\")\n            # return True # Uncomment to suppress exception\n            return False\n\ndef run_tests():\n    import os\n    fname = \"test_ctx.txt\"\n    \n    # 1. Normal usage\n    with ManagedFile(fname) as f:\n        f.write(\"Hello\")\n    \n    # Check if closed\n    assert not f.closed # Wait, the file object itself shows closed status? No, we closed it.\n    # Actually 'f' usage after block is risky if not aware. \n    # But checking internal state:\n    try:\n        f.write(\"More\")\n    except ValueError:\n        print(\"File is indeed closed.\")\n        \n    # Cleanup\n    if os.path.exists(fname):\n        os.remove(fname)\n\n    # 2. Exception handling\n    try:\n        with ManagedFile(\"none\") as f:\n            raise RuntimeError(\"Boom\")\n    except RuntimeError:\n        print(\"Caught Runtime Error outside context\")\n\n    print(\"[PASS] Context manager protocol\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/dataclasses_basics_and_patterns.py", "title": "dataclasses basics and patterns", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/dataclasses_basics_and_patterns.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Dataclasses\nTopic: Advanced OOP\n\nTheory:\n    Introduced in Python 3.7.\n    Decorator `@dataclass` automatically generates:\n    - `__init__`\n    - `__repr__`\n    - `__eq__`\n    \n    Advanced features:\n    - `frozen=True` (Immutability)\n    - `order=True` (Comparison methods)\n    - `field(default_factory=...)` for mutable defaults.\n    - `__post_init__` for post-creation logic.\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import List\n\n@dataclass(order=True)\nclass InventoryItem:\n    name: str = field(compare=False)\n    unit_price: float\n    quantity_on_hand: int = 0\n    \n    # Computed list, mutable default must use factory\n    tags: List[str] = field(default_factory=list, repr=False)\n\n    def total_cost(self) -> float:\n        return self.unit_price * self.quantity_on_hand\n    \n    def __post_init__(self):\n        \"\"\"Called after __init__\"\"\"\n        if self.unit_price < 0:\n            raise ValueError(\"Price cannot be negative\")\n\ndef run_tests():\n    item1 = InventoryItem(\"Widget\", 10.0, 5)\n    item2 = InventoryItem(\"Gadget\", 20.0, 2)\n    \n    # 1. Ordering (by unit_price because it is first field with compare=True default? \n    # Actually fields are ordered by definition. name has compare=False, so price is first sort key.\n    # unit_price(10) < unit_price(20)\n    assert item1 < item2 \n    \n    # 2. Defaults\n    assert item1.tags == []\n    item1.tags.append(\"New\")\n    item3 = InventoryItem(\"Copy\", 10.0)\n    assert item3.tags == [] # Safety check\n    \n    # 3. Post Init\n    try:\n        InventoryItem(\"Test\", -5.0)\n    except ValueError:\n        print(\"Caught validation error\")\n        \n    print(f\"Repr: {item1}\") # Should not show tags\n    \n    print(\"[PASS] Dataclasses patterns\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/decorators_function_and_class.py", "title": "decorators function and class", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/decorators_function_and_class.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Decorators (Function and Class)\nTopic: Advanced OOP\n\nTheory:\n    Decorators wrap functions or classes to modify behavior.\n    Syntax: `@decorator`\n    \n    Types:\n    1. Function Decorators: `def wrapper(func):`\n    2. Class Decorators: `def wrapper(cls):`\n    \n    Preserving metadata (`functools.wraps`) is essential.\n\"\"\"\n\nfrom functools import wraps\n\n# ==========================================\n# 1. Function Decorator\n# ==========================================\n\ndef log_call(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}...\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@log_call\ndef adder(a, b):\n    \"\"\"Adds two numbers.\"\"\"\n    return a + b\n\n\n# ==========================================\n# 2. Class Decorator\n# ==========================================\n\ndef singleton(cls):\n    instances = {}\n    @wraps(cls)\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return get_instance\n\n@singleton\nclass Database:\n    def __init__(self):\n        print(\"Loading Database...\")\n\ndef run_tests():\n    # 1. Function\n    assert adder(2, 3) == 5\n    assert adder.__name__ == \"adder\" # preserved by wraps\n\n    # 2. Class singleton wrapper\n    d1 = Database()\n    d2 = Database()\n    assert d1 is d2\n    \n    print(\"[PASS] Decorators\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/dependency_injection_in_python_oop.py", "title": "dependency injection in python oop", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/dependency_injection_in_python_oop.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Dependency Injection (DI)\nTopic: Advanced OOP\n\nTheory:\n    DI is a technique where an object receives other objects that it depends on (dependencies).\n    Instead of creating dependencies inside the object (`self.svc = Service()`), pass them in (`__init__(self, svc)`).\n    \n    Benefits:\n    - Decoupling.\n    - Testability (Easy to mock dependencies).\n\"\"\"\n\nclass EmailService:\n    def send(self, msg):\n        return f\"Real Email: {msg}\"\n\nclass MockEmailService:\n    def send(self, msg):\n        return f\"Mock Email: {msg}\"\n\nclass NotificationManager:\n    # Dependency is Injected\n    def __init__(self, service):\n        self.service = service\n    \n    def alert(self, msg):\n        return self.service.send(msg)\n\ndef run_tests():\n    # Production\n    prod_svc = EmailService()\n    prod_mgr = NotificationManager(prod_svc)\n    assert prod_mgr.alert(\"Hi\") == \"Real Email: Hi\"\n    \n    # Testing\n    mock_svc = MockEmailService()\n    test_mgr = NotificationManager(mock_svc)\n    assert test_mgr.alert(\"Hi\") == \"Mock Email: Hi\"\n    \n    print(\"[PASS] Dependency Injection\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/descriptors_full_guide.py", "title": "descriptors full guide", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/descriptors_full_guide.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Descriptors (Full Guide)\nTopic: Advanced OOP\n\nTheory:\n    Descriptors are objects that define `__get__`, `__set__`, or `__delete__`.\n    They are the mechanism behind properties, methods, static methods, and class methods.\n\n    - Data Descriptor: Defines `__set__` or `__delete__`.\n    - Non-Data Descriptor: Defines only `__get__` (e.g., methods).\n\n    Crucial: Descriptors are assigned to Class attributes, not instance attributes during init.\n\"\"\"\n\nimport weakref\n\nclass Typed:\n    \"\"\"A descriptor that enforces type checking.\"\"\"\n    def __init__(self, name, expected_type):\n        self.name = name\n        self.expected_type = expected_type\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        return instance.__dict__.get(self.name)\n\n    def __set__(self, instance, value):\n        if not isinstance(value, self.expected_type):\n            raise TypeError(f\"Expected {self.expected_type}\")\n        instance.__dict__[self.name] = value\n\n    def __delete__(self, instance):\n        del instance.__dict__[self.name]\n\nclass Person:\n    # Descriptors must be class attributes\n    name = Typed(\"name\", str)\n    age = Typed(\"age\", int)\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\ndef run_tests():\n    p = Person(\"Bob\", 30)\n    assert p.name == \"Bob\"\n    assert p.age == 30\n    \n    try:\n        p.age = \"Old\"\n    except TypeError as e:\n        print(f\"Caught expected type error: {e}\")\n\n    try:\n        p.name = 123\n    except TypeError:\n        print(\"Caught name error\")\n        \n    print(\"[PASS] Descriptor full guide\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/magic_dunder_methods_containers.py", "title": "magic dunder methods containers", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/magic_dunder_methods_containers.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Container Magic Methods\nTopic: Advanced OOP\n\nTheory:\n    Make your object act like a list, dict, or set.\n    \n    KEY METHODS:\n    - `__len__`: for `len(obj)`\n    - `__getitem__`: for `obj[key]`\n    - `__setitem__`: for `obj[key] = value`\n    - `__delitem__`: for `del obj[key]`\n    - `__iter__`: for `for x in obj`\n    - `__contains__`: for `item in obj`\n\n    Complexity:\n    - Implementing these allows usage with `random.choice`, slicing, unpacking, etc.\n\"\"\"\n\nclass CustomList:\n    \"\"\"A wrapper around list that logs operations.\"\"\"\n    def __init__(self, *args):\n        self._items = list(args)\n\n    def __len__(self):\n        return len(self._items)\n\n    def __getitem__(self, index):\n        print(f\"Accessing index {index}\")\n        return self._items[index]\n\n    def __setitem__(self, index, value):\n        print(f\"Setting index {index} to {value}\")\n        self._items[index] = value\n\n    def __delitem__(self, index):\n        print(f\"Deleting index {index}\")\n        del self._items[index]\n\n    def __iter__(self):\n        return iter(self._items)\n\n    def __contains__(self, item):\n        return item in self._items\n\ndef run_tests():\n    c = CustomList(1, 2, 3, 4)\n    \n    # Test len\n    assert len(c) == 4\n    \n    # Test getitem\n    assert c[0] == 1\n    \n    # Test setitem\n    c[0] = 100\n    assert c[0] == 100\n    \n    # Test contains\n    assert 100 in c\n    assert 99 not in c\n    \n    # Test iter\n    assert list(c) == [100, 2, 3, 4]\n    \n    print(\"[PASS] Container Magic methods verified\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/magic_dunder_methods_core.py", "title": "magic dunder methods core", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/magic_dunder_methods_core.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Core Magic Methods (Dunders)\nTopic: Advanced OOP\n\nTheory:\n    \"Dunder\" stands for Double Underscore. These methods define how objects behave with operators and built-ins.\n    \n    KEY METHODS:\n    - Initialization: `__init__`, `__new__`, `__del__`\n    - Representation: `__str__` (user), `__repr__` (debugging)\n    - Comparison: `__eq__`, `__lt__`, `__le__`, etc.\n    - Hashing: `__hash__` (required for sets/dict keys)\n    - Boolean: `__bool__`\n\nPitfalls:\n    - Implementing `__eq__` without `__hash__` makes objects unhashable.\n    - `__del__` is tricky; don't rely on it for critical cleanup (use Context Managers).\n\"\"\"\n\nclass Person:\n    def __init__(self, name, id_num):\n        self.name = name\n        self.id_num = id_num\n\n    # 1. Representation\n    def __repr__(self):\n        return f\"Person(name='{self.name}', id_num={self.id_num})\"\n\n    def __str__(self):\n        return f\"{self.name} (#{self.id_num})\"\n\n    # 2. Equality\n    def __eq__(self, other):\n        if not isinstance(other, Person):\n            return NotImplemented\n        return self.id_num == other.id_num\n\n    # 3. Hashing (Must be immutable based on Eq)\n    def __hash__(self):\n        return hash(self.id_num)\n\n    # 4. Ordering (Privacy of sorting)\n    def __lt__(self, other):\n        return self.id_num < other.id_num\n    \n    # 5. Truthiness\n    def __bool__(self):\n        return self.id_num > 0 # False if ID is 0\n\ndef run_tests():\n    p1 = Person(\"Alice\", 1)\n    p2 = Person(\"Alice\", 1)\n    p3 = Person(\"Bob\", 2)\n\n    # __eq__\n    assert p1 == p2\n    assert p1 != p3\n\n    # __lt__\n    assert p1 < p3\n\n    # __hash__ (allows set usage)\n    s = {p1, p2, p3}\n    assert len(s) == 2 # p1 and p2 de-duplicated\n\n    # __str__ and __repr__\n    print(f\"Str: {str(p1)}\")   # Alice (#1)\n    print(f\"Repr: {repr(p1)}\") # Person(name='Alice', id_num=1)\n\n    print(\"[PASS] Core Magic/Dunder methods verified\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/metaclasses_introduction.py", "title": "metaclasses introduction", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/metaclasses_introduction.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Metaclasses Introduction\nTopic: Advanced OOP\n\nTheory:\n    In Python, Classes are objects too.\n    - An Object is an instance of a Class.\n    - A Class is an instance of a Metaclass.\n    \n    Default Metaclass: `type`.\n    \n    When you define `class Foo:` Python effectively does:\n    `Foo = type('Foo', (bases,), dict(attributes))`\n    \n    To define a custom metaclass, inherit from `type` and use `metaclass=Meta` in class def.\n\"\"\"\n\ndef simple_metaclass_demo():\n    print(\"--- Dynamic Class Creation with 'type' ---\")\n    \n    # Creating a class dynamically\n    # class DynamicUser:\n    #     role = \"User\"\n    #     def __init__(self, name): self.name = name\n    \n    def init(self, name):\n        self.name = name\n\n    DynamicUser = type(\n        'DynamicUser',          # Name\n        (),                     # Bases\n        {'role': 'User', '__init__': init}  # Dict\n    )\n    \n    u = DynamicUser(\"Alice\")\n    assert u.name == \"Alice\"\n    assert u.role == \"User\"\n    assert type(DynamicUser) is type\n\n\nclass MetaVerbose(type):\n    \"\"\"A metaclass that logs class creation.\"\"\"\n    \n    def __new__(mcs, name, bases, dct):\n        print(f\"Allocating memory for class: {name}\")\n        return super().__new__(mcs, name, bases, dct)\n\n    def __init__(cls, name, bases, dct):\n        print(f\"Initializing class: {name}\")\n        super().__init__(name, bases, dct)\n\nclass SpiedClass(metaclass=MetaVerbose):\n    pass\n\ndef run_tests():\n    simple_metaclass_demo()\n    \n    print(\"Checking SpiedClass...\")\n    # The print statements happened at DEFINITION time (above), not instantiation time.\n    s = SpiedClass()\n    assert isinstance(s, SpiedClass)\n    \n    print(\"[PASS] Metaclass intro\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/metaclasses_practical_patterns.py", "title": "metaclasses practical patterns", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/metaclasses_practical_patterns.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Metaclasses Practical Patterns\nTopic: Advanced OOP\n\nPatterns:\n    1. Validation: Check if class defines required methods or follows conventions.\n    2. Registration: Automatically register plugins/subclasses.\n    3. Auto-Decoration: Apply decorators to all methods in a class.\n\"\"\"\n\n# ==========================================\n# 1. Plugin Registry Pattern\n# ==========================================\n\nclass PluginMeta(type):\n    registry = {}\n    \n    def __init__(cls, name, bases, dct):\n        if name != \"PluginBase\":\n            print(f\"Registering plugin: {name}\")\n            PluginMeta.registry[name] = cls\n        super().__init__(name, bases, dct)\n\nclass PluginBase(metaclass=PluginMeta):\n    pass\n\nclass AudioPlugin(PluginBase):\n    pass\n\nclass VideoPlugin(PluginBase):\n    pass\n\n\n# ==========================================\n# 2. Enforcement Pattern\n# ==========================================\n\nclass EnforcerMeta(type):\n    def __new__(mcs, name, bases, dct):\n        if name != \"EnforcedBase\":\n            if 'required_method' not in dct:\n                raise TypeError(f\"Class {name} missing 'required_method'\")\n        return super().__new__(mcs, name, bases, dct)\n\nclass EnforcedBase(metaclass=EnforcerMeta):\n    pass\n\ndef run_tests():\n    # 1. Registry\n    keys = PluginMeta.registry.keys()\n    assert \"AudioPlugin\" in keys\n    assert \"VideoPlugin\" in keys\n    assert \"PluginBase\" not in keys\n    \n    # 2. Enforcement\n    try:\n        class BrokenPlugin(EnforcedBase):\n            pass\n    except TypeError as e:\n        print(f\"Caught expected metaclass error: {e}\")\n\n    class GoodPlugin(EnforcedBase):\n        def required_method(self): pass\n    \n    print(\"[PASS] Metaclass patterns\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/mixins_design.py", "title": "mixins design", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/mixins_design.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Mixins Design Pattern\nTopic: Advanced OOP\n\nTheory:\n    A Mixin is a class that provides methods to other classes but is not considered a \"base class\" in the hierarchy sense.\n    It doesn't define state (ideally).\n    \n    Usage:\n    `class MyClass(Mixin1, Mixin2, Base):`\n    \n    Mixins usually appear *before* the base class in inheritance list so their methods override/augment the base.\n\"\"\"\n\nimport json\n\nclass JsonSerializableMixin:\n    def to_json(self):\n        return json.dumps(self.__dict__)\n\n    @classmethod\n    def from_json(cls, json_str):\n        data = json.loads(json_str)\n        # Assuming simple kwargs init\n        return cls(**data)\n\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass SerializableUser(JsonSerializableMixin, User):\n    pass\n\ndef run_tests():\n    u = SerializableUser(name=\"Alice\", email=\"alice@example.com\")\n    \n    # 1. Serialization\n    j = u.to_json()\n    print(f\"JSON: {j}\")\n    assert '\"name\": \"Alice\"' in j\n    \n    # 2. Deserialization\n    u2 = SerializableUser.from_json(j)\n    assert u2.name == u.name\n    assert u2.email == u.email\n    assert isinstance(u2, SerializableUser)\n    \n    print(\"[PASS] Mixin usage verified\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/resource_management_and_raii_pythonic.py", "title": "resource management and raii pythonic", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/resource_management_and_raii_pythonic.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Resource Management and RAII\nTopic: Advanced OOP\n\nTheory:\n    RAII (Resource Acquisition Is Initialization) is a C++ concept.\n    In Python, because of GC (non-deterministic destruction), we use Context Managers (`with`) for RAII-like behavior.\n    \n    However, `__del__` exists as a finalizer but is unreliable (circular refs, interpreter shutdown).\n    \n    Best Practice: ALWAYS use `with` statements (Context Managers) or `try...finally` for resources.\n\"\"\"\n\nclass Resource:\n    def __init__(self, name):\n        self.name = name\n        print(f\"Acquired {self.name}\")\n\n    def close(self):\n        print(f\"Released {self.name}\")\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\ndef run_tests():\n    print(\"--- Scope Start ---\")\n    with Resource(\"Database\") as r:\n        print(\"Using Resource\")\n    print(\"--- Scope End ---\")\n    # Output should show Released before Scope End\n    \n    print(\"[PASS] Resource Management verified\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Advanced_Features/slots_and_memory_optimization.py", "title": "slots and memory optimization", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Advanced_Features/slots_and_memory_optimization.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Advanced Features"], "content": "\"\"\"\nTitle: Slots and Memory Optimization\nTopic: Advanced OOP\n\nTheory:\n    By default, Python objects use a `__dict__` to store attributes.\n    This is flexible but memory-heavy for millions of objects.\n    \n    `__slots__`:\n    - Tells Python to use a static structure (array-like) instead of dict.\n    - Prevents creation of new attributes not in slots.\n    - Reduces memory footprint significantly.\n\"\"\"\n\nimport sys\n\nclass RegularPoint:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass SlottedPoint:\n    __slots__ = ['x', 'y']\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef run_tests():\n    p_reg = RegularPoint(1, 2)\n    p_slot = SlottedPoint(1, 2)\n\n    # 1. Attribute Access\n    assert p_reg.x == 1\n    assert p_slot.x == 1\n\n    # 2. Constraint\n    p_reg.z = 3 # Allowed\n    try:\n        p_slot.z = 3 # Not allowed\n    except AttributeError:\n        print(\"Caught expected error: Cannot add new attribute to slotted class\")\n\n    # 3. Memory diff (Approximation)\n    # Note: sys.getsizeof doesn't recursively measure __dict__ fully without help, \n    # but the object struct itself shows difference.\n    \n    size_reg = sys.getsizeof(p_reg) + sys.getsizeof(p_reg.__dict__)\n    size_slot = sys.getsizeof(p_slot)\n    \n    print(f\"Regular Size (approx): {size_reg} bytes\")\n    print(f\"Slotted Size: {size_slot} bytes\")\n    \n    assert size_slot < size_reg\n    \n    print(\"[PASS] Slots optimization\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Basics/classes_objects.py", "title": "classes objects", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Basics/classes_objects.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Basics"], "content": "\"\"\"\nTitle: Classes and Objects in Python\nTopic: OOP Basics\n\nTheory:\n    A Class is a blueprint for creating objects (a particular data structure), providing initial values \n    for state (member variables or attributes), and implementations of behavior (member functions or methods).\n    An Object is an instance of a Class.\n\n    Python is completely object-oriented: everything is an object (integers, strings, functions, classes themselves).\n\n    Key Concepts:\n    - `class` keyword: Defines a new class.\n    - Attributes: Data stored inside an object.\n    - Methods: Functions defined inside a class that operate on its objects.\n    - `self`: Reference to the current instance of the class (explicitly passed as first argument).\n\nComplexity:\n    - Object creation: O(1) typically.\n    - Attribute access: O(1) (average case via dictionary lookup).\n\nPitfalls:\n    - Forgetting `self` in method definitions (leads to \"takes 0 positional arguments but 1 was given\").\n    - Modifying class attributes expecting them to be instance attributes.\n\"\"\"\n\n# ==========================================\n# 1. Basic Class Definition\n# ==========================================\n\nclass Dog:\n    \"\"\"A simple class representing a Dog.\"\"\"\n\n    # Class Attribute (Shared by all instances)\n    species = \"Canis familiaris\"\n\n    def __init__(self, name: str, age: int):\n        \"\"\"\n        The Initializer (Constructor). \n        Called when a new instance is created.\n        \"\"\"\n        # Instance Attributes (Unique to each instance)\n        self.name = name\n        self.age = age\n\n    def description(self):\n        \"\"\"Instance method: operates on 'self'.\"\"\"\n        return f\"{self.name} is {self.age} years old.\"\n\n    def speak(self, sound: str):\n        return f\"{self.name} says {sound}\"\n\n\n# ==========================================\n# 2. Creating and Using Objects\n# ==========================================\n\ndef demonstration():\n    print(\"--- Creating Objects ---\")\n    dog1 = Dog(\"Buddy\", 9)\n    dog2 = Dog(\"Miles\", 4)\n\n    print(f\"Dog 1: {dog1.description()}\")\n    print(f\"Dog 2: {dog2.description()}\")\n\n    # Accessing Class Attributes\n    print(f\"Both are: {Dog.species}\")\n    print(f\"Dog 1 species: {dog1.species}\")\n\n\n# ==========================================\n# 3. Pitfalls & Variations\n# ==========================================\n\nclass EmptyClass:\n    \"\"\"Python requires 'pass' for empty blocks.\"\"\"\n    pass\n\ndef pitfalls_example():\n    \"\"\"\n    Common Pitfall: Mutable Class Attributes\n    \"\"\"\n    class DangerousDog:\n        tricks = [] # Mistake: List is shared by all dogs!\n        \n        def __init__(self, name):\n            self.name = name\n        \n        def add_trick(self, trick):\n            self.tricks.append(trick)\n\n    d1 = DangerousDog(\"Fido\")\n    d2 = DangerousDog(\"Buddy\")\n    \n    d1.add_trick(\"roll over\")\n    # d2 will also have \"roll over\" now!\n    assert \"roll over\" in d2.tricks\n    print(f\"\\n[Pitfall Demo] d2 has tricks: {d2.tricks} (Shared State Issue)\")\n\n\n# ==========================================\n# Tests\n# ==========================================\n\nif __name__ == \"__main__\":\n    print(\"Running demonstration...\")\n    demonstration()\n    pitfalls_example()\n\n    # Simple Asserts\n    my_dog = Dog(\"Rex\", 5)\n    assert my_dog.name == \"Rex\"\n    assert my_dog.age == 5\n    assert my_dog.speak(\"Woof\") == \"Rex says Woof\"\n    assert isinstance(my_dog, Dog)\n    \n    print(\"\\n[PASS] All basic class tests passed.\")\n"}, {"id": "python/PythonMasteryRepo/OOPs/Basics/constructors_init.py", "title": "constructors init", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Basics/constructors_init.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Basics"], "content": "\"\"\"\nTitle: Constructors and __init__\nTopic: OOP Basics\n\nTheory:\n    In Python, `__init__` is the initializer method, not the constructor.\n    The actual constructor is `__new__` (rarely used, mostly for metaclasses or immutable types).\n    \n    `__init__` is called immediately after the object is created to initialize its state.\n\n    Key Concepts:\n    - Default arguments: Allow flexibility in object creation.\n    - Type hints: Highly recommended for `__init__` arguments.\n    - `__new__` vs `__init__`: `__new__` creates the instance, `__init__` initializes it.\n\nPitfalls:\n    - Returning a value from `__init__`: It must return `None`.\n    - Using mutable default arguments in `__init__` (e.g., `def __init__(self, items=[])`).\n\"\"\"\n\nfrom typing import Optional, List\n\n# ==========================================\n# 1. Standard Init with Validation\n# ==========================================\n\nclass Person:\n    def __init__(self, name: str, age: int):\n        # Validation in init\n        if age < 0:\n            raise ValueError(\"Age cannot be negative\")\n        \n        self.name = name\n        self.age = age\n\n    def __repr__(self):\n        return f\"Person(name='{self.name}', age={self.age})\"\n\n\n# ==========================================\n# 2. Init with Default Arguments (Correct Way)\n# ==========================================\n\nclass ShoppingCart:\n    def __init__(self, items: Optional[List[str]] = None):\n        \"\"\"\n        CORRECT: Use None as default for mutable types, then create new list.\n        \"\"\"\n        if items is None:\n            self.items = []\n        else:\n            self.items = items\n\n    def add(self, item: str):\n        self.items.append(item)\n\n\n# ==========================================\n# 3. The `__new__` Method (Advanced)\n# ==========================================\n\nclass Singleton:\n    \"\"\"A Class that allows only one instance (Singleton Pattern via __new__).\"\"\"\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            print(\"Creating the object...\")\n            cls._instance = super(Singleton, cls).__new__(cls)\n        return cls._instance\n\n    def __init__(self, value):\n        self.value = value\n\n\n# ==========================================\n# 4. Pitfalls\n# ==========================================\n\nclass BadInit:\n    def __init__(self, data=[]): # BAD!\n        self.data = data\n\ndef demonstrate_pitfall():\n    print(\"\\n--- Init Pitfall ---\")\n    b1 = BadInit()\n    b1.data.append(\"A\")\n    \n    b2 = BadInit()\n    print(f\"b2 data (should be empty): {b2.data}\") \n    # b2.data is ['A'] because the default list is created once at definition!\n    assert \"A\" in b2.data\n\n\n# ==========================================\n# Tests\n# ==========================================\n\nif __name__ == \"__main__\":\n    # 1. Validation Test\n    try:\n        p = Person(\"John\", -1)\n    except ValueError as e:\n        print(f\"[PASS] Caught expected error: {e}\")\n\n    # 2. Correct Defaults\n    c1 = ShoppingCart()\n    c1.add(\"Apple\")\n    c2 = ShoppingCart()\n    assert \"Apple\" not in c2.items\n    print(\"[PASS] Mutable default argument handled correctly\")\n\n    # 3. Singleton\n    s1 = Singleton(10)\n    s2 = Singleton(20)\n    assert s1 is s2\n    print(f\"[PASS] Singleton identity check: s1 is s2\")\n\n    # 4. Pitfall\n    demonstrate_pitfall()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Basics/docstrings_and_annotations.py", "title": "docstrings and annotations", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Basics/docstrings_and_annotations.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Basics"], "content": "\"\"\"\nTitle: Docstrings and Type Annotations\nTopic: OOP Basics\n\nTheory:\n    - Docstrings: Strings used to document modules, classes, functions, and methods.\n      Accessible via `__doc__` attribute.\n      Common styles: Google, NumPy, Sphinx/reST.\n    \n    - Type Annotations (Hints): Added in Python 3.5+.\n      Used by static type checkers (mypy) and IDEs.\n      Stored in `__annotations__`.\n\n    Best Practices:\n    - Always document public APIs.\n    - Use type hints for function arguments and return types.\n\"\"\"\n\nfrom typing import List, Dict, Union, Optional\n\n# ==========================================\n# 1. Annotated Class with Docstrings\n# ==========================================\n\nclass Student:\n    \"\"\"\n    Represents a student in the system.\n\n    Attributes:\n        name (str): The student's full name.\n        grades (List[int]): A list of scores typicaly 0-100.\n    \"\"\"\n\n    def __init__(self, name: str, grades: Optional[List[int]] = None) -> None:\n        \"\"\"\n        Initializes the student.\n\n        Args:\n            name: The name of the student.\n            grades: Optional list of initial grades.\n        \"\"\"\n        self.name: str = name\n        self.grades: List[int] = grades if grades else []\n\n    def add_grade(self, score: int) -> None:\n        \"\"\"\n        Adds a single grade.\n\n        Args:\n            score (int): The score to add.\n            \n        Raises:\n            ValueError: If score is out of range.\n        \"\"\"\n        if not (0 <= score <= 100):\n            raise ValueError(\"Score must be between 0 and 100\")\n        self.grades.append(score)\n\n    def get_average(self) -> float:\n        \"\"\"\n        Calculates the average grade.\n\n        Returns:\n            float: The average, or 0.0 if no grades.\n        \"\"\"\n        if not self.grades:\n            return 0.0\n        return sum(self.grades) / len(self.grades)\n\n\n# ==========================================\n# 2. Accessing Metadata\n# ==========================================\n\ndef inspection_demo():\n    print(\"--- Inspecting Docstrings and Annotations ---\")\n    \n    # 1. Docstring\n    print(f\"Class Doc: {Student.__doc__.strip().splitlines()[0]}\")\n    print(f\"Method Doc: {Student.add_grade.__doc__.strip().splitlines()[0]}\")\n\n    # 2. Annotations\n    print(f\"Init Annotations: {Student.__init__.__annotations__}\")\n    print(f\"Method Annotations: {Student.get_average.__annotations__}\")\n\n\n# ==========================================\n# Tests\n# ==========================================\n\nif __name__ == \"__main__\":\n    inspection_demo()\n    \n    s = Student(\"Jane\", [90, 80])\n    s.add_grade(100)\n    assert s.get_average() == 90.0\n    \n    print(\"[PASS] Docstrings and Annotations demo passed.\")\n"}, {"id": "python/PythonMasteryRepo/OOPs/Basics/instance_vs_class_vars.py", "title": "instance vs class vars", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Basics/instance_vs_class_vars.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Basics"], "content": "\"\"\"\nTitle: Instance vs Class Variables\nTopic: OOP Basics\n\nTheory:\n    - Class Variables: Shared by all instances of a class. Defined directly in the class body.\n      Any change affects all instances *unless shadowed*.\n    - Instance Variables: Unique to each instance. Defined inside methods (usually `__init__`) using `self`.\n\n    Scope Resolution:\n    When accessing `obj.attr`, Python looks up:\n    1. Instance namespace (`obj.__dict__`)\n    2. Class namespace (`type(obj).__dict__`)\n    3. Base classes.\n\nPitfalls:\n    - Shadowing: Assigning to `self.class_var` creates a new instance variable, masking the class variable for that instance,\n      but not changing the class variable itself.\n\"\"\"\n\n# ==========================================\n# 1. Basic Comparison\n# ==========================================\n\nclass Employee:\n    # Class Variable\n    company_name = \"TechCorp\"\n    employee_count = 0  # To track total employees\n\n    def __init__(self, name: str):\n        # Instance Variable\n        self.name = name\n        \n        # Modifying class variable needs class reference\n        Employee.employee_count += 1\n\n    def change_company(self, new_name):\n        # This shadows the class variable for THIS instance only!\n        self.company_name = new_name \n\n\n# ==========================================\n# 2. Demonstration of Shadowing\n# ==========================================\n\ndef demonstration():\n    print(\"--- Class vs Instance Vars ---\")\n    e1 = Employee(\"Alice\")\n    e2 = Employee(\"Bob\")\n\n    print(f\"Start: e1 company: {e1.company_name}, e2 company: {e2.company_name}\")\n    assert e1.company_name == \"TechCorp\"\n\n    # Modifying Class Variable properly\n    Employee.company_name = \"GlobalTech\"\n    print(f\"After Class Change: e1: {e1.company_name}, e2: {e2.company_name}\")\n    assert e1.company_name == \"GlobalTech\"\n    assert e2.company_name == \"GlobalTech\"\n\n    # Accidental Shadowing\n    print(\"\\n--- Shadowing Pitfall ---\")\n    e1.company_name = \"StartupInc\" # Creates e1.company_name, leaves Employee.company_name alone\n    \n    print(f\"e1: {e1.company_name}\")         # StartupInc\n    print(f\"e2: {e2.company_name}\")         # GlobalTech\n    print(f\"Class: {Employee.company_name}\") # GlobalTech\n\n    # accessing via __dict__\n    print(f\"e1 dict: {e1.__dict__}\")\n    print(f\"e2 dict: {e2.__dict__}\")\n\n\n# ==========================================\n# 3. Practical Usage: Counters and Configs\n# ==========================================\n\nclass ServerConfig:\n    DEFAULT_PORT = 8080 # Class var as constant reference\n    \n    def __init__(self, port=None):\n        self.port = port or self.DEFAULT_PORT\n\n# ==========================================\n# Tests\n# ==========================================\n\nif __name__ == \"__main__\":\n    demonstration()\n    \n    c = ServerConfig()\n    assert c.port == 8080\n    \n    c2 = ServerConfig(9000)\n    assert c2.port == 9000\n    \n    print(\"\\n[PASS] Instance vs Class variable demo finished.\")\n"}, {"id": "python/PythonMasteryRepo/OOPs/Basics/properties_getters_setters.py", "title": "properties getters setters", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Basics/properties_getters_setters.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Basics"], "content": "\"\"\"\nTitle: Properties, Getters, and Setters\nTopic: OOP Basics\n\nTheory:\n    In Python, we prefer direct attribute access (public by default). \n    However, if we need validation or computed attributes, we use the `@property` decorator.\n    This creates \"managed attributes\".\n\n    - @property: Defines the getter.\n    - @name.setter: Defines the setter.\n    - @name.deleter: Defines behavior on `del obj.name`.\n\n    Benefit: You can start with simple attributes (`self.x`) and change to properties later \n    without breaking client code (API stability).\n\nPitfalls:\n    - Infinite recursion: Accessing `self.x` inside the setter for `x`.\n      (Must use a private backing variable like `self._x`).\n\"\"\"\n\n# ==========================================\n# 1. The Pythonic Way\n# ==========================================\n\nclass Circle:\n    def __init__(self, radius: float):\n        self._radius = radius # \"Protected\" variable by convention\n\n    @property\n    def radius(self):\n        \"\"\"The radius property (Getter).\"\"\"\n        return self._radius\n\n    @radius.setter\n    def radius(self, value: float):\n        \"\"\"The radius setter with validation.\"\"\"\n        if value < 0:\n            raise ValueError(\"Radius cannot be negative\")\n        self._radius = value\n\n    @property\n    def area(self):\n        \"\"\"Computed property (Read-only).\"\"\"\n        return 3.14159 * (self._radius ** 2)\n\n\n# ==========================================\n# 2. Pitfall: Infinite Recursion\n# ==========================================\n\nclass Broken:\n    @property\n    def x(self):\n        return self.x # RECURSION ERROR! Should be self._x\n\n    @x.setter\n    def x(self, val):\n        self.x = val # RECURSION ERROR!\n\n\n# ==========================================\n# Tests\n# ==========================================\n\ndef run_tests():\n    print(\"--- Property Tests ---\")\n    c = Circle(5)\n    print(f\"Initial Radius: {c.radius}, Area: {c.area}\")\n    \n    # 1. Test Setter\n    c.radius = 10\n    assert c._radius == 10\n    print(f\"New Radius: {c.radius}\")\n\n    # 2. Test Validation\n    try:\n        c.radius = -5\n    except ValueError as e:\n        print(f\"Caught expected error: {e}\")\n    \n    # 3. Test Read-only\n    try:\n        c.area = 50 # AttributeError, no setter defined\n    except AttributeError:\n        print(\"Caught expected AttributeError for read-only property\")\n\nif __name__ == \"__main__\":\n    run_tests()\n    print(\"[PASS] Property tests passed.\")\n"}, {"id": "python/PythonMasteryRepo/OOPs/Basics/static_and_class_methods.py", "title": "static and class methods", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Basics/static_and_class_methods.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Basics"], "content": "\"\"\"\nTitle: Static Methods vs Class Methods\nTopic: OOP Basics\n\nTheory:\n    - Instance Methods: Receive `self` (the instance). Can access instance and class state.\n    - Class Methods (`@classmethod`): Receive `cls` (the class). Can access class state, but not instance state.\n      Often used for \"Factory Methods\" (alternative constructors).\n    - Static Methods (`@staticmethod`): Receive neither `self` nor `cls`.\n      Behave like regular functions but belong to the class namespace for logical grouping.\n\n    When to use:\n    - @classmethod: When you need access to class variables or want to return an instance of `cls`.\n    - @staticmethod: When the method doesn't touch the object or class internals (utility functions).\n\nPitfalls:\n    - Using a static method when a class method was needed (e.g., hardcoding class name in static method vs using `cls`).\n\"\"\"\n\nimport datetime\n\n# ==========================================\n# 1. Implementation\n# ==========================================\n\nclass DateHelper:\n    # Class variable\n    date_format = \"%Y-%m-%d\"\n\n    def __init__(self, year, month, day):\n        self.year = year\n        self.month = month\n        self.day = day\n\n    def display(self):\n        \"\"\"Instance method\"\"\"\n        return f\"{self.year}/{self.month}/{self.day}\"\n\n    @classmethod\n    def from_string(cls, date_str: str):\n        \"\"\"\n        Class Method used as a Factory.\n        It uses 'cls' to instantiate the object, supporting inheritance.\n        \"\"\"\n        y, m, d = map(int, date_str.split(\"-\"))\n        # Returns an instance of 'cls' (DateHelper or subclass)\n        return cls(y, m, d)\n\n    @classmethod\n    def set_format(cls, new_format):\n        \"\"\"Modifies class state.\"\"\"\n        cls.date_format = new_format\n\n    @staticmethod\n    def is_valid_date(year, month, day):\n        \"\"\"\n        Static Method. \n        Does not need self or cls. Just logic related to dates.\n        \"\"\"\n        if month < 1 or month > 12:\n            return False\n        if day < 1 or day > 31:\n            return False\n        return True\n\n# ==========================================\n# 2. Inheritance Behavior\n# ==========================================\n\nclass DetailedDate(DateHelper):\n    def display(self):\n        return f\"Detailed: {super().display()}\"\n\ndef run_demo():\n    print(\"--- Static vs Class Methods ---\")\n    \n    # 1. Using Factory (Class Method)\n    d1 = DateHelper.from_string(\"2023-10-25\")\n    print(f\"Factory created: {d1.display()}\")\n    assert d1.year == 2023\n\n    # 2. Inheritance check\n    # calling from_string on subclass should return instance of SUBCLASS\n    d2 = DetailedDate.from_string(\"2024-01-01\")\n    print(f\"Subclass factory: {d2.display()}\") \n    assert isinstance(d2, DetailedDate) # Crucial check!\n\n    # 3. Static Method usage\n    valid = DateHelper.is_valid_date(2023, 13, 1) # False\n    print(f\"Is 2023-13-1 valid? {valid}\")\n    assert valid is False\n\n\n# ==========================================\n# Tests\n# ==========================================\n\nif __name__ == \"__main__\":\n    run_demo()\n    print(\"[PASS] Static/Class method tests passed.\")\n"}, {"id": "python/PythonMasteryRepo/OOPs/Concurrency/async_await_oop_patterns.py", "title": "async await oop patterns", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Concurrency/async_await_oop_patterns.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Concurrency"], "content": "\"\"\"\nTitle: Async/Await OOP Patterns\nTopic: Concurrency\n\nTheory:\n    `asyncio` allows writing single-threaded concurrent code using coroutines.\n    Classes can have `async` methods.\n    \n    `__aiter__` and `__anext__`: Async Iterators.\n    `__aenter__` and `__aexit__`: Async Context Managers.\n\n    Pitfall: Blocking the event loop (e.g., using `time.sleep` instead of `asyncio.sleep`).\n\"\"\"\n\nimport asyncio\n\nclass AsyncFetcher:\n    def __init__(self, base_url):\n        self.base_url = base_url\n\n    async def fetch(self, endpoint):\n        \"\"\"Simulate Network Request\"\"\"\n        print(f\"Fetching {endpoint}...\")\n        await asyncio.sleep(0.1) # Non-blocking sleep\n        return f\"Data from {endpoint}\"\n\n    async def fetch_all(self, endpoints):\n        # Gather multiple tasks concurrently\n        tasks = [self.fetch(ep) for ep in endpoints]\n        return await asyncio.gather(*tasks)\n\nclass AsyncResource:\n    async def __aenter__(self):\n        print(\"Async acquiring...\")\n        await asyncio.sleep(0.01)\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb):\n        print(\"Async releasing...\")\n        await asyncio.sleep(0.01)\n\ndef run_tests():\n    async def main():\n        # 1. Async Methods\n        f = AsyncFetcher(\"http://api.com\")\n        results = await f.fetch_all([\"/users\", \"/posts\", \"/comments\"])\n        assert len(results) == 3\n        print(\"Fetch results:\", results)\n\n        # 2. Async Context Manager\n        async with AsyncResource() as res:\n            print(\"Inside async context\")\n\n    # Run the event loop\n    asyncio.run(main()) \n    print(\"[PASS] Async OOP Patterns\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Concurrency/concurrent_futures_thread_pool_process_pool.py", "title": "concurrent futures thread pool process pool", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Concurrency/concurrent_futures_thread_pool_process_pool.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Concurrency"], "content": "\"\"\"\nTitle: Concurrent Futures (ThreadPool & ProcessPool)\nTopic: Concurrency\n\nTheory:\n    High-level API for async execution (`concurrent.futures`).\n    - `ThreadPoolExecutor`: For threads.\n    - `ProcessPoolExecutor`: For processes.\n    \n    Pattern:\n    `future = executor.submit(func, args)`\n    `result = future.result()`\n\"\"\"\n\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\n\ndef square(n):\n    return n * n\n\ndef run_tests():\n    # 1. Thread Pool\n    print(\"--- Thread Pool ---\")\n    with ThreadPoolExecutor(max_workers=3) as executor:\n        results = list(executor.map(square, [1, 2, 3]))\n        assert results == [1, 4, 9]\n\n    # 2. Process Pool\n    print(\"--- Process Pool ---\")\n    with ProcessPoolExecutor(max_workers=3) as executor:\n        futures = {executor.submit(square, n): n for n in [4, 5, 6]}\n        \n        for future in as_completed(futures):\n            res = future.result()\n            print(f\"Result: {res}\")\n            assert res in [16, 25, 36]\n    \n    print(\"[PASS] Concurrent Futures\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Concurrency/multiprocessing_basics.py", "title": "multiprocessing basics", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Concurrency/multiprocessing_basics.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Concurrency"], "content": "\"\"\"\nTitle: Multiprocessing Basics\nTopic: Concurrency\n\nTheory:\n    Processes have separate memory spaces. Ideal for CPU bound tasks.\n    They bypass the GIL.\n    \n    Communication:\n    Use `Queue` or `Pipe` to share data between processes (Pickle-based).\n\"\"\"\n\nimport multiprocessing\nimport time\n\ndef cpu_bound_task(n):\n    return sum(i * i for i in range(n))\n\nclass WorkerProcess(multiprocessing.Process):\n    def __init__(self, n, queue):\n        super().__init__()\n        self.n = n\n        self.queue = queue\n\n    def run(self):\n        \"\"\"Method called when p.start() runs.\"\"\"\n        res = cpu_bound_task(self.n)\n        self.queue.put(res)\n\ndef run_tests():\n    # Only run multiprocessing in main block on Windows!\n    queue = multiprocessing.Queue()\n    \n    p = WorkerProcess(1000, queue)\n    p.start()\n    p.join()\n    \n    result = queue.get()\n    assert result > 0\n    print(f\"Result from process: {result}\")\n    \n    print(\"[PASS] Multiprocessing\")\n\nif __name__ == \"__main__\":\n    # Essential for Windows\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Concurrency/producer_consumer_oop_design.py", "title": "producer consumer oop design", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Concurrency/producer_consumer_oop_design.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Concurrency"], "content": "\"\"\"\nTitle: Producer-Consumer OOP Design\nTopic: Concurrency\n\nTheory:\n    Classic pattern to decouple data production from processing.\n    Key Component: A thread-safe queue.\n    \n    Producer -> Queue -> Consumer.\n    \n    Uses `queue.Queue` (Thread-safe).\n\"\"\"\n\nimport threading\nimport queue\nimport time\nimport random\n\nclass System:\n    def __init__(self):\n        self.queue = queue.Queue(maxsize=5)\n        self.sentinel = object() # Marker to stop consumers\n\nclass Producer(threading.Thread):\n    def __init__(self, system):\n        super().__init__()\n        self.system = system\n\n    def run(self):\n        for i in range(5):\n            item = f\"Item-{i}\"\n            print(f\"Producing {item}\")\n            self.system.queue.put(item) # Blocks if full\n            time.sleep(random.random() * 0.01)\n        \n        print(\"Producer finished\")\n        self.system.queue.put(self.system.sentinel)\n\nclass Consumer(threading.Thread):\n    def __init__(self, system):\n        super().__init__()\n        self.system = system\n        self.consumed = []\n\n    def run(self):\n        while True:\n            item = self.system.queue.get() # Blocks if empty\n            if item is self.system.sentinel:\n                self.system.queue.put(item) # Putting back for other consumers (if multiple)\n                break\n            \n            print(f\"Consuming {item}\")\n            self.consumed.append(item)\n            self.system.queue.task_done()\n            time.sleep(random.random() * 0.01)\n\ndef run_tests():\n    sys = System()\n    p = Producer(sys)\n    c = Consumer(sys)\n    \n    p.start()\n    c.start()\n    \n    p.join()\n    c.join()\n    \n    assert len(c.consumed) == 5\n    print(\"[PASS] Producer-Consumer Pattern\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Concurrency/threading_basics_and_locking.py", "title": "threading basics and locking", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Concurrency/threading_basics_and_locking.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Concurrency"], "content": "\"\"\"\nTitle: Threading Basics and Locking\nTopic: Concurrency\n\nTheory:\n    Threads share the same memory space. Ideal for I/O bound tasks.\n    \n    GIL (Global Interpreter Lock): \n    Python threads cannot run CPU-bound bytecodes in parallel (mostly).\n    Only one thread executes Python bytecode at a time.\n    \n    Race Conditions:\n    Must use Locks (`threading.Lock`) when modifying shared state.\n\"\"\"\n\nimport threading\nimport time\n\nclass BankAccount:\n    def __init__(self):\n        self.balance = 0\n        self.lock = threading.Lock()\n\n    def deposit(self, amount):\n        with self.lock:\n            # Critical Section\n            local = self.balance\n            time.sleep(0.001) # Force context switch risk\n            self.balance = local + amount\n\ndef worker(account):\n    for _ in range(100):\n        account.deposit(1)\n\ndef run_tests():\n    acc = BankAccount()\n    threads = []\n    \n    # Create 10 threads\n    for _ in range(10):\n        t = threading.Thread(target=worker, args=(acc,))\n        threads.append(t)\n        t.start()\n    \n    # Wait for all\n    for t in threads:\n        t.join()\n        \n    print(f\"Final Balance: {acc.balance}\")\n    # Should be 10 * 100 = 1000\n    assert acc.balance == 1000\n    \n    print(\"[PASS] Threading and Locking\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Design_Patterns/behavioral_observer_strategy_command_state.py", "title": "behavioral observer strategy command state", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/behavioral_observer_strategy_command_state.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Design Patterns"], "content": "\"\"\"\nTitle: Behavioral Patterns (Observer, Strategy, Command, State)\nTopic: Design Patterns\n\nTheory:\n    Focus on communication between objects.\n    \n    1. Observer: One-to-many dependency. Notifies dependents of state change.\n    2. Strategy: Encapsulate algorithms and make them interchangeable.\n    3. Command: Encapsulate a request as an object.\n    4. State: Allow object to alter behavior when internal state changes.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\n\n# ==========================================\n# 1. Observer\n# ==========================================\n\nclass Observer:\n    def update(self, msg): pass\n\nclass Subject:\n    def __init__(self):\n        self._observers = []\n    \n    def attach(self, obs):\n        self._observers.append(obs)\n    \n    def notify(self, msg):\n        for o in self._observers:\n            o.update(msg)\n\nclass LogObserver(Observer):\n    def __init__(self):\n        self.log = []\n    def update(self, msg):\n        self.log.append(msg)\n\n# ==========================================\n# 2. Strategy\n# ==========================================\n\nclass SortStrategy(ABC):\n    @abstractmethod\n    def sort(self, data): pass\n\nclass QuickSort(SortStrategy):\n    def sort(self, data): return sorted(data) # Pseudo\n\nclass ReverseSort(SortStrategy):\n    def sort(self, data): return sorted(data, reverse=True)\n\nclass Sorter:\n    def __init__(self, strategy: SortStrategy):\n        self.strategy = strategy\n    \n    def sort_data(self, data):\n        return self.strategy.sort(data)\n\n# ==========================================\n# 3. State\n# ==========================================\n\nclass State(ABC):\n    @abstractmethod\n    def handle(self): pass\n\nclass RedLight(State):\n    def handle(self): return \"STOP\"\n\nclass GreenLight(State):\n    def handle(self): return \"GO\"\n\nclass TrafficLight:\n    def __init__(self):\n        self.state = RedLight()\n    \n    def change(self):\n        if isinstance(self.state, RedLight):\n            self.state = GreenLight()\n        else:\n            self.state = RedLight()\n    \n    def signal(self):\n        return self.state.handle()\n\ndef run_tests():\n    # Observer\n    sub = Subject()\n    obs = LogObserver()\n    sub.attach(obs)\n    sub.notify(\"Event 1\")\n    assert obs.log == [\"Event 1\"]\n    \n    # Strategy\n    s = Sorter(ReverseSort())\n    assert s.sort_data([1,2,3]) == [3,2,1]\n    \n    # State\n    t = TrafficLight()\n    assert t.signal() == \"STOP\"\n    t.change()\n    assert t.signal() == \"GO\"\n    \n    print(\"[PASS] Behavioral Patterns\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Design_Patterns/creational_singleton_factory_builder.py", "title": "creational singleton factory builder", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/creational_singleton_factory_builder.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Design Patterns"], "content": "\"\"\"\nTitle: Creational Patterns (Singleton, Factory, Builder)\nTopic: Design Patterns\n\nTheory:\n    Focus on object creation mechanisms.\n    \n    1. Singleton: Ensure a class has only one instance.\n    2. Factory: Delegate object creation to a factory class/method.\n    3. Builder: Construct complex objects step-by-step.\n\"\"\"\n\n# ==========================================\n# 1. Singleton (Decorator approach)\n# ==========================================\n\nclass SingletonMeta(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=SingletonMeta):\n    pass\n\n# ==========================================\n# 2. Factory Method\n# ==========================================\n\nclass Animal:\n    def speak(self): pass\n\nclass Dog(Animal):\n    def speak(self): return \"Woof\"\n\nclass Cat(Animal):\n    def speak(self): return \"Meow\"\n\nclass AnimalFactory:\n    @staticmethod\n    def create_animal(kind):\n        if kind == \"dog\": return Dog()\n        if kind == \"cat\": return Cat()\n        raise ValueError(\"Unknown animal\")\n\n# ==========================================\n# 3. Builder\n# ==========================================\n\nclass Computer:\n    def __init__(self):\n        self.cpu = None\n        self.ram = None\n        self.gpu = None\n    \n    def __str__(self):\n        return f\"CPU: {self.cpu}, RAM: {self.ram}, GPU: {self.gpu}\"\n\nclass ComputerBuilder:\n    def __init__(self):\n        self.computer = Computer()\n    \n    def add_cpu(self, cpu):\n        self.computer.cpu = cpu\n        return self\n    \n    def add_ram(self, ram):\n        self.computer.ram = ram\n        return self\n    \n    def add_gpu(self, gpu):\n        self.computer.gpu = gpu\n        return self\n    \n    def build(self):\n        return self.computer\n\ndef run_tests():\n    # Singleton\n    d1 = Database()\n    d2 = Database()\n    assert d1 is d2\n    \n    # Factory\n    dog = AnimalFactory.create_animal(\"dog\")\n    assert dog.speak() == \"Woof\"\n    \n    # Builder (Fluent API)\n    pc = ComputerBuilder().add_cpu(\"M1\").add_ram(\"16GB\").build()\n    assert pc.cpu == \"M1\"\n    assert pc.gpu is None # Optional\n    \n    print(\"[PASS] Creational Patterns\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Design_Patterns/iterator_and_generator_patterns.py", "title": "iterator and generator patterns", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/iterator_and_generator_patterns.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Design Patterns"], "content": "\"\"\"\nTitle: Iterator and Generator Patterns\nTopic: Design Patterns\n\nTheory:\n    Iterator Pattern: Provide a way to access elements of an aggregate object uniformly without exposing underlying representation.\n    \n    Python's Protocol: `__iter__` and `__next__`.\n    Generator: A simpler way to create iterators using `yield`.\n\"\"\"\n\n# ==========================================\n# 1. Classic Iterator (Class-based)\n# ==========================================\n\nclass CountDown:\n    def __init__(self, start):\n        self.current = start\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.current <= 0:\n            raise StopIteration\n        val = self.current\n        self.current -= 1\n        return val\n\n# ==========================================\n# 2. Generator (Function-based)\n# ==========================================\n\ndef count_up(limit):\n    \"\"\"Yields numbers from 1 to limit.\"\"\"\n    n = 1\n    while n <= limit:\n        yield n\n        n += 1\n\ndef run_tests():\n    # Iterator\n    c = CountDown(3)\n    assert list(c) == [3, 2, 1]\n    \n    # Generator\n    g = count_up(3)\n    assert list(g) == [1, 2, 3]\n    \n    print(\"[PASS] Iterator and Generator\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Design_Patterns/registry_plugin_architecture.py", "title": "registry plugin architecture", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/registry_plugin_architecture.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Design Patterns"], "content": "\"\"\"\nTitle: Registry Pattern\nTopic: Design Patterns\n\nTheory:\n    Global or scoped central place to store and retrieve objects/classes.\n    Often used for Plugin systems (seen in Metaclasses example too).\n\"\"\"\n\nclass Registry:\n    _objects = {}\n\n    @classmethod\n    def register(cls, name, obj):\n        cls._objects[name] = obj\n\n    @classmethod\n    def get(cls, name):\n        return cls._objects.get(name)\n\n# Decorator based registration\ndef register_service(name):\n    def wrapper(cls):\n        Registry.register(name, cls)\n        return cls\n    return wrapper\n\n@register_service(\"auth\")\nclass AuthService:\n    def login(self): return \"Logged in\"\n\ndef run_tests():\n    svc_cls = Registry.get(\"auth\")\n    assert svc_cls is AuthService\n    \n    svc = svc_cls()\n    assert svc.login() == \"Logged in\"\n    \n    print(\"[PASS] Registry Pattern\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Design_Patterns/structural_adapter_decorator_facade_proxy.py", "title": "structural adapter decorator facade proxy", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/structural_adapter_decorator_facade_proxy.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Design Patterns"], "content": "\"\"\"\nTitle: Structural Patterns (Adapter, Decorator, Facade, Proxy)\nTopic: Design Patterns\n\nTheory:\n    Focus on class and object composition.\n    \n    1. Adapter: Convert interface of a class into another client expects.\n    2. Decorator: Add responsibility dynamically (covered in Advanced).\n    3. Facade: Simplified interface to a complex system.\n    4. Proxy: Placeholder for another object to control access.\n\"\"\"\n\n# ==========================================\n# 1. Adapter\n# ==========================================\n\nclass EuropeanSocket:\n    def voltage(self): return 220\n\nclass USASocket:\n    def voltage(self): return 110\n\nclass AdapterEUtoUSA:\n    def __init__(self, socket):\n        self.socket = socket\n    \n    def voltage(self):\n        # Convert 220 -> 110\n        return self.socket.voltage() / 2\n\n# ==========================================\n# 2. Facade\n# ==========================================\n\nclass CPU:\n    def freeze(self): print(\"CPU frozen\")\n    def execute(self): print(\"CPU Executing\")\n\nclass Memory:\n    def load(self): print(\"Memory loading\")\n\nclass ComputerFacade:\n    def __init__(self):\n        self.cpu = CPU()\n        self.mem = Memory()\n    \n    def start(self):\n        self.cpu.freeze()\n        self.mem.load()\n        self.cpu.execute()\n\n# ==========================================\n# 3. Proxy\n# ==========================================\n\nclass RealImage:\n    def display(self):\n        return \"Displaying Image\"\n\nclass ProxyImage:\n    def __init__(self):\n        self.real_image = None\n    \n    def display(self):\n        if self.real_image is None:\n            self.real_image = RealImage() # Lazy Load\n        return self.real_image.display()\n\ndef run_tests():\n    # Adapter\n    eu = EuropeanSocket()\n    adapter = AdapterEUtoUSA(eu)\n    assert adapter.voltage() == 110\n    \n    # Facade\n    print(\"--- Facade Start ---\")\n    ComputerFacade().start()\n    \n    # Proxy\n    p = ProxyImage()\n    assert p.real_image is None\n    assert p.display() == \"Displaying Image\"\n    assert p.real_image is not None\n    \n    print(\"[PASS] Structural Patterns\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Design_Patterns/template_method_and_hook_patterns.py", "title": "template method and hook patterns", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Design_Patterns/template_method_and_hook_patterns.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Design Patterns"], "content": "\"\"\"\nTitle: Template Method and Hooks\nTopic: Design Patterns\n\nTheory:\n    Template Method: Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps.\n    Hook: A method in the superclass that does nothing (or default) but can be overridden.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\n\nclass CaffeineBeverage(ABC):\n    def prepare(self):\n        \"\"\"The Template Method.\"\"\"\n        self.boil_water()\n        self.brew()\n        self.pour_in_cup()\n        if self.customer_wants_condiments(): # Hook usage\n            self.add_condiments()\n\n    def boil_water(self):\n        print(\"Boiling water\")\n\n    def pour_in_cup(self):\n        print(\"Pouring into cup\")\n\n    @abstractmethod\n    def brew(self): pass\n\n    @abstractmethod\n    def add_condiments(self): pass\n\n    # Hook\n    def customer_wants_condiments(self):\n        return True\n\nclass Tea(CaffeineBeverage):\n    def brew(self):\n        print(\"Steeping the tea\")\n    \n    def add_condiments(self):\n        print(\"Adding Lemon\")\n    \n    def customer_wants_condiments(self):\n        return False # Hook override\n\ndef run_tests():\n    print(\"--- Making Tea ---\")\n    my_tea = Tea()\n    my_tea.prepare()\n    # Output should not contain \"Adding Lemon\"\n    \n    print(\"[PASS] Template Method\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Encapsulation/immutability_patterns.py", "title": "immutability patterns", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Encapsulation/immutability_patterns.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Encapsulation"], "content": "\"\"\"\nTitle: Immutability Patterns\nTopic: Encapsulation\n\nTheory:\n    Immutable objects cannot be changed after creation (e.g., tuples, strings).\n    In custom classes, we can enforce immutability to make code thread-safe and predictable.\n\n    Techniques:\n    1. Property only (no setter).\n    2. Overriding `__setattr__`.\n    3. Using `NamedTuple` or `@dataclass(frozen=True)`.\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom collections import namedtuple\n\n# ==========================================\n# 1. Property-based Immutability\n# ==========================================\n\nclass ImmutablePoint:\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n    @property\n    def x(self):\n        return self._x\n\n    @property\n    def y(self):\n        return self._y\n    \n    # No setters defined!\n\n# ==========================================\n# 2. Hardened Immutability (__setattr__)\n# ==========================================\n\nclass HardFrozen:\n    def __init__(self, val):\n        # We must bypass our own block to set initial value\n        super().__setattr__('val', val)\n\n    def __setattr__(self, name, value):\n        raise AttributeError(f\"Cannot modify immutable instance attribute '{name}'\")\n\n# ==========================================\n# 3. Modern Approaches\n# ==========================================\n\n# A. Named Tuple\nColor = namedtuple('Color', ['r', 'g', 'b'])\n\n# B. Frozen Dataclass\n@dataclass(frozen=True)\nclass User:\n    id: int\n    username: str\n\n# ==========================================\n# Tests\n# ==========================================\n\ndef run_tests():\n    print(\"--- Immutability Tests ---\")\n    \n    # 1. Property\n    p = ImmutablePoint(1, 2)\n    try:\n        p.x = 10\n    except AttributeError:\n        print(\"Caught expected AttributeError (Property)\")\n\n    # 2. Hard Frozen\n    h = HardFrozen(\"Test\")\n    try:\n        h.val = \"New\"\n    except AttributeError:\n        print(\"Caught expected AttributeError (__setattr__)\")\n\n    # 3. Dataclass\n    u = User(1, \"admin\")\n    try:\n        u.item = \"something\" # Frozen classes don't allow new attributes either\n    except Exception as e: # Frozen dataclasses raise FrozenInstanceError\n        print(f\"Caught expected error (Frozen Dataclass): {type(e).__name__}\")\n\n    print(\"[PASS] Verify Immutability passed.\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Encapsulation/name_mangling_and_access_patterns.py", "title": "name mangling and access patterns", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Encapsulation/name_mangling_and_access_patterns.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Encapsulation"], "content": "\"\"\"\nTitle: Name Mangling and Access Patterns\nTopic: Encapsulation\n\nTheory:\n    Name mangling is triggered by double underscores prefix `__var`.\n    Python rewrites `__var` to `_ClassName__var`.\n\n    Purpose: \n    - Prevent accidental overriding of internal variables in subclasses.\n    - NOT for security (it is easily reversible).\n\n    Access Patterns check:\n    - `obj.public`\n    - `obj._protected` (Trust based)\n    - `getattr(obj, 'name')` (Dynamic access)\n\"\"\"\n\n# ==========================================\n# 1. Subclass Collision mechanics\n# ==========================================\n\nclass Base:\n    def __init__(self):\n        self.public = \"Base Public\"\n        self._protected = \"Base Protected\"\n        self.__private = \"Base Private\" # Becomes _Base__private\n\n    def get_private(self):\n        return self.__private\n\nclass Child(Base):\n    def __init__(self):\n        super().__init__()\n        self.public = \"Child Public\"       # Overrides\n        self._protected = \"Child Protected\" # Overrides\n        self.__private = \"Child Private\"    # DOES NOT Override Base.__private!\n        # Because this becomes _Child__private\n\n    def get_child_private(self):\n        return self.__private\n\n# ==========================================\n# Demonstration\n# ==========================================\n\ndef run_demo():\n    print(\"--- Name Mangling Logic ---\")\n    b = Base()\n    c = Child() \n\n    # 1. Standard overrides\n    assert c.public == \"Child Public\"\n    assert c._protected == \"Child Protected\"\n\n    # 2. Private variables do NOT collide\n    print(f\"Base Method returns: {c.get_private()}\")       # Returns \"Base Private\"\n    print(f\"Child Method returns: {c.get_child_private()}\") # Returns \"Child Private\"\n\n    # 3. Inspecting the dictionary\n    print(f\"\\nObject Dict keys: {c.__dict__.keys()}\")\n    \n    # We should see '_Base__private' AND '_Child__private'\n    assert '_Base__private' in c.__dict__\n    assert '_Child__private' in c.__dict__\n\n    print(\"[PASS] Name mangling prevented collision.\")\n\nif __name__ == \"__main__\":\n    run_demo()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Encapsulation/private_protected_members.py", "title": "private protected members", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Encapsulation/private_protected_members.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Encapsulation"], "content": "\"\"\"\nTitle: Private and Protected Members\nTopic: Encapsulation\n\nTheory:\n    Python does not have strict private/protected access modifiers like Java or C++.\n    It uses naming conventions:\n    \n    1. Public (`self.name`): Accessible from anywhere.\n    2. Protected (`self._name`): Strong convention. Should only be accessed within the class \n       and subclasses. No enforcement by language.\n    3. Private (`self.__name`): Naming convention that triggers \"Name Mangling\". \n       Makes it harder (but not impossible) to access from outside.\n\n    Pitfalls:\n    - Relying on `__private` for security. It's just for avoiding namespace collisions in subclasses.\n\"\"\"\n\n# ==========================================\n# 1. Implementation\n# ==========================================\n\nclass BankAccount:\n    def __init__(self, owner: str, balance: float):\n        self.owner = owner       # Public\n        self._balance = balance  # Protected (Convention)\n        self.__pin = 1234        # Private (Name Mangled)\n\n    def deposit(self, amount: float):\n        if amount > 0:\n            self._balance += amount\n            print(f\"Deposited {amount}\")\n\n    def _internal_audit(self):\n        \"\"\"Protected method: internal use only.\"\"\"\n        return f\"Audit: {self._balance}\"\n\n    def verify_pin(self, pin: int) -> bool:\n        return self.__pin == pin\n\n\nclass SavingsAccount(BankAccount):\n    def add_interest(self):\n        # We can access _balance (Protected)\n        interest = self._balance * 0.05\n        self._balance += interest\n        \n    def try_access_pin(self):\n        try:\n            return self.__pin # Error! __pin is mangled in Parent\n        except AttributeError:\n            return \"Cannot access __pin directly\"\n\n\n# ==========================================\n# 2. Access outside class\n# ==========================================\n\ndef demonstration():\n    print(\"--- Access Modifiers ---\")\n    acc = BankAccount(\"Alice\", 1000)\n\n    # Public\n    print(f\"Owner: {acc.owner}\")\n\n    # Protected - Mutable from outside (Not recommended but possible)\n    print(f\"Balance (Protected): {acc._balance}\") \n    acc._balance = 5000 \n    assert acc._balance == 5000\n\n    # Private - AttributeError\n    try:\n        print(acc.__pin)\n    except AttributeError:\n        print(\"Caught expected error: 'BankAccount' object has no attribute '__pin'\")\n    \n    # Accessing Mangled Name (The bypass)\n    # _ClassName__AttributeName\n    print(f\"Mangled Pin access: {acc._BankAccount__pin}\")\n    assert acc._BankAccount__pin == 1234\n\n\n# ==========================================\n# Tests\n# ==========================================\n\nif __name__ == \"__main__\":\n    demonstration()\n\n    s = SavingsAccount(\"Bob\", 500)\n    s.add_interest()\n    assert s._balance == 525.0\n    \n    assert s.try_access_pin() == \"Cannot access __pin directly\"\n    \n    print(\"\\n[PASS] Private/Protected tests passed.\")\n"}, {"id": "python/PythonMasteryRepo/OOPs/Encapsulation/property_decorator_and_descriptors.py", "title": "property decorator and descriptors", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Encapsulation/property_decorator_and_descriptors.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Encapsulation"], "content": "\"\"\"\nTitle: Property Decorator and Descriptors\nTopic: Encapsulation\n\nTheory:\n    We've seen basic `@property`. This file looks closer at how it encapsulates logic.\n    Also introduces the concept of Descriptors: the mechanism behind properties.\n\n    - A Descriptor is any object that defines `__get__`, `__set__`, or `__delete__`.\n    - Properties are implementing the descriptor protocol.\n\n    Use Case: \n    - Validation logic reuse. If multiple attributes need similar validation (e.g., \"must be positive integer\"),\n      writing a custom descriptor is better than multiple properties.\n\n\"\"\"\n\n# ==========================================\n# 1. Reuse logic with Descriptors\n# ==========================================\n\nclass PositiveInteger:\n    \"\"\"A Descriptor for enforcing positive integers.\"\"\"\n    \n    def __init__(self, default=0):\n        self.default = default\n        self.data = {} # Simulating storage (In real descriptors, use instance.__dict__)\n\n    def __set_name__(self, owner, name):\n        # Called when the descriptor is instantiated in a class\n        self.name = name\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        return instance.__dict__.get(self.name, self.default)\n\n    def __set__(self, instance, value):\n        if not isinstance(value, int):\n            raise TypeError(f\"{self.name} must be an integer\")\n        if value < 0:\n            raise ValueError(f\"{self.name} must be positive\")\n        instance.__dict__[self.name] = value\n\n\nclass Rectangle:\n    # Using the descriptor\n    width = PositiveInteger()\n    height = PositiveInteger()\n\n    def __init__(self, w, h):\n        self.width = w\n        self.height = h\n\n    @property # Standard property for computed value\n    def area(self):\n        return self.width * self.height\n\n\n# ==========================================\n# 2. Standard Property (Encapsulation logic)\n# ==========================================\n\nclass Celsius:\n    def __init__(self, temperature=0):\n        self._temperature = temperature\n\n    @property\n    def temperature(self):\n        return self._temperature\n\n    @temperature.setter\n    def temperature(self, value):\n        if value < -273.15:\n            raise ValueError(\"Temperature below absolute zero is impossible\")\n        self._temperature = value\n\n    def to_fahrenheit(self):\n        return (self.temperature * 1.8) + 32\n\n\n# ==========================================\n# Tests\n# ==========================================\n\ndef run_tests():\n    print(\"--- Descriptor & Property Tests ---\")\n\n    # 1. Descriptor\n    r = Rectangle(10, 20)\n    assert r.area == 200\n    \n    try:\n        r.width = -5\n    except ValueError as e:\n        print(f\"Caught descriptor error: {e}\")\n\n    # 2. Property\n    c = Celsius(25)\n    assert c.to_fahrenheit() == 77.0\n    \n    try:\n        c.temperature = -300\n    except ValueError as e:\n        print(f\"Caught property error: {e}\")\n\nif __name__ == \"__main__\":\n    run_tests()\n    print(\"[PASS] All tests passed.\")\n"}, {"id": "python/PythonMasteryRepo/OOPs/Error_Handling/contextlib_and_safe_resource_cleanup.py", "title": "contextlib and safe resource cleanup", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Error_Handling/contextlib_and_safe_resource_cleanup.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Error Handling"], "content": "\"\"\"\nTitle: Contextlib and Safe Resource Cleanup\nTopic: Error Handling\n\nTheory:\n    `contextlib` provides utilities for common context manager tasks.\n    - `@contextmanager`: Generator to context manager.\n    - `closing()`: Auto-close objects not supporting context proto.\n    - `suppress()`: Ignore specific exceptions.\n\"\"\"\n\nfrom contextlib import contextmanager, suppress\n\n@contextmanager\ndef temporary_file(name):\n    print(f\"Creating temp file {name}...\")\n    try:\n        yield name\n    finally:\n        print(f\"Deleting temp file {name}...\")\n\ndef run_tests():\n    # 1. Generator CM\n    with temporary_file(\"test.txt\") as f:\n        print(f\"Working with {f}\")\n    \n    # 2. Suppress\n    with suppress(FileNotFoundError):\n        open(\"non_existent_file.txt\")\n    print(\"Continued execution after suppress\")\n    \n    print(\"[PASS] Contextlib tools\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Error_Handling/design_by_contract_assertions_and_type_checks.py", "title": "design by contract assertions and type checks", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Error_Handling/design_by_contract_assertions_and_type_checks.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Error Handling"], "content": "\"\"\"\nTitle: Design by Contract (Assertions and Type Checks)\nTopic: Error Handling\n\nTheory:\n    DbC defines Preconditions (Args valid), Postconditions (Return valid), and Invariants (State valid).\n    \n    Python tools:\n    - `assert`: Optimized out with `-O`. Good for internal sanity checks.\n    - Exceptions: For runtime input validation (Public API).\n\"\"\"\n\ndef divide(a, b):\n    # Precondition (Internal)\n    assert isinstance(a, (int, float)), \"a must be number\"\n    assert isinstance(b, (int, float)), \"b must be number\"\n    assert b != 0, \"b cannot be zero\"\n    \n    result = a / b\n    \n    # Postcondition\n    assert result * b == a, \"Math broken\" \n    return result\n\nclass Account:\n    def __init__(self, balance):\n        self._balance = balance\n        self._invariant()\n\n    def _invariant(self):\n        assert self._balance >= 0, \"Balance cannot be negative\"\n\n    def withdraw(self, amount):\n        if amount > self._balance:\n            raise ValueError(\"Insufficient funds\")\n        self._balance -= amount\n        self._invariant()\n\ndef run_tests():\n    assert divide(10, 2) == 5.0\n    \n    try:\n        divide(10, 0)\n    except AssertionError as e:\n        print(f\"Caught assertion: {e}\")\n\n    acc = Account(100)\n    acc.withdraw(50)\n    \n    print(\"[PASS] DbC assertions\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Error_Handling/exceptions_hierarchy_and_custom_exceptions.py", "title": "exceptions hierarchy and custom exceptions", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Error_Handling/exceptions_hierarchy_and_custom_exceptions.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Error Handling"], "content": "\"\"\"\nTitle: Exceptions Hierarchy and Custom Exceptions\nTopic: Error Handling\n\nTheory:\n    All exceptions inherit from `BaseException`.\n    Standard exceptions inherit from `Exception`.\n    \n    Structure:\n    BaseException\n     +-- SystemExit\n     +-- KeyboardInterrupt\n     +-- Exception\n          +-- .... (ValueError, TypeError, etc)\n\n    Best Practice:\n    - Inherit from `Exception` for custom errors.\n    - Don't catch `BaseException` unless intended (catches exit signals!).\n\"\"\"\n\nclass MyAppError(Exception):\n    \"\"\"Base class for all app errors.\"\"\"\n    pass\n\nclass ValidationError(MyAppError):\n    def __init__(self, field, message):\n        self.field = field\n        self.message = message\n        super().__init__(f\"Invalid {field}: {message}\")\n\nclass NetworkError(MyAppError):\n    pass\n\ndef validate_age(age):\n    if age < 0:\n        raise ValidationError(\"age\", \"Must be positive\")\n\ndef run_tests():\n    try:\n        validate_age(-5)\n    except ValidationError as e:\n        print(f\"Caught: {e}\")\n        assert e.field == \"age\"\n    except MyAppError:\n        print(\"Caught generic app error\")\n    except Exception:\n        print(\"Caught generic exception\")\n\n    print(\"[PASS] Custom Exceptions\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Inheritance/hierarchical_inheritance.py", "title": "hierarchical inheritance", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Inheritance/hierarchical_inheritance.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Inheritance"], "content": "\"\"\"\nTitle: Hierarchical Inheritance\nTopic: Inheritance\n\nTheory:\n    Multiple classes inherit from a single Base class.\n    One Parent -> Many Children.\n\"\"\"\n\nclass Shape:\n    def describe(self):\n        return \"I am a shape\"\n\nclass Circle(Shape):\n    def roll(self):\n        return \"Rolling\"\n\nclass Square(Shape):\n    def stack(self):\n        return \"Stacking\"\n\ndef run_test():\n    c = Circle()\n    s = Square()\n    \n    # Both share Parent method\n    assert c.describe() == \"I am a shape\"\n    assert s.describe() == \"I am a shape\"\n    \n    # But disjoint sibling methods\n    assert hasattr(c, 'roll')\n    assert not hasattr(s, 'roll')\n    \n    print(\"[PASS] Hierarchical inheritance\")\n\nif __name__ == \"__main__\":\n    run_test()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Inheritance/hybrid_inheritance.py", "title": "hybrid inheritance", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Inheritance/hybrid_inheritance.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Inheritance"], "content": "\"\"\"\nTitle: Hybrid Inheritance\nTopic: Inheritance\n\nTheory:\n    Hybrid Inheritance is a mix of two or more types (e.g., Single + Multiple).\n    Typically results in the \"Diamond Problem\" structure.\n    \n    Python handles this purely via MRO. No special keyword.\n    \n    Complexity:\n    High human cognitive load. Avoid deep hybrid graphs if possible.\n\"\"\"\n\nclass Device:\n    def __init__(self, name):\n        self.name = name\n\nclass Phone(Device): # Single\n    def call(self):\n        return \"Calling\"\n\nclass Camera(Device): # Single\n    def snap(self):\n        return \"Snapping\"\n\nclass SmartPhone(Phone, Camera): # Multiple (creating Hybrid overall)\n    def __init__(self, name):\n        # We need to initialize carefully.\n        # Since Device is not cooperative (didn't use super presumably, or is simple),\n        # we might just direct init if it's the same base.\n        # But correctly, we should use super() if base is shared.\n        super().__init__(name)\n\n    def feature(self):\n        return f\"{self.name}: {self.call()} and {self.snap()}\"\n\ndef run_test():\n    s = SmartPhone(\"iPhone\")\n    assert s.call() == \"Calling\"\n    assert s.snap() == \"Snapping\"\n    assert s.name == \"iPhone\"\n    \n    print(\"[PASS] Hybrid structure valid\")\n\nif __name__ == \"__main__\":\n    run_test()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Inheritance/method_resolution_order_mro.py", "title": "method resolution order mro", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Inheritance/method_resolution_order_mro.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Inheritance"], "content": "\"\"\"\nTitle: Method Resolution Order (MRO)\nTopic: Inheritance\n\nTheory:\n    Python uses the C3 Linearization Algorithm (since 2.3) to determine the MRO.\n    It ensures:\n    - Children are visited before parents.\n    - Parent order is preserved (Left to Right).\n    - Monotonicity (subclassing doesn't change valid orderings).\n\n    You can view it via `ClassName.__mro__` or `ClassName.mro()`.\n\"\"\"\n\nclass A:\n    def process(self):\n        return \"A\"\n\nclass B(A):\n    def process(self):\n        return \"B\"\n\nclass C(A):\n    def process(self):\n        return \"C\"\n\n# Diamond Inheritance\nclass D(B, C):\n    \"\"\"\n      A\n     / \\\\\n    B   C\n     \\\\ /\n      D\n    \n    MRO should be: D -> B -> C -> A -> object\n    \"\"\"\n    pass\n\ndef run_analysis():\n    print(\"--- MRO Analysis ---\")\n    \n    mro = [x.__name__ for x in D.mro()]\n    print(f\"D MRO: {mro}\")\n    \n    assert mro == ['D', 'B', 'C', 'A', 'object']\n    \n    d = D()\n    # It calls B's process because B is first after D\n    assert d.process() == \"B\" \n    \n    print(\"[PASS] MRO logic verified\")\n\nif __name__ == \"__main__\":\n    run_analysis()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Inheritance/multilevel_inheritance.py", "title": "multilevel inheritance", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Inheritance/multilevel_inheritance.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Inheritance"], "content": "\"\"\"\nTitle: Multilevel Inheritance\nTopic: Inheritance\n\nTheory:\n    A class inherits from a child class, forming a chain.\n    GrandParent -> Parent -> Child.\n\n    MRO (Method Resolution Order) is linear here.\n\"\"\"\n\nclass Organism:\n    def live(self):\n        return \"I am alive\"\n\nclass Animal(Organism):\n    def eat(self):\n        return \"I eat food\"\n\nclass Dog(Animal):\n    def bark(self):\n        return \"Woof\"\n\ndef run_test():\n    d = Dog()\n    assert d.live() == \"I am alive\" # From GrandParent\n    assert d.eat() == \"I eat food\"  # From Parent\n    assert d.bark() == \"Woof\"       # From Child\n    \n    # Check inheritance chain\n    assert isinstance(d, Dog)\n    assert isinstance(d, Animal)\n    assert isinstance(d, Organism)\n    \n    print(\"[PASS] Multilevel inheritance\")\n\nif __name__ == \"__main__\":\n    run_test()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Inheritance/multiple_inheritance.py", "title": "multiple inheritance", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Inheritance/multiple_inheritance.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Inheritance"], "content": "\"\"\"\nTitle: Multiple Inheritance\nTopic: Inheritance\n\nTheory:\n    A class can inherit from more than one parent.\n    `class Child(Parent1, Parent2):`\n\n    Complexity matches:\n    - Search order matters (Left to Right).\n    - The \"Diamond Problem\" (ambiguity) is solved by Python's MRO.\n\n    Pitfalls:\n    - Naming collisions between parents.\n    - Complex dependency graphs making code hard to trace.\n\"\"\"\n\nclass Flyer:\n    def fly(self):\n        return \"I can fly\"\n    \n    def action(self):\n        return \"Flying high\"\n\nclass Swimmer:\n    def swim(self):\n        return \"I can swim\"\n\n    def action(self):\n        return \"Swimming deep\"\n\nclass Duck(Flyer, Swimmer):\n    \"\"\"\n    Inherits from both.\n    Where 'action' is defined in both, the first one in the list wins \n    unless overridden.\n    Duck(Flyer, Swimmer) -> Flyer.action wins.\n    \"\"\"\n    pass\n\nclass Penguin(Swimmer, Flyer):\n    \"\"\"\n    Swapped order.\n    Penguin(Swimmer, Flyer) -> Swimmer.action wins.\n    \"\"\"\n    pass\n\ndef run_tests():\n    d = Duck()\n    assert d.fly() == \"I can fly\"\n    assert d.swim() == \"I can swim\"\n    # Resolution based on order\n    assert d.action() == \"Flying high\" \n\n    p = Penguin()\n    assert p.action() == \"Swimming deep\"\n\n    print(\"[PASS] Multiple Inheritance basics\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Inheritance/single_inheritance.py", "title": "single inheritance", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Inheritance/single_inheritance.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Inheritance"], "content": "\"\"\"\nTitle: Single Inheritance\nTopic: Inheritance\n\nTheory:\n    Single Inheritance: A Child class inherits from exactly one Parent class.\n    \n    Terminology:\n    - Base Class / Parent Class / Super Class\n    - Derived Class / Child Class / Sub Class\n\n    Benefits: Reuse code, extend functionality.\n\"\"\"\n\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def eat(self):\n        return f\"{self.name} is eating.\"\n\nclass Dog(Animal):\n    def bark(self):\n        return \"Woof!\"\n\ndef run_test():\n    d = Dog(\"Buddy\")\n    # Method from Parent\n    assert d.eat() == \"Buddy is eating.\"\n    # Method from Child\n    assert d.bark() == \"Woof!\"\n    \n    print(\"[PASS] Single inheritance\")\n\nif __name__ == \"__main__\":\n    run_test()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Inheritance/super_function_and_cooperative_multiple_inheritance.py", "title": "super function and cooperative multiple inheritance", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Inheritance/super_function_and_cooperative_multiple_inheritance.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Inheritance"], "content": "\"\"\"\nTitle: Super() and Cooperative Multiple Inheritance\nTopic: Inheritance\n\nTheory:\n    `super()` returns a proxy object that delegates method calls to a parent/sibling class \n    **based on the MRO**, not just the immediate parent.\n    \n    \"Cooperative Inheritance\":\n    - Classes are designed to work together in a hierarchy.\n    - Each class calls `super().method()`, passing arguments along.\n    - This ensures every class in the diamond gets called exactly once (if structured correctly).\n\n    Pitfall:\n    - Mixing classes that user `super()` with classes that don't (breaking the chain).\n    - Arguments mismatch in the chain (`*args, **kwargs` is often needed).\n\"\"\"\n\nclass BaseModule:\n    def __init__(self):\n        print(\"BaseModule Init\")\n\nclass LoggerMixin(BaseModule):\n    def __init__(self):\n        print(\"LoggerMixin Init Start\")\n        super().__init__() # Calls next in MRO\n        print(\"LoggerMixin Init End\")\n\nclass DatabaseMixin(BaseModule):\n    def __init__(self):\n        print(\"DatabaseMixin Init Start\")\n        super().__init__() # Calls next in MRO\n        print(\"DatabaseMixin Init End\")\n\nclass App(LoggerMixin, DatabaseMixin):\n    \"\"\"\n    MRO: App -> LoggerMixin -> DatabaseMixin -> BaseModule -> object\n    \"\"\"\n    def __init__(self):\n        print(\"App Init Start\")\n        super().__init__()\n        print(\"App Init End\")\n\ndef run_demo():\n    print(\"--- Cooperative Init Chain ---\")\n    # Expected Output flow:\n    # App Start -> Logger Start -> Database Start -> Base -> Database End -> Logger End -> App End\n    app = App()\n    \n    # Verify MRO\n    mro_names = [c.__name__ for c in App.mro()]\n    assert mro_names == ['App', 'LoggerMixin', 'DatabaseMixin', 'BaseModule', 'object']\n    print(\"\\n[PASS] Cooperative inheritance demonstrated\")\n\nif __name__ == \"__main__\":\n    run_demo()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Polymorphism/duck_typing_and_eafp.py", "title": "duck typing and eafp", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/duck_typing_and_eafp.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Polymorphism"], "content": "\"\"\"\nTitle: Duck Typing and EAFP\nTopic: Polymorphism\n\nTheory:\n    Duck Typing: \"If it walks like a duck and quacks like a duck, it's a duck.\"\n    We check for behaviors (methods presence) rather than type.\n\n    EAFP: Easier to Ask for Forgiveness than Permission.\n    Try doing the operation, and catch the exception if it fails.\n    Contrast with LBYL (Look Before You Leap).\n\"\"\"\n\nclass Duck:\n    def quack(self):\n        print(\"Quack!\")\n\nclass Person:\n    def quack(self):\n        print(\"I'm quacking like a duck!\")\n\nclass Car:\n    def honk(self):\n        print(\"Beep\")\n\n# ==========================================\n# 1. Duck Typing\n# ==========================================\n\ndef make_it_quack(obj):\n    # Doesn't care if it's a Duck or Person, as long as it has .quack()\n    try:\n        obj.quack()\n        return True\n    except AttributeError:\n        print(\"This object cannot quack\")\n        return False\n\n# ==========================================\n# 2. EAFP vs LBYL\n# ==========================================\n\ndef get_value_eafp(data, key):\n    try:\n        return data[key]\n    except KeyError:\n        return None\n\ndef get_value_lbyl(data, key):\n    if key in data:\n        return data[key]\n    return None\n\n# ==========================================\n# Tests\n# ==========================================\n\ndef run_tests():\n    d = Duck()\n    p = Person()\n    c = Car()\n\n    assert make_it_quack(d) == True\n    assert make_it_quack(p) == True\n    assert make_it_quack(c) == False\n    \n    print(\"[PASS] Duck typing verification\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Polymorphism/method_overloading_pythonic_alternatives.py", "title": "method overloading pythonic alternatives", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/method_overloading_pythonic_alternatives.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Polymorphism"], "content": "\"\"\"\nTitle: Method Overloading (And Pythonic Alternatives)\nTopic: Polymorphism\n\nTheory:\n    Traditional Overloading (Same method name, different signatures) is NOT supported in Python.\n    Defining the method twice simply overwrites the first one.\n\n    Pythonic Alternatives:\n    1. Default Arguments (`def foo(x, y=None)`).\n    2. Variable Arguments (`*args`, `**kwargs`).\n    3. `functools.singledispatch` (for type-based overloading).\n\"\"\"\n\nfrom functools import singledispatch\nfrom typing import Union\n\n# ==========================================\n# 1. Using Default Arguments (Most Common)\n# ==========================================\n\nclass MathOps:\n    def add(self, a, b, c=0):\n        \"\"\"Simulates add(a,b) and add(a,b,c)\"\"\"\n        return a + b + c\n\n\n# ==========================================\n# 2. Using *args (Variable Length)\n# ==========================================\n\nclass Logger:\n    def log(self, message, *args):\n        \"\"\"Simulates multiple log signatures\"\"\"\n        full_msg = message\n        for arg in args:\n            full_msg += f\" {arg}\"\n        return full_msg\n\n\n# ==========================================\n# 3. Using Single Dispatch (Type-based)\n# ==========================================\n\n@singledispatch\ndef process(data):\n    \"\"\"Base generic function\"\"\"\n    raise ValueError(\"Unknown type\")\n\n@process.register(int)\ndef _(data):\n    return f\"Processing integer: {data}\"\n\n@process.register(list)\ndef _(data):\n    return f\"Processing list of length {len(data)}\"\n\n# ==========================================\n# Tests\n# ==========================================\n\ndef run_tests():\n    # 1. Defaults\n    m = MathOps()\n    assert m.add(1, 2) == 3\n    assert m.add(1, 2, 3) == 6\n    \n    # 2. Args\n    l = Logger()\n    assert l.log(\"Error\", 404, \"Not Found\") == \"Error 404 Not Found\"\n\n    # 3. Single Dispatch\n    assert process(10) == \"Processing integer: 10\"\n    assert process([1,2,3]) == \"Processing list of length 3\"\n    \n    print(\"[PASS] Overloading patterns working\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Polymorphism/method_overriding.py", "title": "method overriding", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/method_overriding.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Polymorphism"], "content": "\"\"\"\nTitle: Method Overriding\nTopic: Polymorphism\n\nTheory:\n    Child class provides a specific implementation of a method that is already defined in its Parent.\n    This allows polymorphism: treat Child as Parent, but get Child's behavior.\n\n    Use `super()` to extend rather than replace fully.\n\"\"\"\n\nclass PaymentProcessor:\n    def process_payment(self, amount):\n        return \"Base payment processing\"\n\nclass CreditCard(PaymentProcessor):\n    def process_payment(self, amount):\n        # Full Override\n        return f\"Charging Credit Card: {amount}\"\n\nclass PayPal(PaymentProcessor):\n    def process_payment(self, amount):\n        # Extending Base Behavior\n        base_msg = super().process_payment(amount)\n        return f\"PayPal Wrapper -> {base_msg}\"\n\ndef run_transaction(processor: PaymentProcessor, amount):\n    \"\"\"Polymorphic Function\"\"\"\n    return processor.process_payment(amount)\n\ndef run_tests():\n    cc = CreditCard()\n    pp = PayPal()\n    \n    # Same function call, different behavior\n    assert run_transaction(cc, 100) == \"Charging Credit Card: 100\"\n    assert \"PayPal Wrapper\" in run_transaction(pp, 50)\n    \n    print(\"[PASS] Method overriding\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Polymorphism/operator_overloading_magic_methods.py", "title": "operator overloading magic methods", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/operator_overloading_magic_methods.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Polymorphism"], "content": "\"\"\"\nTitle: Operator Overloading (Magic Methods)\nTopic: Polymorphism\n\nTheory:\n    Python allows changing the meaning of operators (+, -, *, ==) for custom classes.\n    Double underscore methods (`__dunder__`) handle this.\n\n    Common ones:\n    - `__add__(self, other)` -> `+`\n    - `__sub__(self, other)` -> `-`\n    - `__eq__(self, other)`  -> `==`\n    - `__lt__(self, other)`  -> `<`\n    - `__str__` vs `__repr__`\n\"\"\"\n\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.x + other.x, self.y + other.y)\n        raise TypeError(\"Can only add Vector to Vector\")\n\n    def __eq__(self, other):\n        if isinstance(other, Vector):\n            return self.x == other.x and self.y == other.y\n        return False\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n    \n    def __repr__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\ndef run_tests():\n    v1 = Vector(1, 2)\n    v2 = Vector(3, 4)\n    v3 = v1 + v2 # Calls __add__\n    \n    assert v3.x == 4\n    assert v3.y == 6\n    \n    assert v1 != v2\n    assert Vector(1, 2) == v1\n    \n    print(f\"String Rep: {v1}\")\n    print(\"[PASS] Operator overloading\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Polymorphism/typing_protocols_structural_subtyping.py", "title": "typing protocols structural subtyping", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Polymorphism/typing_protocols_structural_subtyping.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Polymorphism"], "content": "\"\"\"\nTitle: Protocols (Structural Subtyping)\nTopic: Polymorphism\n\nTheory:\n    Introduced in Python 3.8 (`typing.Protocol`).\n    Allows \"Static Duck Typing\".\n    \n    If a class implements the methods defined in the Protocol, it is considered a subtype of that Protocol,\n    even if it doesn't explicitly inherit from it.\n\"\"\"\n\nfrom typing import Protocol, List\n\n# ==========================================\n# 1. Define Protocol\n# ==========================================\n\nclass Drawable(Protocol):\n    def draw(self) -> str:\n        \"\"\"Any class with this method satisfies Drawable.\"\"\"\n        ...\n\n# ==========================================\n# 2. Implementations (No inheritance needed!)\n# ==========================================\n\nclass Circle:\n    def draw(self) -> str:\n        return \"Drawing Circle\"\n\nclass Square:\n    def draw(self) -> str:\n        return \"Drawing Square\"\n\nclass User:\n    def save(self):\n        return \"Saving\"\n    # Does NOT implement draw\n\n# ==========================================\n# 3. Usage\n# ==========================================\n\ndef render(shapes: List[Drawable]):\n    output = []\n    for s in shapes:\n        output.append(s.draw())\n    return output\n\n# ==========================================\n# Tests\n# ==========================================\n\ndef run_tests():\n    c = Circle()\n    s = Square()\n    u = User()\n\n    # Valid Usage\n    results = render([c, s])\n    assert results == [\"Drawing Circle\", \"Drawing Square\"]\n    \n    # Static Analysis would catch 'u' passed to render, \n    # but runtime python just crashes if we try to call .draw() on u\n    try:\n        render([u]) # type: ignore\n    except AttributeError:\n        print(\"Caught expected error for non-conforming type\")\n\n    print(\"[PASS] Protocols (Structural Subtyping)\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Testing/layering_and_package_structure.py", "title": "layering and package structure", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Testing/layering_and_package_structure.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Testing"], "content": "\"\"\"\nTitle: Layering and Package Structure\nTopic: Architecture\n\nTheory:\n    Separation of Concerns is key.\n    Typical Layers:\n    1. Presentation / API Layer (Routes, CLI)\n    2. Service / Business Logic Layer (Orchestration)\n    3. Data Access Layer (Repositories, DB)\n    4. Domain / Model Layer (Pure Python Objects)\n\n    Dependency Rule: Inner layers (Domain) should NOT depend on outer layers (DB/Web).\n\"\"\"\n\n# ==========================================\n# Domain Layer (Pure)\n# ==========================================\nclass User:\n    def __init__(self, name):\n        self.name = name\n\n# ==========================================\n# Data Layer (Infrastructure)\n# ==========================================\nclass UserRepo:\n    def save(self, user):\n        print(f\"DB: INSERT INTO users ({user.name})\")\n\n# ==========================================\n# Service Layer (Business Logic)\n# ==========================================\nclass UserService:\n    def __init__(self, repo):\n        self.repo = repo\n    \n    def register(self, name):\n        if len(name) < 3:\n            raise ValueError(\"Name too short\")\n        u = User(name)\n        self.repo.save(u)\n        return u\n\n# ==========================================\n# Presentation Layer (e.g., Controller)\n# ==========================================\ndef register_controller(name):\n    # Wiring dependencies\n    repo = UserRepo()\n    svc = UserService(repo)\n    try:\n        svc.register(name)\n        print(\"HTTP 201 Created\")\n    except ValueError as e:\n        print(f\"HTTP 400 Bad Request: {e}\")\n\nif __name__ == \"__main__\":\n    print(\"--- Layering Demo ---\")\n    register_controller(\"Al\")\n    register_controller(\"Alice\")\n"}, {"id": "python/PythonMasteryRepo/OOPs/Testing/property_based_testing_for_objects.py", "title": "property based testing for objects", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Testing/property_based_testing_for_objects.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Testing"], "content": "\"\"\"\nTitle: Property Based Testing\nTopic: Testing\n\nTheory:\n    Instead of writing specific inputs/outputs (Example-based), \n    we define properties that should hold true for ANY valid input.\n    We typically generate random data to find edge cases.\n    \n    Real world tool: `hypothesis` library (strongly recommended).\n    Here: A manual simulation to understand the concept.\n\"\"\"\n\nimport random\n\ndef add(a, b):\n    return a + b\n\ndef properties_of_addition():\n    \"\"\"Run random inputs to verify Commutative Property.\"\"\"\n    for _ in range(100):\n        a = random.randint(-1000, 1000)\n        b = random.randint(-1000, 1000)\n        \n        # Property: a + b == b + a\n        assert add(a, b) == add(b, a), f\"Commutativity failed for {a}, {b}\"\n        \n        # Property: a + 0 == a\n        assert add(a, 0) == a, \"Identity failed\"\n\ndef run_tests():\n    print(\"Running Property Based checks...\")\n    try:\n        properties_of_addition()\n        print(\"[PASS] Addition properties hold for random inputs\")\n    except AssertionError as e:\n        print(f\"[FAIL] {e}\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Testing/serialization_pickle_json_dataclasses_asdict.py", "title": "serialization pickle json dataclasses asdict", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Testing/serialization_pickle_json_dataclasses_asdict.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Testing"], "content": "\"\"\"\nTitle: Serialization (Pickle, JSON, Dataclasses)\nTopic: Architecture/Persistence\n\nTheory:\n    Serialization: Converting objects to byte/string stream.\n    \n    1. Pickle: Python specific, supports almost anything. WARNING: Unsecure (RCE risk).\n    2. JSON: Text-based, cross-language. Safe. \n    3. Dataclasses: `asdict` helper makes JSON conversion easy.\n\"\"\"\n\nimport pickle\nimport json\nimport dataclasses\nfrom dataclasses import dataclass\n\n@dataclass\nclass Config:\n    theme: str\n    volume: int\n\ndef run_tests():\n    c = Config(\"Dark\", 80)\n    \n    # 1. Pickle\n    serialized_bytes = pickle.dumps(c)\n    print(f\"Pickle: {serialized_bytes}\")\n    c_restored = pickle.loads(serialized_bytes)\n    assert c == c_restored\n\n    # 2. JSON via asdict\n    d = dataclasses.asdict(c)\n    json_str = json.dumps(d)\n    print(f\"JSON: {json_str}\")\n    \n    # Restore\n    data = json.loads(json_str)\n    c_json = Config(**data)\n    assert c == c_json\n    \n    print(\"[PASS] Serialization\")\n\nif __name__ == \"__main__\":\n    run_tests()\n"}, {"id": "python/PythonMasteryRepo/OOPs/Testing/unit_tests_for_oop_classes.py", "title": "unit tests for oop classes", "type": "Code", "path": "python/PythonMasteryRepo/OOPs/Testing/unit_tests_for_oop_classes.py", "breadcrumbs": ["python", "PythonMasteryRepo", "OOPs", "Testing"], "content": "\"\"\"\nTitle: Unit Testing OOP Classes\nTopic: Testing\n\nTheory:\n    `unittest` is the built-in framework.\n    Key concepts:\n    - TestCase: A class representing a test scenario.\n    - `setUp`/`tearDown`: Lifecycle methods (fixtures).\n    - `assert*` methods: Validation.\n\"\"\"\n\nimport unittest\n\nclass Calculator:\n    def add(self, a, b):\n        return a + b\n    \n    def divide(self, a, b):\n        if b == 0:\n            raise ValueError(\"Zero division\")\n        return a / b\n\nclass TestCalculator(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Called before EACH test method.\"\"\"\n        self.calc = Calculator()\n\n    def tearDown(self):\n        \"\"\"Called after EACH test method.\"\"\"\n        pass\n\n    def test_add(self):\n        self.assertEqual(self.calc.add(1, 2), 3)\n        self.assertEqual(self.calc.add(-1, 1), 0)\n\n    def test_divide(self):\n        self.assertEqual(self.calc.divide(10, 2), 5)\n        # Testing Exception\n        with self.assertRaises(ValueError):\n            self.calc.divide(10, 0)\n\nif __name__ == \"__main__\":\n    unittest.main()\n"}, {"id": "python/PythonMasteryRepo/STYLE_GUIDE.md", "title": "STYLE GUIDE", "type": "Topic", "path": "python/PythonMasteryRepo/STYLE_GUIDE.md", "breadcrumbs": ["python", "PythonMasteryRepo"], "content": "# Python Study Repo - Style Guide\n\n## General Convention\n- **Naming**: `snake_case` for variables and functions. `PascalCase` for classes.\n- **Type Hints**: Use `python 3.9+` style hints (e.g., `list[int]`, `dict[str, Any]`).\n- **Docstrings**: Google style or simple one-liners for obvious functions.\n- **Line Length**: Soft limit 100 characters.\n\n## File Structure\nEvery file must start with a header comment block:\n```python\n\"\"\"\nTitle: [Concept Name]\nTopic: [Category]\n\nTheory:\n    [Explanation]\n\nComplexity:\n    Time: O(...)\n    Space: O(...)\n\"\"\"\n```\n\n## Testing Protocol\n- Include a `if __name__ == \"__main__\":` block.\n- Use `assert` statements for simple verifications.\n- Print clear success messages, e.g., `print(\"[PASS] Quick Sort tests passed\")`.\n- Avoid external testing dependencies for individual files (keep them self-contained).\n\n## Pitfalls & Variations\n- Explicitly comment on *why* a certain approach is taken if it's not the most obvious one.\n- Show \"Bad\" vs \"Good\" code comparisons if relevant.\n"}],
    stats: {"files": 299, "topics": 55, "lines_of_code": 9849, "last_updated": "2025-12-09 13:47"}
};
console.log("KB Data Loaded", window.KB_DATA.stats);
