
window.KB_DATA = {
    tree: {"Algorithms-and-Data-Structures-Python": {"01_Pure_Mathematics": {"01_Algebra": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/07_Advanced_Notes_and_Research_Directions.md"}}, "02_Linear_Algebra": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/07_Advanced_Notes_and_Research_Directions.md"}}, "03_Abstract_Algebra": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/07_Advanced_Notes_and_Research_Directions.md"}}, "04_Real_Analysis": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/07_Advanced_Notes_and_Research_Directions.md"}}, "05_Complex_Analysis": {"01_Theory.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/01_Theory.md"}, "02_Methods_and_Algorithms.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/02_Methods_and_Algorithms.md"}, "03_Tricks_and_Patterns.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/03_Tricks_and_Patterns.md"}, "04_Python_Implementations.py": {"type": "file", "ext": ".py", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/04_Python_Implementations.py"}, "05_Annotated_Examples_and_Use_Cases.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/05_Annotated_Examples_and_Use_Cases.md"}, "06_Problems_and_Solutions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/06_Problems_and_Solutions.md"}, "07_Advanced_Notes_and_Research_Directions.md": {"type": "file", "ext": ".md", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/07_Advanced_Notes_and_Research_Directions.md"}}}}, "Python_Theory": {"01_Introduction": {"01_Definition.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/01_Definition.md"}, "02_Theory.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/02_Theory.md"}, "03_Properties_and_Uses.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/03_Properties_and_Uses.md"}, "04_Syntax_and_Methods.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/04_Syntax_and_Methods.md"}, "05_Examples.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/05_Examples.md"}, "06_Common_Errors.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/06_Common_Errors.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/01_Introduction/07_Practice_Questions.md"}}, "02_Basic_Syntax": {"01_Indentation_and_Comments.md": {"type": "file", "ext": ".md", "path": "Python_Theory/02_Basic_Syntax/01_Indentation_and_Comments.md"}, "02_Variables_and_Constants.md": {"type": "file", "ext": ".md", "path": "Python_Theory/02_Basic_Syntax/02_Variables_and_Constants.md"}, "03_Input_Output.md": {"type": "file", "ext": ".md", "path": "Python_Theory/02_Basic_Syntax/03_Input_Output.md"}, "04_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/02_Basic_Syntax/04_Practice_Questions.md"}}, "03_Data_Types": {"01_Overview.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/01_Overview.md"}, "02_Numbers.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/02_Numbers.md"}, "03_Booleans.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/03_Booleans.md"}, "04_Type_Conversion.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/04_Type_Conversion.md"}, "05_NoneType.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/05_NoneType.md"}, "06_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/03_Data_Types/06_Practice_Questions.md"}}, "04_Operators_and_Expressions": {"01_Arithmetic.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/01_Arithmetic.md"}, "02_Comparison_Logical.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/02_Comparison_Logical.md"}, "03_Assignment_Bitwise.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/03_Assignment_Bitwise.md"}, "04_Membership_Identity.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/04_Membership_Identity.md"}, "05_Operator_Precedence.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/05_Operator_Precedence.md"}, "06_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/04_Operators_and_Expressions/06_Practice_Questions.md"}}, "05_Control_Flow": {"01_Conditional_Statements.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/01_Conditional_Statements.md"}, "02_Loops_For.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/02_Loops_For.md"}, "03_Loops_While.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/03_Loops_While.md"}, "04_Loop_Control_Statements.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/04_Loop_Control_Statements.md"}, "05_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/05_Control_Flow/05_Practice_Questions.md"}}, "06_Functions": {"01_Definition_Syntax.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/01_Definition_Syntax.md"}, "02_Parameters_Arguments.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/02_Parameters_Arguments.md"}, "03_Return_Statement.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/03_Return_Statement.md"}, "04_Scope_Lifetime.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/04_Scope_Lifetime.md"}, "05_Lambda_Functions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/05_Lambda_Functions.md"}, "06_Recursion.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/06_Recursion.md"}, "07_Practice_Questions.md": {"type": "file", "ext": ".md", "path": "Python_Theory/06_Functions/07_Practice_Questions.md"}}}},
    index: [{"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Theory and Foundations\n\n## 1. Algebraic Structures\n\nAlgebra in computer science is not just about solving equations; it's about understanding **structures** and **operations** that follow specific rules. These structures are the foundation of cryptography, coding theory, and advanced algorithm design (e.g., FFT).\n\n### 1.1 Groups, Rings, and Fields\n\nThe hierarchy of algebraic structures defines what operations are permissible and what properties they guarantee.\n\n#### 1.1.1 Groups\nA **Group** $(G, \\cdot)$ is a set $G$ equipped with a binary operation $\\cdot$ satisfying:\n1.  **Closure**: $\\forall a, b \\in G, a \\cdot b \\in G$.\n2.  **Associativity**: $(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$.\n3.  **Identity**: $\\exists e \\in G$ such that $a \\cdot e = e \\cdot a = a$.\n4.  **Inverse**: $\\forall a \\in G, \\exists a^{-1} \\in G$ such that $a \\cdot a^{-1} = a^{-1} \\cdot a = e$.\n\n*   **Abelian Group**: If $a \\cdot b = b \\cdot a$ (Commutativity).\n*   *Examples*: Integers under addition $(\\mathbb{Z}, +)$, Non-zero reals under multiplication $(\\mathbb{R}^*, \\cdot)$.\n\n#### 1.1.2 Rings\nA **Ring** $(R, +, \\cdot)$ has two operations:\n1.  $(R, +)$ is an Abelian Group.\n2.  $(R, \\cdot)$ is a Monoid (Closure, Associativity, Identity).\n3.  **Distributivity**: $a \\cdot (b + c) = a \\cdot b + a \\cdot c$.\n\n*   *Example*: Integers $(\\mathbb{Z}, +, \\cdot)$.\n\n#### 1.1.3 Fields\nA **Field** $(F, +, \\cdot)$ is a Ring where:\n1.  $(F^*, \\cdot)$ is an Abelian Group (Multiplicative inverses exist for all non-zero elements).\n2.  Commutativity of multiplication holds.\n\n*   *Examples*: Real numbers $\\mathbb{R}$, Complex numbers $\\mathbb{C}$, Finite fields $\\mathbb{F}_p$ (integers modulo a prime $p$).\n\n### 1.2 Modular Arithmetic (The Integers Modulo $n$)\n\nThe set $\\mathbb{Z}_n = \\{0, 1, \\dots, n-1\\}$ under addition and multiplication modulo $n$.\n*   $\\mathbb{Z}_n$ is always a Ring.\n*   $\\mathbb{Z}_n$ is a **Field** if and only if $n$ is **prime**.\n\n#### Properties:\n*   $a \\equiv b \\pmod n \\iff n \\mid (a - b)$.\n*   $(a + b) \\pmod n = ((a \\pmod n) + (b \\pmod n)) \\pmod n$.\n*   $(a \\cdot b) \\pmod n = ((a \\pmod n) \\cdot (b \\pmod n)) \\pmod n$.\n\n## 2. Homomorphisms and Isomorphisms\n\nMap functions that preserve structure. Let $(G, \\cdot)$ and $(H, *)$ be groups. A function $f: G \\to H$ is a **homomorphism** if:\n$$ f(a \\cdot b) = f(a) * f(b) $$\n\n*   **Isomorphism**: A bijective homomorphism. If exists, $G$ and $H$ are effectively the same structure.\n\n## 3. Polynomial Arithmetic\n\nPolynomials over a field $F$, denoted $F[x]$, behave similarly to integers.\n*   **Division Algorithm**: $A(x) = Q(x)B(x) + R(x)$, where $\\deg(R) < \\deg(B)$.\n*   **Irreducible Polynomials**: Analogous to prime numbers.\n*   **Galois Fields $GF(p^n)$**: Constructed using irreducible polynomials over $\\mathbb{F}_p$. Critical for AES encryption and Reed-Solomon codes.\n\n## 4. Theory Recommendation for CS\n\nUnderstanding **Finite Fields** and **Group Theory** is non-negotiable for:\n1.  **Cryptography**: RSA uses $\\mathbb{Z}_n^*$, Elliptic Curve Cryptography uses groups over finite fields.\n2.  **Hashing**: Cyclic Redundancy Checks (CRC) use polynomial rings.\n3.  **Error Correction**: Reed-Solomon codes rely on field arithmetic.\n4.  **FFT**: Fast Fourier Transform relies on roots of unity in a field (Complex or Finite).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Methods and Algorithms\n\n## 1. Modular Exponentiation\n\nCalculating $a^b \\pmod m$ efficiently is fundamental. Brute force is $O(b)$, which is exponential in the number of bits of $b$.\n**Technique**: Binary Exponentiation (Square-and-Multiply).\n**Complexity**: $O(\\log b)$.\n\n## 2. Euclidean Algorithm for GCD\n\nFinding the Greatest Common Divisor (GCD) of two numbers $a, b$.\n**Recursive Step**: $\\gcd(a, b) = \\gcd(b, a \\pmod b)$.\n**Base Case**: $\\gcd(a, 0) = a$.\n**Complexity**: $O(\\log(\\min(a, b)))$. Lam\u00e9's Theorem relates this to Fibonacci numbers.\n\n## 3. Extended Euclidean Algorithm\n\nFinds $x, y$ such that $ax + by = \\gcd(a, b)$.\nEssential for finding **Modular Inverse**. If $\\gcd(a, m) = 1$, then $ax \\equiv 1 \\pmod m$.\n**Algorithm**:\nMaintain quotients during the standard Euclidean algorithm and back-substitute.\n\n## 4. Euler's Totient Function $\\phi(n)$\n\nCount of integers $1 \\le k < n$ such that $\\gcd(k, n) = 1$.\n*   If $p$ is prime, $\\phi(p) = p - 1$.\n*   If $n = p_1^{e_1} \\dots p_k^{e_k}$, then $\\phi(n) = n \\prod (1 - 1/p_i)$.\n*   **Euler's Theorem**: $a^{\\phi(n)} \\equiv 1 \\pmod n$.\n\n## 5. Primitive Roots and Discrete Logarithm\n\nA **primitive root** modulo $n$ is an integer $g$ such that every $a$ coprime to $n$ can be written as $g^k \\pmod n$.\n*   **Discrete Logarithm Problem**: Given $g, a, n$, find $k$. This is computationally hard and forms the basis of Diffie-Hellman Key Exchange.\n*   **Algorithm**: Baby-step Giant-step ($O(\\sqrt{n})$).\n\n## 6. Fast Fourier Transform (FFT) for Polynomial Multiplication\n\nMultiplying two polynomials of degree $n$:\n*   Naive: $O(n^2)$.\n*   FFT approach: $O(n \\log n)$.\n    1.  Evaluate polynomials at $2n$ points (Roots of Unity) using FFT.\n    2.  Point-wise multiply values.\n    3.  Interpolate back to coefficients using Inverse FFT.\n\n## 7. Gaussian Elimination (Linear Algebra over Fields)\n\nSolving systems of linear equations over any field (e.g., $\\mathbb{F}_2$).\n**Algorithm**: Row reduction to Reduced Row Echelon Form (RREF).\n**Complexity**: $O(n^3)$.\n**Application**: Solving XOR equations (lights out game), Berlekamp-Massey algo.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Tricks and Patterns (Competitive Programming & Optimization)\n\n## 1. Modular Arithmetic Patterns\n\n### 1.1 Negative Modulo\nIn Python, `-5 % 3` is `1`. In C++/Java, it might be `-2`.\n**Pattern**: Always normalize: `res = (a % m + m) % m`.\n\n### 1.2 Identifying \"Cycle Finding\" Problems\nAny sequence defined by $x_{i+1} = f(x_i) \\pmod m$ will eventually cycle.\n**Trick**: Use Floyd's Cycle Finding (Tortoise and Hare) to detect period $\\lambda$ and pre-period $\\mu$.\n**App**: Pollard's Rho Algorithm for integer factorization.\n\n### 1.3 Fermat's Little Theorem for Division\nTo compute $(a / b) \\pmod p$ where $p$ is prime:\nCompute $a \\cdot b^{p-2} \\pmod p$.\n**Precondition**: $b$ is not a multiple of $p$.\n\n## 2. Combinatorics and Modulo\n\n### 2.1 Precomputing Factorials\nTo calculate $\\binom{n}{k} \\pmod p$ repeatedly:\n1.  Precompute fact $[i] = i! \\pmod p$.\n2.  Precompute invFact $[i] = (i!)^{-1} \\pmod p$ using Fermat's Little Theorem (one exp call, then build backwards: $1/((n-1)!) = (1/n!) \\cdot n$).\n\n### 2.2 Lucas Theorem\nFor huge $n, k$ and small prime $p$, $\\binom{n}{k} \\equiv \\prod \\binom{n_i}{k_i} \\pmod p$, where $n_i, k_i$ are digits in base $p$.\n\n## 3. Matrix Exponentiation (Algebra + DP)\nLinear recurrence relations (Fibonacci, Tilings) can be solved in $O(k^3 \\log n)$ using matrix exponentiation.\n**Pattern**:\nState vector $V_i$. Transition $V_{i+1} = M \\times V_i$.\nResult: $V_n = M^n \\times V_0$.\n\n## 4. GCD Properties\n*   $\\gcd(a, b, c) = \\gcd(a, \\gcd(b, c))$.\n*   $\\gcd(a, b) = \\gcd(a, b-a)$.\n*   **Optimization**: $\\gcd(a, b)$ is very fast. Don't hesitate to use it in inner loops if values decrease rapidly.\n\n## 5. Identifying Groups in Disguise\n*   **XOR Operations**: Determine a vector space over $\\mathbb{F}_2$. Use Gaussian Elimination / Linear Basis to find max XOR subset, etc.\n*   **Permutations**: Decompose into disjoint cycles. Order of permutation = LCM of cycle lengths.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "\"\"\"\nAlgebraic Algorithms Implementation.\n\nIncludes:\n1. GCD and Extended GCD (Iterative & Recursive)\n2. Modular Inverse and Exponentiation\n3. Chinese Remainder Theorem Class\n4. Matrix Multiplication and Exponentiation (for Linear Recurrences)\n5. discrete_log (Baby-step Giant-step)\n\"\"\"\n\nfrom typing import Tuple, List, Optional\nimport math\n\n# ==============================================================================\n# 1. Basic Number Theory Helpers\n# ==============================================================================\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"\n    Compute Euclidean GCD of a and b.\n    Complexity: O(log(min(a, b)))\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef extended_gcd(a: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    Extended Euclidean Algorithm.\n    Returns (g, x, y) such that ax + by = g = gcd(a, b).\n    Complexity: O(log(min(a, b)))\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        g, y, x = extended_gcd(b % a, a)\n        return g, x - (b // a) * y, y\n\ndef mod_inverse(a: int, m: int) -> int:\n    \"\"\"\n    Compute modular multiplicative inverse of a under modulo m.\n    Raises ValueError if inverse does not exist (gcd(a, m) != 1).\n    \"\"\"\n    g, x, y = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError(f\"Modular inverse does not exist for {a} modulo {m}\")\n    return (x % m + m) % m\n\ndef binary_exponentiation(base: int, exp: int, mod: int) -> int:\n    \"\"\"\n    Compute (base^exp) % mod using Square-and-Multiply.\n    Complexity: O(log exp)\n    \"\"\"\n    res = 1\n    base %= mod\n    while exp > 0:\n        if exp % 2 == 1:\n            res = (res * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return res\n\n# ==============================================================================\n# 2. Chinese Remainder Theorem\n# ==============================================================================\n\nclass ChineseRemainderSolver:\n    \"\"\"\n    Solves system of congruences:\n    x = a1 (mod n1)\n    x = a2 (mod n2)\n    ...\n    Assumes n_i correspond to pairwise coprime moduli.\n    \"\"\"\n    \n    @staticmethod\n    def solve(remainders: List[int], moduli: List[int]) -> int:\n        prod = 1\n        for n in moduli:\n            prod *= n\n            \n        result = 0\n        for a_i, n_i in zip(remainders, moduli):\n            p = prod // n_i\n            result += a_i * mod_inverse(p, n_i) * p\n        return result % prod\n\n# ==============================================================================\n# 3. Matrix Exponentiation (for Recurrences)\n# ==============================================================================\n\nclass MatrixMod:\n    \"\"\"\n    Matrix operations under modulo m.\n    \"\"\"\n    def __init__(self, mat: List[List[int]], mod: int):\n        self.mat = mat\n        self.mod = mod\n        self.rows = len(mat)\n        self.cols = len(mat[0])\n\n    @staticmethod\n    def identity(n: int, mod: int) -> 'MatrixMod':\n        mat = [[0] * n for _ in range(n)]\n        for i in range(n):\n            mat[i][i] = 1\n        return MatrixMod(mat, mod)\n\n    def __mul__(self, other: 'MatrixMod') -> 'MatrixMod':\n        if self.cols != other.rows:\n            raise ValueError(\"Matrix dimensions mismatch\")\n        \n        res = [[0] * other.cols for _ in range(self.rows)]\n        for i in range(self.rows):\n            for k in range(self.cols):\n                if self.mat[i][k] == 0: continue\n                for j in range(other.cols):\n                    res[i][j] = (res[i][j] + self.mat[i][k] * other.mat[k][j]) % self.mod\n        return MatrixMod(res, self.mod)\n\n    def pow(self, exp: int) -> 'MatrixMod':\n        res = MatrixMod.identity(self.rows, self.mod)\n        base = self\n        while exp > 0:\n            if exp % 2 == 1:\n                res = res * base\n            base = base * base\n            exp //= 2\n        return res\n\n# ==============================================================================\n# 4. Discrete Logarithm (Baby-step Giant-step)\n# ==============================================================================\n\ndef discrete_log(a: int, b: int, m: int) -> Optional[int]:\n    \"\"\"\n    Solves a^x = b (mod m) for x.\n    Time Complexity: O(sqrt(m))\n    Space Complexity: O(sqrt(m))\n    \"\"\"\n    a %= m\n    b %= m\n    n = int(math.sqrt(m)) + 1\n    \n    # Baby steps: store a^j (mod m) for 0 <= j < n\n    value_map = {}\n    curr = 1\n    for j in range(n):\n        value_map[curr] = j\n        curr = (curr * a) % m\n        \n    # Giant steps: check b * (a^(-n))^i for matches\n    # a^x = b => a^(i*n + j) = b => a^j = b * (a^-n)^i\n    \n    try:\n        factor = mod_inverse(binary_exponentiation(a, n, m), m)\n    except ValueError:\n        return None # Inverse doesn't exist implies 'a' not coprime to m\n        \n    cur_val = b\n    for i in range(n + 1):\n        if cur_val in value_map:\n            res = i * n + value_map[cur_val]\n            return res\n        cur_val = (cur_val * factor) % m\n        \n    return None\n\nif __name__ == \"__main__\":\n    # Test GCD\n    assert gcd(48, 18) == 6\n    g, x, y = extended_gcd(35, 15)\n    assert 35*x + 15*y == g\n    \n    # Test Matrix Exp (Fibonacci)\n    # [ F_n+1 ] = [ 1 1 ] [ F_n   ]\n    # [ F_n   ]   [ 1 0 ] [ F_n-1 ]\n    mod = 10**9 + 7\n    fib_matrix = MatrixMod([[1, 1], [1, 0]], mod)\n    # F_10 = 55. Matrix^9 * [1, 0] gives F_10 at index [0][0] roughly\n    res_mat = fib_matrix.pow(9)\n    # Start vector [F_1, F_0] = [1, 0]\n    # Result [F_10, F_9]\n    f_10 = (res_mat.mat[0][0] * 1 + res_mat.mat[0][1] * 0) % mod\n    assert f_10 == 55\n    \n    # Test Discrete Log: 3^x = 13 (mod 17) -> 3^4 = 81 = 13 mod 17\n    assert discrete_log(3, 13, 17) == 4\n    \n    print(\"All Algebra implementations passed.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Annotated Examples and Use Cases\n\n## 1. Cryptography: Diffie-Hellman Key Exchange\n\n**Theory**: Relies on the difficulty of the Discrete Logarithm Problem in a cyclic group.\n**Scenario**: Alice and Bob want to share a secret key over an insecure channel.\n\n**Step-by-Step**:\n1.  **Public Parameters**: A large prime $p$ and a primitive root $g$ modulo $p$. (e.g., $p=23, g=5$).\n2.  **Alice**: Chooses private secret $a = 6$.\n    *   Computes public $A = g^a \\pmod p = 5^6 \\pmod{23} = 8$.\n    *   Sends $A$ to Bob.\n3.  **Bob**: Chooses private secret $b = 15$.\n    *   Computes public $B = g^b \\pmod p = 5^{15} \\pmod{23} = 19$.\n    *   Sends $B$ to Alice.\n4.  **Shared Secret**:\n    *   Alice computes $s = B^a \\pmod p = 19^6 \\pmod{23} = 2$.\n    *   Bob computes $s = A^b \\pmod p = 8^{15} \\pmod{23} = 2$.\n\n**Why it works**:\n$(g^a)^b = g^{ab} = (g^b)^a \\pmod p$.\nAn attacker sees $p, g, A, B$. To find $s$, they need $a$ or $b$, requiring discrete log solution.\n\n## 2. RSA Encryption (Rivest-Shamir-Adleman)\n\n**Theory**: Relies on the difficulty of factoring large numbers.\n**Key Generation**:\n1.  Choose primes $p, q$. Let $n = pq$.\n2.  Compute $\\phi(n) = (p-1)(q-1)$.\n3.  Choose $e$ such that $\\gcd(e, \\phi(n)) = 1$.\n4.  Compute $d$ such that $ed \\equiv 1 \\pmod{\\phi(n)}$ using Extended Euclidean Algo.\n\n**Use Case**:\n*   Public Key: $(e, n)$.\n*   Private Key: $d$.\n*   Encrypt: $C = M^e \\pmod n$.\n*   Decrypt: $M = C^d \\pmod n$.\n\n**Visual Model**:\nThink of encryption as putting a message in a box locked by a \"multiplication\" lock ($e$). The \"division\" key ($d$) unlocks it. But finding $d$ without $p, q$ is like trying to un-mix paint.\n\n## 3. Error Detection: CRC (Cyclic Redundancy Check)\n\n**Theory**: Polynomial division over $\\mathbb{F}_2$.\n**Process**:\n1.  Message is treated as a polynomial $M(x)$.\n2.  Generator polynomial $G(x)$ is fixed (standard specification).\n3.  Multiply $M(x)$ by $x^k$ (shift) and calculate remainder $R(x) = M(x) \\cdot x^k \\pmod{G(x)}$.\n4.  Send $M(x) \\cdot x^k - R(x)$. This is divisible by $G(x)$.\n5.  Receiver checks if received polynomial is divisible by $G(x)$.\n\n## 4. Competitive Programming: N-th Fibonacci via Matrix Exponentiation\n\n**Problem**: Find $F_{10^{18}} \\pmod{10^9+7}$.\n**Naive**: $O(N)$ iteration. TLE.\n**Algebraic Approach**:\n$$ \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} F_n \\\\ F_{n-1} \\end{pmatrix} $$\nLet $M = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}$. Then $\\vec{v}_n = M^n \\vec{v}_0$.\nUse Binary Exponentiation for $M^n$. $O(\\log n)$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Problems and Solutions\n\n## Problem 1: Linear Diophantine Equation\n\n**Statement**: Given $A, B, C$, find integer solutions for $Ax + By = C$. If no solution, print \"Impossible\".\n\n**Approach**:\n1.  Calculate $g = \\gcd(A, B)$ using Euclidean Algo.\n2.  If $C \\% g \\neq 0$, no integer solution exists.\n3.  Use Extended Euclidean Algo to find $x_0, y_0$ such that $Ax_0 + By_0 = g$.\n4.  One particular solution is $x = x_0 \\cdot (C/g)$, $y = y_0 \\cdot (C/g)$.\n5.  General solution: $x' = x + k \\cdot (B/g)$, $y' = y - k \\cdot (A/g)$.\n\n**Python Solution**:\n```python\ndef solve_diophantine(a, b, c):\n    g, x0, y0 = extended_gcd(abs(a), abs(b))\n    if c % g != 0:\n        return None\n    \n    scale = c // g\n    x = x0 * scale\n    y = y0 * scale\n    \n    # Adjust signs if a or b were negative\n    if a < 0: x = -x\n    if b < 0: y = -y\n    return x, y\n```\n\n## Problem 2: Sum of Geometric Series Modulo M\n\n**Statement**: Compute $S = 1 + r + r^2 + \\dots + r^n \\pmod m$.\n\n**Approach**:\n*   Formula: $S = \\frac{r^{n+1} - 1}{r - 1}$.\n*   Requires Modular Inverse of $(r-1)$. This only exists if $\\gcd(r-1, m) = 1$.\n*   **General Case (if inverse doesn't exist)**: Use Divide and Conquer.\n    *   If $n$ is odd ($n = 2k+1$ terms? Let's say indices $0 \\dots 2k$):\n        $1 + \\dots + r^{2k+1} = (1 + r^{k+1})(1 + r + \\dots + r^k)$.\n    *   If $n$ is even, reduce to odd case or handle term manually.\n\n**Python Solution (DnC)**:\n```python\ndef geometric_sum(r, n, m):\n    # Sum r^0 + ... + r^(n-1)\n    if n == 0: return 0\n    if n % 2 == 0: # Even number of terms, e.g., r^0...r^3\n        half_n = n // 2\n        half_sum = geometric_sum(r, half_n, m)\n        multiplier = (1 + pow(r, half_n, m)) % m\n        return (half_sum * multiplier) % m\n    else: # Odd number of terms\n        return (1 + r * geometric_sum(r, n - 1, m)) % m\n```\n\n## Problem 3: Square Root Modulo P\n\n**Statement**: Find $x$ such that $x^2 \\equiv n \\pmod p$.\n\n**Approach**: Tonelli-Shanks Algorithm.\n*   If $p \\equiv 3 \\pmod 4$, then $x \\equiv \\pm n^{(p+1)/4} \\pmod p$.\n*   For general $p$, the algorithm is more involved ($O(\\log^2 p)$).\n\n**Note**: Check Euler's Criterion first: $n^{(p-1)/2} \\equiv 1 \\pmod p$. If $-1$, no solution.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/01_Algebra/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "01 Algebra"], "content": "# Algebra: Advanced Notes and Research Directions\n\n## 1. Abstract Algebra Deeper Dive\n\n### 1.1 Solvable Groups and Galois Theory\n*   **Galois Theory** connects Field Theory and Group Theory. It explains why there is no general formula for quintic equations (because $S_5$ is not a solvable group).\n*   **Application**: Advanced error-correcting codes and lattice-based cryptography often draw on these deeper properties.\n\n### 1.2 Ring of Polynomials\n*   $F[x] / P(x)$ forms a field if $P(x)$ is irreducible.\n*   **Research**: Optimizing arithmetic in $GF(2^{128})$ is crucial for GCM mode in AES.\n*   **NTRU Encryption**: Operations occur in a truncated polynomial ring $R = \\mathbb{Z}[X]/(X^N - 1)$.\n\n## 2. Homomorphic Encryption\nAllows computation on encrypted data without decrypting it ($E(a) + E(b) \\to E(a+b)$).\n*   **Partially Homomorphic**: RSA is multiplicative ($E(m_1)E(m_2) = E(m_1 m_2)$).\n*   **Fully Homomorphic Encryption (FHE)**: Based on Lattice problems (LWE - Learning With Errors).\n\n## 3. Pairing-Based Cryptography\nUses **Bilinear Maps** (Pairings) $e: G_1 \\times G_2 \\to G_T$.\n*   $e(aP, bQ) = e(P, Q)^{ab}$.\n*   Allows for **Identity-Based Encryption (IBE)** and short signatures (BLS).\n\n## 4. Primality Testing\n*   **Miller-Rabin**: Probabilistic. Standard in practice.\n*   **AKS (Agrawal-Kayal-Saxena)**: Deterministic polynomial time. Theoretical breakthrough (2002).\n\n## 5. Integer Factorization\n*   **General Number Field Sieve (GNFS)**: Fastest known classical algorithm.\n*   **Shor's Algorithm**: Quantum algorithm that factors in polynomial time. Threatens RSA.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Theory and Foundations\n\n## 1. Vector Spaces and Subspaces\n\nThe central object of linear algebra is the **Vector Space** $V$ over a field $F$.\nVectors obey addition and scalar multiplication.\n\n### 1.1 Basis and Dimension\n*   **Linear Independence**: A set $\\{v_1, \\dots, v_k\\}$ is linearly independent if $c_1 v_1 + \\dots + c_k v_k = 0 \\implies c_i = 0$.\n*   **Span**: The set of all linear combinations of vectors.\n*   **Basis**: A linearly independent set that spans $V$.\n*   **Dimension**: The size of the basis (invariant).\n\n### 1.2 Subspaces\nA subset $W \\subseteq V$ is a subspace if it is closed under addition and scalar multiplication.\n*   **Null Space (Kernel)** of Matrix $A$: $\\{x \\mid Ax = 0\\}$.\n*   **Column Space (Image)** of Matrix $A$: Span of columns of $A$.\n*   **Rank-Nullity Theorem**: $\\text{rank}(A) + \\text{nullity}(A) = n$ (number of cols).\n\n## 2. Matrices and Linear Transformations\n\nMatrices represent linear maps between vector spaces.\nIf $T: \\mathbb{R}^n \\to \\mathbb{R}^m$, there exists an $m \\times n$ matrix $A$ such that $T(x) = Ax$.\n\n### 2.1 Determinant\nA scalar value $\\det(A)$ characterizing square matrices.\n*   Geometric interpretation: Scaling factor of volume.\n*   $\\det(A) \\neq 0 \\iff A$ is invertible.\n*   Multiplicative: $\\det(AB) = \\det(A)\\det(B)$.\n\n### 2.2 Eigenvalues and Eigenvectors\nFor a square matrix $A$, if $Av = \\lambda v$ ($v \\neq 0$), then $\\lambda$ is an **Eigenvalue** and $v$ is an **Eigenvector**.\n*   **Characteristic Polynomial**: $p(\\lambda) = \\det(A - \\lambda I)$. Roots are eigenvalues.\n*   **Diagonalization**: $A = PDP^{-1}$ if $A$ has $n$ linearly independent eigenvectors.\n*   **Spectral Theorem**: Real symmetric matrices can be diagonalized by orthogonal matrices ($A = Q \\Lambda Q^T$).\n\n## 3. Norms and Inner Products\n\nMeasuring \"length\" and \"angle\".\n\n### 3.1 Norms ($L_p$)\n*   $L_1$ (Manhattan): $\\sum |x_i|$.\n*   $L_2$ (Euclidean): $\\sqrt{\\sum x_i^2}$.\n*   $L_\\infty$ (Max): $\\max |x_i|$.\n\n### 3.2 Inner Product\n$\\langle u, v \\rangle = u^T v = \\sum u_i v_i$.\n*   **Orthogonality**: $\\langle u, v \\rangle = 0$.\n*   **Cauchy-Schwarz Inequality**: $|\\langle u, v \\rangle| \\le \\|u\\| \\|v\\|$.\n\n## 4. Decompositions (The \"Factorization\" of LA)\n\nAlgorithms rely on decomposing difficult matrices into simpler ones.\n1.  **LU Decomposition**: $A = LU$ (Lower $\\times$ Upper). Used for solving linear systems.\n2.  **QR Decomposition**: $A = QR$ (Orthogonal $\\times$ Upper Triangular). Used for Least Squares.\n3.  **Cholesky Decomposition**: $A = LL^T$ (for Symmetric Positive Definite).\n4.  **SVD (Singular Value Decomposition)**: The \"King\" of decompositions. $A = U \\Sigma V^T$.\n    *   Exists for **any** matrix (even rectangular).\n    *   Applications: Compression, PCA, Pseudo-inverse, Recommender Systems.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Methods and Algorithms\n\n## 1. Gaussian Elimination\n\n**Purpose**: Solve $Ax = b$, find $\\det(A)$, find $A^{-1}$, find Rank.\n**Method**: Transform augmented matrix $[A|b]$ to Row Echelon Form (REF) and then Reduced REF (RREF).\n**Operations**:\n1.  Swap rows.\n2.  Multiply row by non-zero scalar.\n3.  Add multiple of one row to another.\n**Complexity**: $O(N^3)$.\n\n## 2. Matrix Multiplication Optimization\n\nNaive is $O(N^3)$.\n*   **Strassen's Algorithm**: $O(N^{\\log_2 7}) \\approx O(N^{2.81})$. Uses recursive block multiplication tricks.\n*   **Coppersmith-Winograd**: $O(N^{2.376})$ (Theoretical, huge constant).\n\n## 3. Computing Matrix Powers $A^k$\n\n**Method**: Binary Exponentiation (Square and Multiply).\n**Complexity**: $O(N^3 \\log k)$.\n**Application**: Counting paths of length $k$ in a graph, Linear Recurrences.\n\n## 4. Singular Value Decomposition (SVD) Algorithm\n\n**Goal**: Find $U, \\Sigma, V^T$ such that $A = U \\Sigma V^T$.\n**Iterative Methods**:\n*   **Golub-Kahan-Reinsch**: Reduces $A$ to bidiagonal form, then uses QR-like iterations.\n*   **Power Iteration**: Finds dominant eigenvalue/vector. Can be adapted for SVD.\n\n## 5. Solving Linear Recurrences (The General Method)\n\nGiven $f_n = c_1 f_{n-1} + \\dots + c_k f_{n-k}$.\n1.  Construct Transformation Matrix $T$ size $k \\times k$.\n$$\nT = \\begin{bmatrix}\nc_1 & c_2 & \\dots & c_{k-1} & c_k \\\\\n1 & 0 & \\dots & 0 & 0 \\\\\n0 & 1 & \\dots & 0 & 0 \\\\\n\\vdots & & \\ddots & & \\vdots \\\\\n0 & 0 & \\dots & 1 & 0\n\\end{bmatrix}\n$$\n2.  State vector $V_{n-1} = [f_{n-1}, \\dots, f_{n-k}]^T$.\n3.  $V_{n+m} = T^{m+1} V_{n-1}$.\n\n## 6. Least Squares Regression\n\nGiven overdetermined system $Ax = b$ (more equations than unknowns).\nMinimize $\\|Ax - b\\|^2$.\n**Analytical Solution**: Normal Equation $A^T A x = A^T b$.\n**computional Note**: Solving via Normal Equation is unstable if condition number is high. QR decomposition or SVD is preferred ($x = A^+ b$).\n\n## 7. Linear Basis (Competitive Programming)\n\n**Problem**: Given a set of integers, find max XOR subset, check if $X$ can be formed by XORing subset.\n**Algorithm**: Gaussian Elimination on bits ($GF(2)$).\nMaintain a basis set $\\{b_1, \\dots, b_d\\}$ where each basis vector improves the \"highest bit\".\n**Complexity**: $O(N \\log (\\max val))$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Tricks and Patterns\n\n## 1. Matrix Exponentiation Tricks\n\n### 1.1 Augmenting the State\nSometimes the recurrence depends on $n$ or a sum.\n*   $f_n = f_{n-1} + f_{n-2} + n$.\n*   State: $[f_n, f_{n-1}, n, 1]^T$.\n*   Transition incorporates the $+1$ for $n$ and the $+n$ for $f_n$.\n\n### 1.2 Graph Adjacency Matrix\n*   Let $A$ be the adjacency matrix of an unweighted graph.\n*   $(A^k)_{ij}$ = Number of walks of length exactly $k$ from $i$ to $j$.\n*   **Trick**: If nodes are small ($N \\le 50$) and $k$ is huge, use Matrix Exp.\n\n## 2. XOR Basis (The \"Linear Algebra of Bits\")\n\nTo check if a number $X$ is representable by XOR sum of array $A$:\n1.  Insert all $a \\in A$ into a linear basis.\n2.  Try to reduce $X$ using the basis.\n3.  If $X$ reduces to 0, it is representable.\n4.  **Max XOR**: Greedily XOR with basis elements starting from most significant bit.\n\n## 3. Coordinate Compression\n\nIn geometry or 2D grid problems with huge coordinates but few points:\n*   Map unique sorted $x$-coordinates to $0, 1, 2, \\dots$.\n*   Preserves relative order.\n*   Transforms $10^9$ grid to $O(N)$ grid.\n\n## 4. Vandermonde Matrix Properties\n\nDeterminant of Vandermonde matrix (geometric progression rows) has a closed form: $\\prod_{1 \\le i < j \\le n} (x_j - x_i)$.\n*   Useful in interpolation and secret sharing problems.\n\n## 5. Cayley-Hamilton Theorem\n\nEvery square matrix satisfies its own characteristic equation: $p(A) = 0$.\n*   **Trick**: Enables computing $A^{-1}$ as a polynomial in $A$ of degree $n-1$.\n*   $A^n = c_{n-1}A^{n-1} + \\dots + c_0 I$. Can reduce high powers of $A$ without full multiplication if we only need specific projections.\n\n## 6. Rotation Matrices\n\nTo rotate a point $(x, y)$ by $\\theta$ counter-clockwise:\n$$\n\\begin{bmatrix} x' \\\\ y' \\end{bmatrix} =\n\\begin{bmatrix} \\cos \\theta & -\\sin \\theta \\\\ \\sin \\theta & \\cos \\theta \\end{bmatrix}\n\\begin{bmatrix} x \\\\ y \\end{bmatrix}\n$$\n**Trick**: For $90^\\circ$, swap and negate: $(x, y) \\to (-y, x)$.\n\n## 7. Fast Hadamard Transform (FHT)\n\nLike FFT but for XOR convolution.\n$(A * B)[k] = \\sum_{i \\oplus j = k} A[i] B[j]$.\nUses the Hadamard matrix structure. Complexity $O(N \\log N)$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "\"\"\"\nLinear Algebra Algorithms Implementation.\n\nIncludes:\n1. Matrix Class (Basic Ops, Transpose, Determinanat via Gaussian)\n2. Gaussian Elimination (Row Reduction)\n3. Linear Basis (XOR Basis)\n4. Fast Walsh-Hadamard Transform (FWHT) for XOR Convolution\n\"\"\"\n\nfrom typing import List, Optional\n\n# ==============================================================================\n# 1. Matrix Operations (Basic)\n# ==============================================================================\n\nclass Matrix:\n    def __init__(self, data: List[List[float]]):\n        self.data = data\n        self.rows = len(data)\n        self.cols = len(data[0])\n\n    def __repr__(self):\n        return \"\\n\".join([\" \".join(f\"{x:.2f}\" for x in row) for row in self.data])\n\n    def multiply(self, other: 'Matrix') -> 'Matrix':\n        if self.cols != other.rows:\n            raise ValueError(\"Dimensions invalid for multiplication\")\n        res = [[0.0] * other.cols for _ in range(self.rows)]\n        for i in range(self.rows):\n            for k in range(self.cols):\n                if self.data[i][k] == 0: continue\n                for j in range(other.cols):\n                    res[i][j] += self.data[i][k] * other.data[k][j]\n        return Matrix(res)\n\n    def determinant(self) -> float:\n        \"\"\"\n        Computes determinant using Gaussian elimination.\n        Complexity: O(N^3)\n        \"\"\"\n        if self.rows != self.cols:\n            raise ValueError(\"Determinant only for square matrices\")\n        \n        n = self.rows\n        mat = [row[:] for row in self.data] # Copy\n        det = 1.0\n        \n        for i in range(n):\n            # Pivot\n            pivot = i\n            while pivot < n and abs(mat[pivot][i]) < 1e-9:\n                pivot += 1\n            if pivot == n:\n                return 0.0 # Singular\n            \n            # Swap\n            if pivot != i:\n                mat[pivot], mat[i] = mat[i], mat[pivot]\n                det *= -1\n                \n            det *= mat[i][i]\n            \n            # Eliminate\n            for j in range(i + 1, n):\n                factor = mat[j][i] / mat[i][i]\n                for k in range(i, n): # Start from i optimization\n                    mat[j][k] -= factor * mat[i][k]\n                    \n        return det\n\n    @staticmethod\n    def identity(n: int) -> 'Matrix':\n        data = [[0.0]*n for _ in range(n)]\n        for i in range(n): data[i][i] = 1.0\n        return Matrix(data)\n\n# ==============================================================================\n# 2. Linear Basis (XOR Basis)\n# ==============================================================================\n\nclass LinearBasis:\n    \"\"\"\n    Manages a basis for XOR vector space.\n    Operations: O(log(MaxVal)) = O(Bits).\n    \"\"\"\n    def __init__(self):\n        self.basis: List[int] = []\n        \n    def insert(self, mask: int):\n        for b in self.basis:\n            mask = min(mask, mask ^ b)\n        if mask > 0:\n            self.basis.append(mask)\n            self.basis.sort(reverse=True) # Keep basis sorted for greedy max\n            \n    def can_form(self, mask: int) -> bool:\n        for b in self.basis:\n            mask = min(mask, mask ^ b)\n        return mask == 0\n        \n    def max_xor(self) -> int:\n        res = 0\n        for b in self.basis:\n            res = max(res, res ^ b)\n        return res\n\n# ==============================================================================\n# 3. Fast Walsh-Hadamard Transform (FWHT)\n# ==============================================================================\n\ndef fwht(a: List[int], inverse: bool = False) -> List[int]:\n    \"\"\"\n    Computes XOR convolution (or transform).\n    Len(a) must be power of 2.\n    \"\"\"\n    n = len(a)\n    if (n & (n - 1)) != 0:\n        raise ValueError(\"Length must be power of 2\")\n        \n    a = list(a) # Copy\n    length = 1\n    while length < n:\n        for i in range(0, n, 2 * length):\n            for j in range(length):\n                x = a[i + j]\n                y = a[i + j + length]\n                if not inverse:\n                    a[i + j] = x + y\n                    a[i + j + length] = x - y\n                else:\n                    a[i + j] = (x + y) // 2\n                    a[i + j + length] = (x - y) // 2\n        length *= 2\n    return a\n\ndef xor_convolution(a: List[int], b: List[int]) -> List[int]:\n    \"\"\"\n    Computes C[k] = sum(A[i] * B[j]) for all i ^ j = k.\n    \"\"\"\n    # Pad to power of 2\n    n = 1\n    while n < max(len(a), len(b)): n *= 2\n    \n    a += [0] * (n - len(a))\n    b += [0] * (n - len(b))\n    \n    fa = fwht(a)\n    fb = fwht(b)\n    \n    # Point-wise multiply\n    fc = [fa[i] * fb[i] for i in range(n)]\n    \n    return fwht(fc, inverse=True)\n\n# ==============================================================================\n# 4. Main Test\n# ==============================================================================\n\nif __name__ == \"__main__\":\n    # Test Matrix\n    m1 = Matrix([[1, 2], [3, 4]])\n    assert abs(m1.determinant() - (-2.0)) < 1e-9\n    \n    # Test Linear Basis\n    lb = LinearBasis()\n    lb.insert(3) # 011\n    lb.insert(5) # 101\n    # Can form 3^5 = 6 (110)? Yes.\n    assert lb.can_form(6) is True\n    assert lb.max_xor() == 7 # 6^? no 3 is 011, 5 is 101. Basis [5, 3^5=6]. 5^6 = 3. Max is 5(101) ^ 6(110)? No. 5 is highest bit. 5^011(3)=6. 5^2(from 3^5? no).\n    # Correct Basis behavior:\n    # Ins 3: [3]\n    # Ins 5: 5^3 = 6. [6, 3] (Sorted).\n    # Max: 0^6 = 6. 6^3 = 5. Wait.\n    # 6 (110), 3 (011). \n    # Max XOR: Try to include 6. Res=6. Try include 3. 6^3 = 5 (101). 6 > 5. Keep 6. Wait 6^3 is 110^011=101=5.\n    # Actually, basis logic usually keeps 'high bit' unique.\n    # [5 (101), 3 (011)] -> 5 is basis for bit 2. 3 is basis for bit 1? no. 3^5 = 6(110).\n    # Correct reduction:\n    # ins 3. basis: [3]\n    # ins 5. min(5, 5^3=6). 5 is smaller? Insert 3, then 5.\n    # Standard basis: {101, 011}. Linear combinations: 101, 011, 110. Max is 110 (6).\n    # Code implementation check:\n    # insert 3: basis=[3]\n    # insert 5: 5^3 = 6. 5>6 False. 5 inserted? No logic: mask = min(mask, mask^b). \n    # 5^3 = 6. min(5, 6) = 5. 5 is > 0. basis=[5, 3]?\n    # Let's trace carefully: insert(mask). mask iterates basis.\n    # mask=5. b=3. 5^3=6. min(5, 6)=5. mask stays 5.\n    # append 5. sort reverse. basis=[5, 3].\n    # max_xor: res=0. res^5=5. res^3=6. Final 6. Correct.\n    assert lb.max_xor() == 6\n\n    # Test FWHT\n    # A = [1, 0], B = [1, 1] (Polynomials over methods)\n    # i, j indices. 0,0->0. 0,1->1.\n    # Result should have 1 at index 0, 1 at index 1.\n    poly_a = [1, 0] # Represents {0}\n    poly_b = [1, 1] # Represents {0, 1}\n    # {0}^0 = 0. {0}^1 = 1.\n    res = xor_convolution(poly_a, poly_b)\n    # Expect [1, 1]\n    assert res[0] == 1 and res[1] == 1\n    \n    print(\"All Linear Algebra Implementations Validated.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Annotated Examples and Use Cases\n\n## 1. PageRank Algorithm (Google)\n\n**Theory**: Finding the \"importance\" of nodes in a graph based on incoming links. Modeling the web as a Markov Chain.\n**Linear Algebra Core**: Finding the **Principal Eigenvector** of the transition matrix.\n$$ v_{t+1} = M v_t $$\nwhere $M$ is the stochastic matrix (columns sum to 1).\n**Stationary Distribution**: $v = Mv$. This means $v$ is an eigenvector with eigenvalue $\\lambda = 1$.\n\n**Process**:\n1.  Construct adjacency matrix $A$.\n2.  Normalize columns to get $M$.\n3.  Add \"damping factor\" (teleportation) to ensure connectivity and existence of limit.\n4.  Use **Power Iteration**: Repeatedly multiply $v$ by $M$ until convergence. The magnitude of components of $v$ represents Rank.\n\n## 2. Dimensionality Reduction (PCA)\n\n**Scenario**: You have a dataset with 100 features, but many are correlated. You want to visualize it in 2D.\n**Technique**: Principal Component Analysis via **SVD**.\n1.  Center data (subtract mean). Form matrix $X$ ($n \\text{ samples} \\times d \\text{ features}$).\n2.  Compute covariance matrix $C = \\frac{1}{n} X^T X$.\n3.  Compute Eigenvectors of $C$ (or SVD of $X$).\n4.  The eigenvectors corresponding to largest eigenvalues are \"Principal Components\" (directions of max variance).\n5.  Project $X$ onto these top 2 vectors.\n\n## 3. Game Theory: Lights Out\n\n**Problem**: A grid of lights. Pressing one toggles it and neighbors. Turn all off.\n**Model**: System of linear equations over $\\mathbb{F}_2$ (GF(2)).\n$$ Ax = b $$\nwhere $x$ is vector of button presses (1 or 0), $b$ is current state, $A$ describes effect of buttons.\n**Solution**: Gaussian Elimination over GF(2).\n\n## 4. Recommender Systems (Matrix Factorization)\n\n**Scenario**: Users rating movies. Matrix $R$ (Users $\\times$ Movies) is sparse.\n**Goal**: Fill in blanks.\n**Model**: Assume $R \\approx U \\times V^T$.\n$U$: User preference vectors (latent factors).\n$V$: Movie feature vectors.\n**Solver**: Alternating Least Squares (ALS) or SVD-based approximation.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Problems and Solutions\n\n## Problem 1: Number of Spanning Trees (Matrix Tree Theorem)\n\n**Statement**: Given a connected graph $G$, calculate the number of distinct spanning trees.\n\n**Theory (Kirchhoff's Theorem)**:\nThe number of spanning trees is equal to any cofactor of the **Laplacian Matrix** $L$.\n$L = D - A$, where $D$ is Degree Matrix (diagonal), $A$ is Adjacency Matrix.\n\n**Approach**:\n1.  Construct $L$.\n2.  Remove last row and last column to get $L'$.\n3.  Compute $\\det(L')$.\n\n**Python Solution**:\n```python\ndef count_spanning_trees(adj_matrix):\n    n = len(adj_matrix)\n    # 1. Build Laplacian\n    L = [[0.0] * n for _ in range(n)]\n    for i in range(n):\n        degree = sum(adj_matrix[i])\n        for j in range(n):\n            if i == j:\n                L[i][j] = degree\n            elif adj_matrix[i][j]:\n                L[i][j] = -1\n    \n    # 2. Minor (Remove last row/col)\n    minor = [row[:-1] for row in L[:-1]]\n    \n    # 3. Determinant (using our Matrix class logic)\n    mat = Matrix(minor)\n    return round(mat.determinant()) \n```\n\n## Problem 2: Knight's Moves on Infinite Board\n\n**Statement**: Can a Knight reach $(x, y)$ from $(0, 0)$? In exactly $K$ steps?\n**Linear Algebra Approach**:\nThis is a path counting problem on a graph.\nFor small board: Adjacency Matrix power $A^K$.\nFor infinite board: Not strictly linear algebra matrices, but can be modeled as linear combination of move vectors.\n$(x, y) = a(1, 2) + b(2, 1) + \\dots$\nMore of a Diophantine / BFS problem, but $A^k$ applies for finite bounded boards (e.g., \"Moves on Keypad\").\n\n## Problem 3: Recurrence with \"Sum of Previous Terms\"\n\n**Statement**: $a_n = 2a_{n-1} + a_{n-2} + n^2$. Find $a_N \\pmod M$.\n**State Vector**: Need terms to generate next $n^2$ (which is $(n+1)^2 = n^2 + 2n + 1$).\n$V_n = [a_n, a_{n-1}, n^2, n, 1]^T$.\n**Transition**:\n$a_{n+1} = 2a_n + a_{n-1} + (n+1)^2 = 2a_n + a_{n-1} + n^2 + 2n + 1$.\n$(n+1)^2 = n^2 + 2n + 1$.\n$(n+1) = n + 1$.\n$1 = 1$.\n\nMatrix M:\n```\n[2, 1, 1, 2, 1]\n[1, 0, 0, 0, 0]\n[0, 0, 1, 2, 1]\n[0, 0, 0, 1, 1]\n[0, 0, 0, 0, 1]\n```\nCompute $M^N \\times V_0$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/02_Linear_Algebra/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "02 Linear Algebra"], "content": "# Linear Algebra: Advanced Notes and Research Directions\n\n## 1. Randomized Linear Algebra\n\nStandard matrix algorithms ($O(N^3)$) are too slow for Big Data ($N=10^6$).\n**Research methods**:\n*   **Sketching**: Project vectors into lower dimensions using random matrices (Johnson-Lindenstrauss Lemma) while preserving norms.\n*   **Randomized SVD**: Identify range of $A$ using random vectors, then SVD on smaller subspace. Very fast approximate PCA.\n\n## 2. Sparse Linear Algebra\n\nAlgorithms optimized for matrices where most entries are zero.\n*   **Storage**: CSR (Compressed Sparse Row), CSC.\n*   **Solvers**: Krylov Subspace Methods (Conjugate Gradient, GMRES). These solve $Ax=b$ by iteratively building a basis for $\\{b, Ab, A^2b \\dots\\}$. $O(k \\cdot E)$ where $E$ is edges, much faster than $N^3$.\n\n## 3. Tensor Algebra (Multilinear Algebra)\n\nGeneralizing matrices (2D) to Tensors (nD).\n*   **Tensor Decomposition**: CP (Canonical Polyadic), Tucker.\n*   **Applications**: Deep Learning (PyTorch/TensorFlow are tensor algebra libraries), Chemometrics.\n\n## 4. Quantum Linear Algebra\n\nHHL Algorithm (Harrow-Hassidim-Lloyd).\n*   Solves $Ax=b$ in $O(\\log N)$ on a quantum computer (under specific conditions).\n*   Offers exponential speedup over classical algorithms.\n\n## 5. Spectral Graph Theory\n\nStudying graphs via eigenvalues of their matrices (Adjacency, Laplacian).\n*   **Cheeger's Inequality**: Relates \"conductance\" (bottlenecks) of a graph to the second smallest eigenvalue of Laplacian ($\\lambda_2$).\n*   **Graph Isomorphism**: Using spectrum to check isomorphism (imperfect but useful).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Group Actions and Combinatorics\n\n## 1. Group Actions\n\nWhile basic algebra checks satisfying properties (Is this a Group?), **Group Actions** study how groups **act** on sets. This is the bridge to Combinatorics and Geometry.\n\n### 1.1 Definition\nLeft action of group $G$ on set $X$ is a function $G \\times X \\to X$, denoted $g \\cdot x$, satisfying:\n1.  **Identity**: $e \\cdot x = x$.\n2.  **Compatibility**: $(gh) \\cdot x = g \\cdot (h \\cdot x)$.\n\n### 1.2 Orbits and Stabilizers\n*   **Orbit** of $x$: $Orb(x) = \\{g \\cdot x \\mid g \\in G\\}$. The set of points $x$ can reach.\n*   **Stabilizer** of $x$: $Stab(x) = \\{g \\in G \\mid g \\cdot x = x\\}$. The set of group elements that fix $x$.\n*   **Orbit-Stabilizer Theorem**: $|G| = |Orb(x)| \\cdot |Stab(x)|$.\n\n## 2. Burnside's Lemma (The \"Counting Lemma\")\n\nUsed to count distinct objects under symmetry (e.g., how many distinct necklaces with 3 beads exist?).\nThe number of distinct orbits $|X/G|$ is the average number of elements fixed by each $g \\in G$.\n\n$$ |X/G| = \\frac{1}{|G|} \\sum_{g \\in G} |fix(g)| $$\nwhere $fix(g) = \\{x \\in X \\mid g \\cdot x = x\\}$.\n\n## 3. P\u00f3lya Enumeration Theorem (PET)\n\nA generalization of Burnside's Lemma that counts distinct colorings by \"weight\" (e.g., 2 Red, 1 Blue).\n*   **Cycle Index Polynomial** $Z(G)$: A polynomial representing the cycle structure of $G$'s permutations.\n    $$ Z(G) = \\frac{1}{|G|} \\sum_{g \\in G} t_1^{j_1(g)} t_2^{j_2(g)} \\dots $$\n    where $j_k(g)$ is the number of cycles of length $k$ in permutation $g$.\n*   **Theorem**: Determine the number of patterns by substituting color weights into $Z(G)$.\n\n## 4. Permutation Groups\n\n*   **Symmetric Group $S_n$**: All $n!$ permutations of $n$ elements.\n*   **Alternating Group $A_n$**: Only even permutations.\n*   **Cayley's Theorem**: Every group is isomorphic to a subgroup of a symmetric group. \n\n## 5. Sylow Theorems (Structure of Finite Groups)\n\nIf $|G| = p^k m$ ($p$ prime not dividing $m$), then:\n1.  **Existence**: $G$ has a subgroup of size $p^k$ (Sylow $p$-subgroup).\n2.  **Conjugacy**: All Sylow $p$-subgroups are conjugate.\n3.  **Counting**: Number of Sylow $p$-subgroups $n_p$ satisfies $n_p \\equiv 1 \\pmod p$ and $n_p \\mid m$.\n\n**Application**: Used to prove a group is not simple (normal subgroups exist).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Methods and Algorithms\n\n## 1. Decomposing Permutations into Disjoint Cycles\n\n**Goal**: Convert a permutation array `p` where `p[i]` is image of `i` into cycle notation $(a, b, c)(d, e)$.\n**Method**:\n1.  Mark all elements as unvisited.\n2.  For each unvisited $i$, follow $i \\to p[i] \\to p[p[i]] \\dots$ until back to $i$.\n3.  This forms one cycle. Mark all in cycle as visited.\n**Complexity**: $O(N)$.\n\n## 2. Applying Burnside's Lemma\n\n**Goal**: Count distinct colorings of an object under symmetries.\n**Algorithm**:\n1.  Identify the group $G$ of symmetries (Rotation, Reflection).\n2.  For each $g \\in G$:\n    a. Decompose $g$ into $k$ disjoint cycles.\n    b. If we have $C$ colors, the number of fixed points $|fix(g)| = C^k$ (Each cycle must be monochromatic).\n3.  Sum results and divide by $|G|$.\n\n## 3. Generating Symmetry Groups\n\n*   **Cyclic Group $C_n$** (Rotations of regular $n$-gon): Generated by rotation $\\sigma$. Elements $\\{e, \\sigma, \\dots, \\sigma^{n-1}\\}$.\n*   **Dihedral Group $D_n$** (Rotations + Reflections): Size $2n$.\n    *   Rotations: $n$ elements.\n    *   Reflections: $n$ elements.\n        *   If $n$ odd: Axis through vertex and midpoint of opposite side.\n        *   If $n$ even: Half through vertices, half through midpoints of sides.\n\n## 4. Baby-step Giant-step for Discrete Log (Generalized)\n\nWorks for any finite cyclic group (not just modulo $p$).\nRequires group operations $a \\cdot b$ and inverse $a^{-1}$.\n\n## 5. Schreier-Sims Algorithm (Computational Group Theory)\n\n**Goal**: Determine the order of a permutation group generated by a set $S$.\n**Concept**: Uses Stabilizer Chain $G = G_0 \\ge G_1 \\ge \\dots \\ge G_k = \\{e\\}$.\n**Complexity**: Polynomial in $n$ (degree of permutation), unlike brute force $n!$.\n*   (Too advanced to implement fully here, but good to know existence).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Tricks and Patterns\n\n## 1. GCD of Polynomials\nJust like integers, polynomials have GCD.\n**Pattern**: Use `numpy.polynomial` or implement standard Euclidean algo for polynomials over a field. Use to find common roots.\n\n## 2. Power of Permutation\nTo compute $P^k$ for large $k$:\n1.  Decompose $P$ into cycles.\n2.  For a cycle of length $L$, the effect of $P^k$ is shifting elements by $k \\pmod L$.\n3.  Reconstruct the permutation.\n**Complexity**: $O(N)$. Much faster than matrix exponentiation or composition ($O(N \\log k)$ or $O(N)$ with composition overhead).\n\n## 3. Order of Permutation\nThe smallest $k$ such that $P^k = I$.\n**Trick**: $\\text{Order}(P) = \\text{LCM}(\\text{length of cycle}_1, \\dots, \\text{length of cycle}_m)$.\n**CP Application**: \"What is the maximum order of a permutation of size $N$?\" -> Landau's Function $g(n)$. Maximum LCM of partition of $n$.\n\n## 4. Fixed Points Calculation (Burnside Shortcut)\nFor rotational symmetry of $N$ items with $C$ colors:\n*   Rotation by $k$ units ($0 \\le k < N$).\n*   Number of cycles is $\\gcd(k, N)$.\n*   Contribution: $C^{\\gcd(k, N)}$.\n*   **Total**: $\\frac{1}{N} \\sum_{k=1}^N C^{\\gcd(k, N)}$.\n\n## 5. Conjugacy Classes\nIn $S_n$, two permutations are conjugate $\\iff$ they have the same cycle type (same number of cycles of each length).\n**Trick**: Iterate partitions of $N$ to sum over $S_n$ quickly using Polya, instead of iterating $n!$ elements.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "\"\"\"\nAbstract Algebra Algorithms Implementation.\n\nIncludes:\n1. Permutation Class (Composition, Power, Cycles).\n2. Burnside's Lemma Solver (for Rotational/Dihedral symmetries).\n3. Landau's Function (Max Order of Permutation).\n\"\"\"\n\nfrom typing import List, Tuple\nfrom math import gcd\n\n# ==============================================================================\n# 1. Permutation Operations\n# ==============================================================================\n\nclass Permutation:\n    def __init__(self, mapping: List[int]):\n        # mapping[i] is the image of i. Assumes 0-indexed elements 0..N-1\n        self.mapping = mapping\n        self.n = len(mapping)\n        \n    def __repr__(self):\n        return f\"Perm({self.mapping})\"\n\n    def __mul__(self, other: 'Permutation') -> 'Permutation':\n        # Composition: (f * g)(x) = f(g(x))\n        if self.n != other.n:\n            raise ValueError(\"Size mismatch\")\n        new_map = [self.mapping[other.mapping[i]] for i in range(self.n)]\n        return Permutation(new_map)\n\n    def get_cycles(self) -> List[List[int]]:\n        visited = [False] * self.n\n        cycles = []\n        for i in range(self.n):\n            if not visited[i]:\n                cycle = []\n                curr = i\n                while not visited[curr]:\n                    visited[curr] = True\n                    cycle.append(curr)\n                    curr = self.mapping[curr]\n                cycles.append(cycle)\n        return cycles\n\n    def power(self, k: int) -> 'Permutation':\n        # Apply permutation k times using cycle decomposition\n        # O(N) instead of O(N log K) composition\n        new_map = [0] * self.n\n        cycles = self.get_cycles()\n        \n        for cycle in cycles:\n            l = len(cycle)\n            shift = k % l\n            for idx, val in enumerate(cycle):\n                # The element at 'val' moves to cycle[(idx + shift) % l]\n                # Wait: mapping[i] is where i goes.\n                # If i is cycle[idx], it goes to cycle[idx+1].\n                # After k steps, it lands at cycle[(idx + k) % l].\n                target = cycle[(idx + shift) % l]\n                new_map[val] = target # val goes to target\n                \n        return Permutation(new_map)\n\n# ==============================================================================\n# 2. Burnside's Lemma / Polya Helpers\n# ==============================================================================\n\ndef count_necklace_embeddings(n: int, k: int) -> int:\n    \"\"\"\n    Count distinct necklaces with n beads and k colors under Rotation.\n    Formula: (1/n) * sum(k^gcd(i, n) for i in 1..n)\n    \"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        cycles = gcd(i, n)\n        total += k ** cycles\n    return total // n\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\ndef landau_function_dp(n: int) -> int:\n    \"\"\"\n    Computes g(n): Maximum order of an element of S_n.\n    Equivalent to Max LCM of partitions of n.\n    DP State: dp[i] = sets of possible LCMs summing to i? Too big.\n    Optimization: The partition consists of prime powers.\n    dp[j] = max LCM using sum j.\n    \"\"\"\n    # Primes up to n\n    primes = []\n    is_prime = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if is_prime[p]:\n            primes.append(p)\n            for i in range(p*p, n+1, p): is_prime[i] = False\n            \n    # dp[w] = max_lcm with weight w\n    dp = [1.0] * (n + 1) # Use float to avoid huge int overhead during intermediate steps? No, Python ints are fine.\n    dp_int = [1] * (n + 1)\n    \n    # Knapsack-like approach\n    for p in primes:\n        for w in range(n, -1, -1):\n            pp = p\n            while pp <= w:\n                dp_int[w] = max(dp_int[w], dp_int[w - pp] * pp)\n                pp *= p\n                \n    return max(dp_int)\n\nif __name__ == \"__main__\":\n    # Test Permutation\n    p = Permutation([1, 2, 0, 4, 3]) \n    # Cycles: (0 1 2), (3 4)\n    # Order: LCM(3, 2) = 6. P^6 should be identity.\n    p6 = p.power(6)\n    assert p6.mapping == [0, 1, 2, 3, 4]\n    \n    # Test Necklace\n    # 3 beads, 2 colors (Red, Blue)\n    # Patterns: RRR, BBB, RRB(x3->1), BBR(x3->1). Total 4.\n    # Formula: 1/3 * (2^gcd(1,3) + 2^gcd(2,3) + 2^gcd(3,3)) = 1/3 * (2^1 + 2^1 + 2^3) = 1/3 * (2+2+8) = 12/3 = 4.\n    assert count_necklace_embeddings(3, 2) == 4\n    \n    # Test Landau\n    # g(4) -> partition 4 into max lcm. 4->4, 3+1->3, 2+2->2, 2+1+1->2. Max is 4.\n    # g(5) -> 2,3 -> lcm 6.\n    assert landau_function_dp(5) == 6\n    \n    print(\"Abstract Algebra Implementations Verified.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Annotated Examples and Use Cases\n\n## 1. Coloring the Cube (Burnside's Lemma)\n\n**Problem**: How many ways to color the faces of a cube with 3 colors (R, G, B) under rotation?\n\n**Analysis of Symmetry Group $G$ (Rotations of Cube)**: $|G| = 24$.\n1.  **Identity** (1 element): Fixes 6 faces. Contribution $1 \\cdot 3^6$.\n2.  **Axis through opposite face centers** (3 axes $\\times$ 3 rotations - identity):\n    *   $90^\\circ$ (6 elements): Fixes 2 faces (axis), others cycle 4. Cycles=3. Contrib $6 \\cdot 3^3$.\n    *   $180^\\circ$ (3 elements): Fixes 2 faces, others cycle 2. Cycles=4. Contrib $3 \\cdot 3^4$.\n3.  **Axis through opposite edges** (6 axes $\\times$ 1 rotation $180^\\circ$):\n    *   (6 elements): Fixes 0 faces. 3 cycles of 2. Contrib $6 \\cdot 3^3$.\n4.  **Axis through opposite vertices** (4 axes $\\times$ 2 rotations):\n    *   (8 elements): Fixes 0 faces. 2 cycles of 3. Contrib $8 \\cdot 3^2$.\n\n**Calculation**:\nTotal = $\\frac{1}{24} (3^6 + 6 \\cdot 3^3 + 3 \\cdot 3^4 + 6 \\cdot 3^3 + 8 \\cdot 3^2)$\n$= \\frac{1}{24} (729 + 162 + 243 + 162 + 72) = \\frac{1368}{24} = 57$.\n\n**Answer**: 57 distinct cubes.\n\n## 2. 15-Puzzle Solvability (Group Theory Invariant)\n\n**Problem**: Given a scrambled 15-puzzle, is it solvable?\n**Invariant**: The **Parity** of the permutation of tiles plus the parity of the taxicab distance of the empty square from the bottom-right corner must be even.\n**Group Theory**:\n*   Swapping a tile with empty space is a transposition (odd permutation).\n*   One move changes parity of permutation AND parity of distance (row+col).\n*   Therefore, (Permutation Parity + Distance Parity) is **invariant** (mod 2).\n\n## 3. Rubik's Cube Groups\n\n**Theory**: The states of a Rubik's Cube form a Group generated by $\\{F, B, L, R, U, D\\}$ (Face turns).\nSize is approx $4.3 \\times 10^{19}$.\n**God's Number**: Maximum diameter of the Cayley Graph is 20 (every state is solvable in 20 moves). Proven computationally using group theory coset concepts.\n\n## 4. Error Correction: Reed-Solomon Code\n\n**Theory**: Encodes message as a polynomial over Finite Field $GF(2^m)$.\n**Algebra**:\n*   Message $a_0, \\dots, a_{k-1}$ defines $P(x) = \\sum a_i x^i$.\n*   Codeword is evaluations $[P(1), P(\\alpha), P(\\alpha^2) \\dots]$.\n*   Because two degree $k-1$ polynomials intersect at most $k-1$ points, this code has large Hamming Distance.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Problems and Solutions\n\n## Problem 1: Necklace with Constraints\n\n**Statement**: Count necklaces with 4 beads, colored Black or White, such that **no two Black beads are adjacent**.\n**Approach**: Burnside's Lemma with restricted fixed point counting.\n*   $N=4$, $G = C_4$ (Rotations: 0, 1, 2, 3).\n*   **Rot 0**: All valid linear strings of length 4 without 'BB'. Use DP/Fibonacci.\n    *   Matches: WWWW, WWWB, WWBW, WBWW, BWWW, WBWB, BWBW. (7 strings). Fixed = 7.\n*   **Rot 1 (90)**: Cycle (1 2 3 4). Monochromatic. 'WWWW', 'BBBB'. 'BBBB' invalid. Fixed = 1 (WWWW).\n*   **Rot 2 (180)**: Cycles (1 3)(2 4). Pattern XYXY. No BB implies X,Y cannot both be B.\n    *   (W, W) -> WWWW (Valid)\n    *   (W, B) -> WBWB (Valid)\n    *   (B, W) -> BWBW (Valid)\n    *   (B, B) -> BBBB (Invalid)\n    *   Fixed = 3.\n*   **Rot 3 (270)**: Same as Rot 1. Fixed = 1.\n\nSum: $(7 + 1 + 3 + 1) / 4 = 12 / 4 = 3$.\nPatterns: WWWW, One B (any pos), Two B opposite (BWBW).\n(Note: WBWB is unique. WWBB is invalid. WBBW invalid. WWWB is One B rotated. So 3 is correct: No B, One B, Two Opposite B).\n\n## Problem 2: Permutation Iteration\n\n**Statement**: Given permutation $P$, find $Q$ such that $Q^2 = P$.\n**Theory**:\n*   If $P$ has a cycle of length $L$:\n    *   If $L$ is odd, $Q$ maps to this cycle by \"interleaving\". (Cycle $1 \\to 3 \\to 5 \\dots$).\n    *   If $L$ is even, we need TWO cycles of length $L$ in $P$ to merge into one cycle of length $2L$ in $Q$.\n*   Condition: Count of even length cycles of each size must be even.\n\n## Problem 3: Giant Step\n\n**Statement**: Find the size of the group generated by two integers $a, b$ modulo $n$ under multiplication.\n**Group**: Subgroup of $\\mathbb{Z}_n^*$.\n**Approach**:\n*   This is not just simple LCM.\n*   The group elements are $a^i b^j \\pmod n$.\n*   This forms a 2D lattice structure in the exponents modulo order(a) and order(b), interacting if they share structure.\n*   Generally simply traverse BFS from 1, multiplying by $a$ and $b$ until no new elements found (for small $n$).\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/03_Abstract_Algebra/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "03 Abstract Algebra"], "content": "# Abstract Algebra: Advanced Notes and Research Directions\n\n## 1. Representation Theory\n\nStudying groups by mapping them to Matrix Groups (GL(n)).\n*   **Character Theory**: Trace of the representation matrices. Simplifies group analysis significantly (e.g., Burnside's $p^a q^b$ theorem).\n*   **Application**: FFT is essentially Representation Theory of finite relationships. Non-abelian FFT uses representations of non-commutative groups.\n\n## 2. Monster Group\n\nThe largest sporadic simple group. Order $\\approx 8 \\times 10^{53}$.\n**Monstrous Moonshine**: Connection between the Monster Group and Modular Functions in Number Theory.\n\n## 3. Lattice-Based Cryptography\n\n**Lattices**: A discrete subgroup of $\\mathbb{R}^n$ (like a grid).\n**Shortest Vector Problem (SVP)**: Hard problem that is basis for Post-Quantum Cryptography (kyber, Dilithium).\nUnlike RSA/ECC, Lattice problems are believed to be hard even for Quantum Computers.\n\n## 4. Category Theory\n\nThe \"Algebra of Algebra\". Abstracts structures (objects) and mappings (morphisms).\n**Haskell/Functional Programming**: Deeply connected to Category Theory (Monads, Functors).\n*   A **Monad** is \"just a monoid in the category of endofunctors\".\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Rigorous Foundations of Calculus\n\n## 1. The Real Number System ($\\mathbb{R}$)\n\nUnlike floating point numbers in computers, Real Numbers ($\\mathbb{R}$) are **Continuous** and **Complete**.\n*   **Completeness Axiom**: Every non-empty subset of $\\mathbb{R}$ that is bounded above has a **Least Upper Bound** (Supremum).\n*   **Implication for CS**: Floating point arithmetic breaks these axioms (e.g., associativity errors, underflow). Understanding \"Epsilon\" ($\\epsilon$) is crucial.\n\n## 2. Sequences and Convergence\n\nA sequence $(x_n)$ converges to $L$ ($\\lim_{n \\to \\infty} x_n = L$) if:\n$$ \\forall \\epsilon > 0, \\exists N \\in \\mathbb{N} \\text{ such that } \\forall n \\ge N, |x_n - L| < \\epsilon $$\n*   **Cauchy Sequence**: Items get closer to *each other*. In $\\mathbb{R}$, Cauchy $\\iff$ Convergent.\n*   **Big-O Notation**: Formally defined using limits superior. $f(n) = O(g(n)) \\iff \\limsup |f(n)/g(n)| < \\infty$.\n\n## 3. Continuity and Limits\n\nA function $f$ is continuous at $c$ if $\\lim_{x \\to c} f(x) = f(c)$.\n*   **Delta-Epsilon Definition**: $\\forall \\epsilon > 0, \\exists \\delta > 0$ such that $|x - c| < \\delta \\implies |f(x) - f(c)| < \\epsilon$.\n*   **Lipschitz Continuity**: $|f(x) - f(y)| \\le K |x - y|$. Stronger than uniform continuity. Critical in **GANs (Generative Adversarial Networks)** training stability (Wasserstein GAN).\n\n## 4. Derivatives and Smoothness\n\nSlope of the tangent line.\n$$ f'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h} $$\n*   **Differentiability classes ($C^k$)**:\n    *   $C^0$: Continuous.\n    *   $C^1$: Differentiable, derivative is continuous (Smooth-ish).\n    *   $C^\\infty$: Infinitely differentiable (Smooth).\n    *   **ReLU**: Not $C^1$ at 0. But practically useful.\n\n## 5. Taylor Series\n\nApproximating functions with polynomials.\n$$ f(x) \\approx \\sum_{n=0}^k \\frac{f^{(n)}(a)}{n!} (x-a)^n $$\n*   **CS Application**: Optimization algorithms (Newton's Method) use 2nd order Taylor approximation.\n\n## 6. Integration (Riemann vs Lebesgue)\n\n*   **Riemann**: Sum of rectangles. Good for continuous functions.\n*   **Lebesgue**: Partitions the range. Handles weird functions (like Dirichlet function). standard necessity for Probability Theory.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Methods and Algorithms\n\n## 1. Root Finding (Solving $f(x) = 0$)\n\n### 1.1 Bisection Method\n**Theory**: Intermediate Value Theorem. If $f(a)$ and $f(b)$ have opposite signs, a root exists in $[a, b]$.\n**Algo**: Check mid. Recurse.\n**Complexity**: Linear choice of accuracy ($O(\\log(1/\\epsilon))$).\n\n### 1.2 Newton-Raphson Method\n**Theory**: Linear approximation using derivative.\n**Algo**: $x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$.\n**Convergence**: Quadratic (doubles digits of precision per step) if close to root.\n\n## 2. Numerical Differentiation\n\nHow to calculate $f'(x)$ if we only have $f$ as a black box?\n*   **Finite Difference**:\n    *   Forward: $\\frac{f(x+h) - f(x)}{h}$. Error $O(h)$.\n    *   Central: $\\frac{f(x+h) - f(x-h)}{2h}$. Error $O(h^2)$. (Much Better).\n*   **Automatic Differentiation (Autodiff)**: The heart of PyTorch/TensorFlow. Applies Chain Rule exactly to computer programs. NOT numerical differentiation.\n\n## 3. Numerical Integration (Quadrature)\n\nCalculating $\\int_a^b f(x) dx$.\n*   **Trapezoidal Rule**: Connect points with lines. Error $O(h^2)$.\n*   **Simpson's Rule**: Connect with parabolas. Error $O(h^4)$.\n*   **Monte Carlo Integration**: Sample random points. $\\frac{1}{N} \\sum f(x_i)$. Error $O(1/\\sqrt{N})$. Good for high dimensions.\n\n## 4. Fixed Point Iteration\n\nSolving $x = g(x)$.\n**Banach Fixed Point Theorem**: If $g$ is a contraction mapping (Lipschitz constant $K < 1$), then $x_{n+1} = g(x_n)$ converges to unique fixed point.\n**App**: PageRank, iterative linear solvers.\n\n## 5. Golden Section Search\n\nFinding min/max of unimodal function without derivatives.\nMaintains a bracket $[a, b]$ and two inner points $c, d$.\nRatio $(b-a)/(d-a)$ is the Golden Ratio $\\phi$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Tricks and Patterns\n\n## 1. Handling Floating Point (The \"Epsilon\" Pattern)\n\nIn Python/C++, never strictly check `a == b` for floats.\n**Pattern**:\n```python\nEPS = 1e-9\nif abs(a - b) < EPS: ...\n```\n\n## 2. Log-Sum-Exp Trick\n\nWhen computing $\\log(\\sum e^{x_i})$ (common in ML softmax), naive computation overflows if $x_i$ is large.\n**Trick**:\n$$ \\log(\\sum e^{x_i}) = \\max(x) + \\log(\\sum e^{x_i - \\max(x)}) $$\nThis effectively shifts exponents to be $\\le 0$, preventing overflow.\n\n## 3. Finding Roots of Monotonic Functions\nIf you need to invert a monotonic function $y = f(x)$ (find $x$ for given $y$):\n**Pattern**: Use Binary Search on the Answer.\n*   Continuous domain: Bisection usually 60-100 iterations gives high precision.\n*   Discrete domain: Standard binary search.\n\n## 4. Convexity Tricks\nIf $f$ is Convex ($f'' > 0$):\n*   Local minimum is Global minimum.\n*   **Jensen's Inequality**: $E[f(X)] \\ge f(E[X])$.\n*   **Ternary Search**: Use to find minimum of unimodal function in $O(\\log n)$.\n\n## 5. Kahan Summation Algorithm\n\nSumming a large array of floats accumulates error.\n**Trick**: Maintain a `c` (compensation) variable to track low-order bits lost in addition.\nReduces error from $O(N \\epsilon)$ to $O(1 \\epsilon)$ effectively.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "\"\"\"\nReal Analysis Algorithms Implementation.\n\nIncludes:\n1. Root Finding (Newton, Bisection).\n2. Numerical Integration (Simpson).\n3. Kahan Summation.\n4. AutoDiff (Toy Implementation of Forward Mode).\n\"\"\"\n\nfrom typing import Callable, List, Union\nimport math\n\n# ==============================================================================\n# 1. Root Finding\n# ==============================================================================\n\ndef bisection_method(f: Callable[[float], float], a: float, b: float, tol=1e-9) -> float:\n    if f(a) * f(b) > 0:\n        raise ValueError(\"No root bracketed\")\n    \n    mid = 0.0\n    for _ in range(100): # Hard limit prevents infinite loops\n        mid = (a + b) / 2\n        if (b - a) < tol:\n            return mid\n        if f(mid) == 0:\n            return mid\n        \n        if f(a) * f(mid) < 0:\n            b = mid\n        else:\n            a = mid\n    return mid\n\ndef newton_method(f: Callable[[float], float], df: Callable[[float], float], x0: float, tol=1e-9) -> float:\n    x = x0\n    for _ in range(100):\n        y = f(x)\n        dy = df(x)\n        if abs(y) < tol:\n            return x\n        if dy == 0:\n            raise ValueError(\"Derivative zero\")\n        x = x - y / dy\n    return x\n\n# ==============================================================================\n# 2. Numerical Integration\n# ==============================================================================\n\ndef simpsons_rule(f: Callable[[float], float], a: float, b: float, n: int) -> float:\n    \"\"\"\n    Approximates definite integral using Simpson's 1/3 rule.\n    n must be even.\n    \"\"\"\n    if n % 2 != 0: n += 1\n    h = (b - a) / n\n    s = f(a) + f(b)\n    \n    for i in range(1, n, 2):\n        s += 4 * f(a + i * h)\n    for i in range(2, n - 1, 2):\n        s += 2 * f(a + i * h)\n        \n    return s * h / 3\n\n# ==============================================================================\n# 3. Kahan Summation\n# ==============================================================================\n\ndef kahan_sum(arr: List[float]) -> float:\n    sum_val = 0.0\n    c = 0.0 # Compensation for lost low-order bits\n    for x in arr:\n        y = x - c\n        t = sum_val + y\n        c = (t - sum_val) - y\n        sum_val = t\n    return sum_val\n\n# ==============================================================================\n# 4. Toy Automatic Differentiation (Forward Mode)\n# ==============================================================================\n\nclass Dual:\n    \"\"\"\n    Represents a number a + b*epsilon where epsilon^2 = 0.\n    val: value\n    der: derivative component\n    \"\"\"\n    def __init__(self, val: float, der: float = 0.0):\n        self.val = val\n        self.der = der\n        \n    def __repr__(self):\n        return f\"Dual(val={self.val}, der={self.der})\"\n    \n    def __add__(self, other):\n        other = other if isinstance(other, Dual) else Dual(other)\n        return Dual(self.val + other.val, self.der + other.der)\n    \n    def __mul__(self, other):\n        other = other if isinstance(other, Dual) else Dual(other)\n        # Product Rule: (u*v)' = u'v + uv'\n        return Dual(self.val * other.val, self.der * other.val + self.val * other.der)\n    \n    def sin(self):\n        # Chain Rule: sin(u)' = cos(u) * u'\n        return Dual(math.sin(self.val), math.cos(self.val) * self.der)\n\ndef differentiate(func: Callable[[Dual], Dual], x: float) -> float:\n    \"\"\"\n    Computes derivative of func at x using Forward Mode Basic.\n    \"\"\"\n    d = Dual(x, 1.0) # Seed derivative 1\n    res = func(d)\n    return res.der\n\nif __name__ == \"__main__\":\n    # Test Root Finding (x^2 - 4 = 0)\n    root_bis = bisection_method(lambda x: x*x - 4, 0, 5)\n    assert abs(root_bis - 2.0) < 1e-6\n    \n    root_newt = newton_method(lambda x: x*x - 4, lambda x: 2*x, 5)\n    assert abs(root_newt - 2.0) < 1e-9\n    \n    # Test Integration (Integral x^2 dx from 0 to 3 is x^3/3 = 9)\n    integ = simpsons_rule(lambda x: x*x, 0, 3, 100)\n    assert abs(integ - 9.0) < 1e-6\n    \n    # Test Autodiff (derivative of x^2 + 2x at x=3 is 2x+2 = 8)\n    def my_func(x):\n        return x*x + Dual(2)*x\n    \n    der_val = differentiate(my_func, 3.0)\n    assert abs(der_val - 8.0) < 1e-9\n    \n    print(\"All Real Analysis Implementations Verified.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Annotated Examples and Use Cases\n\n## 1. Gradient Descent (Optimization)\n\n**Scenario**: Training a Neural Network. Minimizing Loss $L(\\theta)$.\n**Methods**:\n*   **Gradient Descent**: $\\theta_{new} = \\theta_{old} - \\alpha \\nabla L(\\theta)$.\n*   Relies on the derivative pointing in direction of steepest ascent.\n*   **Lipschitz Continuity** ensures that if we take a small enough step ($\\alpha < 1/L$), we strictly decrease Loss.\n\n## 2. Audio Processing (Signals)\n\n**Theory**: Fourier Series implies any periodic function (sound wave) can be represented as sum of infinite sines/cosines.\n**Real Analysis**: Convergence of Fourier Series.\n*   Phenomenon: **Gibbs Phenomenon** at discontinuities (ringing artifacts).\n*   Sampling Theorem (Nyquist-Shannon): Needs rigorous limits to prove.\n\n## 3. Zeno's Paradoxes and Infinite Series\n\n**Problem**: Achilles and the Tortoise. To catch up, Achilles travels half distance, then half remaining... does he ever reach?\n**Analysis**: The sum of an infinite Geometric Series exists and is finite.\n$$ \\sum_{n=1}^\\infty (1/2)^n = 1 $$\nThis resolved centuries of philosophical debate.\n\n## 4. Probability Density Functions (PDF)\n\n**Scenario**: Normal Distribution.\n**Area**: $\\int_{-\\infty}^\\infty \\frac{1}{\\sqrt{2\\pi}} e^{-x^2/2} dx = 1$.\n**Improper Integrals**: Integration over infinite bounds requires Limits: $\\lim_{t \\to \\infty} \\int_{-t}^t$.\n\n## 5. Detecting Edge Cases (Analysis helps bugs)\n\n*   **Function**: $f(x) = 1/x$.\n*   **Problem**: Not continuous at 0.\n*   **Code**: `if abs(x) < 1e-9: raise ValueError`.\n*   **Mathematical Insight**: The limit $\\lim_{x \\to 0^+} f(x) = \\infty$, $\\lim_{x \\to 0^-} f(x) = -\\infty$. Discontinuity is essential, not just a nuisance.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Problems and Solutions\n\n## Problem 1: Square Root without Math Library\n\n**Statement**: Compute `sqrt(n)` to precision `p`.\n**Approach**: Newton's Method on $f(x) = x^2 - n$.\n*   $f'(x) = 2x$.\n*   Update: $x \\leftarrow x - (x^2 - n)/(2x) = (x + n/x) / 2$.\n*   This is the Babylonian Method.\n\n**Python**:\n```python\ndef my_sqrt(n):\n    if n < 0: raise ValueError\n    x = n\n    while abs(x*x - n) > 1e-10:\n        x = (x + n/x) / 2\n    return x\n```\n\n## Problem 2: Ternary Search for Unimodal Max\n\n**Statement**: Given a function $f(x)$ that strictly increases then strictly decreases, find peak.\n**Approach**:\n*   Pick two points $m1 = l + (r-l)/3$, $m2 = r - (r-l)/3$.\n*   If $f(m1) < f(m2)$, peak is in $[m1, r]$.\n*   Else, peak is in $[l, m2]$.\n*   Converges in $O(\\log n)$.\n\n## Problem 3: Simpson's Paradox (Probability/Stats boundary)\n\n(Actually a Stats problem, replacing with Analysis problem).\n\n## Problem 3: Continuous Knapsack (Greedy Analysis)\n\n**Statement**: You can cut items (continuous). Maximize value in weight $W$.\n**Analysis**:\n*   Sort items by density $v_i / w_i$.\n*   Take whole items until $W$ full. Take fraction of last item.\n*   **Proof**: Exchange argument. If you take simpler density item instead of higher, you lose total value. This relies on the \"Intermediate Value\" property of continuous mass.\n\n## Problem 4: Finding Fixed Point\n\n**Statement**: $f: [0, 1] \\to [0, 1]$ is continuous. Prove $f(x)=x$ has a solution and find it.\n**Analytical Proof**: Let $g(x) = f(x) - x$.\n$g(0) = f(0) - 0 \\ge 0$.\n$g(1) = f(1) - 1 \\le 0$.\nBy IVT, exists $c$ such that $g(c)=0 \\implies f(c)=c$.\n**Algo**: Bisection method on $f(x)-x$.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/04_Real_Analysis/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "04 Real Analysis"], "content": "# Real Analysis: Advanced Notes and Research Directions\n\n## 1. Metric Spaces and Topology\n\n$\\mathbb{R}$ is just one example of a Metric Space (Set with distance function).\n*   **Topology**: Generalized notions of \"open sets\" and \"continuity\" without distance.\n*   **Manifolds**: Spaces that look like $\\mathbb{R}^n$ locally. (e.g., surface of a sphere).\n*   **Manifold Learning**: ML technique assuming high-dim data lies on low-dim manifold.\n\n## 2. Measure Theory\n\nGeneralizing \"length\" and \"volume\".\n*   **Lebesgue Measure**: The standard way to assign size to sets.\n*   **Probability Theory**: Formally defined as Measure Theory with total measure 1.\n*   **Almost Everywhere (a.e.)**: Property holds everywhere except on a set of measure zero. (e.g., $ReLU$ is differentiable a.e.).\n\n## 3. Functional Analysis\n\nVector spaces where \"vectors\" are functions.\n*   **Hilbert Spaces**: Complete inner product spaces (infinite dimensions). Basis for Quantum Mechanics.\n*   **Reproducing Kernel Hilbert Spaces (RKHS)**: The math behind Kernel Machines (SVMs) and Gaussian Processes.\n\n## 4. Fourier Analysis (Harmonic Analysis)\n\nDecomposing functions into frequencies.\n*   **Wavelets**: Localized frequency analysis. Used in JPEG2000 and signal denoising.\n*   **Sparse Fourier Transform**: Algorithms faster than FFT for sparse signals.\n\n## 5. Non-Standard Analysis\n\nRigorous formulation of calculus using infinitesimals (hyperreal numbers).\n*   Justifies logical intuition of $dx$ as an infinitely small number.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/01_Theory.md", "title": "01 Theory", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/01_Theory.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: The Geometry of Numbers\n\n## 1. Complex Numbers $\\mathbb{C}$\n\nExtensions of reals with $i^2 = -1$.\n*   **Form**: $z = x + iy$.\n*   **Polar Form**: $z = r e^{i\\theta} = r (\\cos \\theta + i \\sin \\theta)$.\n*   **Euler's Formula**: $e^{i\\pi} + 1 = 0$.\n\n### 1.1 Geometry\n*   Addition: Vector addition in 2D plane.\n*   Multiplication: Scale lengths ($r_1 r_2$), Add angles ($\\theta_1 + \\theta_2$).\n*   **Roots of Unity**: Solutions to $z^n = 1$. Form a regular $n$-gon. Critical for FFT.\n\n## 2. Holomorphic Functions\n\nComplex differentiable functions. This is a MUCh stronger condition than real differentiability.\n$$ f'(z_0) = \\lim_{z \\to z_0} \\frac{f(z) - f(z_0)}{z - z_0} $$\nLimit must be independent of direction of approach.\n\n### 2.1 Cauchy-Riemann Equations\nFor $f(z) = u(x, y) + i v(x, y)$ to be holomorphic:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y} \\quad \\text{and} \\quad \\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x} $$\nConsequence: Holomorphic functions are $C^\\infty$ (infinitely differentiable) and **Analytic** (equal to their Taylor series).\n\n## 3. Cauchy's Integral Theorem\n\nIf $f$ is holomorphic on a simply connected domain and $\\gamma$ is a closed loop:\n$$ \\oint_\\gamma f(z) dz = 0 $$\n**Path Independence**: Integration between two points is independent of path.\n\n### 3.1 Cauchy's Integral Formula\nValue inside a loop is determined by values on boundary:\n$$ f(a) = \\frac{1}{2\\pi i} \\oint_\\gamma \\frac{f(z)}{z-a} dz $$\n\n## 4. Residue Theorem\n\nA powerful tool to evaluate integrals.\n$$ \\oint_\\gamma f(z) dz = 2\\pi i \\sum \\text{Res}(f, a_k) $$\nwhere $a_k$ are singularities inside $\\gamma$.\n*   **Residue**: The coefficient $c_{-1}$ in the Laurent Series $\\sum c_n (z-a)^n$.\n\n## 5. Conformal Mapping\n\nHolomorphic functions preserve angles (conformal).\n*   **Riemann Mapping Theorem**: Any simply connected non-empty open subset of $\\mathbb{C}$ (not whole $\\mathbb{C}$) can be mapped bijectively to the open unit disk.\n*   **App**: Solving fluid flow (aerodynamics) on complex shapes by mapping shape to a circle.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/02_Methods_and_Algorithms.md", "title": "02 Methods and Algorithms", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/02_Methods_and_Algorithms.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Methods and Algorithms\n\n## 1. Fast Fourier Transform (FFT)\n\nThe most important algorithm in history ($O(N \\log N)$).\n**Theory**: Evaluating a polynomial $P(x)$ at $n$-th Roots of Unity.\n**Divide and Conquer**:\n$P(x) = P_{even}(x^2) + x P_{odd}(x^2)$.\nUsing $\\omega_n^k$, we exploit symmetry $\\omega_n^{k + n/2} = -\\omega_n^k$.\n\n## 2. M\u00f6bius Transformations\n\nBijective maps from extended complex plane to itself.\n$$ f(z) = \\frac{az + b}{cz + d} $$\n*   Maps circles/lines to circles/lines.\n*   Used in **Image Processing** for warping.\n\n## 3. Contour Integration (for Real Integrals)\n\nTechnique to solve hard real integrals $\\int_{-\\infty}^\\infty f(x) dx$ by \"completing the contour\" in the complex plane and summing Residues.\n**Method**:\n1.  Choose semi-circle contour.\n2.  Show integral on arc $\\to 0$ as $R \\to \\infty$ (Jordan's Lemma).\n3.  Answer is $2\\pi i \\sum \\text{Residues}$.\n\n## 4. Generating Fractal Images (Mandelbrot)\n\nIterating $z_{n+1} = z_n^2 + c$.\n*   **Mandelbrot Set**: $c$ such that $|z_n|$ remains bounded starting $z_0 = 0$.\n*   **Julia Sets**: Fixed $c$, vary $z_0$.\n\n## 5. Phase Unwrapping\n\nIn signal processing, we compute phase $\\phi(t) = \\text{arg}(z(t))$.\nThis value jumps by $2\\pi$.\n**Algorithm**: Detect jumps $>\\pi$ and add $\\pm 2\\pi$ to make phase continuous.\nEssential for Radar/Sonar processing.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/03_Tricks_and_Patterns.md", "title": "03 Tricks and Patterns", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/03_Tricks_and_Patterns.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Tricks and Patterns\n\n## 1. Roots of Unity Tricks\n\n### 1.1 Sum of Roots\nSum of all $n$-th roots of unity is 0 (for $n > 1$).\n$\\sum_{k=0}^{n-1} \\omega^k = \\frac{\\omega^n - 1}{\\omega - 1} = 0$.\n\n### 1.2 Filtering\nTo extract coefficients where index is multiple of $k$:\nEvaluate polynomial at all $k$-th roots of unity and average.\n**App**: Solving combinatorial problems with modulo constraints.\n\n## 2. Rotation as Multiplication\n\nTo rotate a 2D point $(x, y)$ by $\\theta$:\nDon't use $2 \\times 2$ matrices.\nUse $z = x + iy$.\n$z_{new} = z \\cdot e^{i\\theta}$.\nMuch cleaner code and math derivation.\n\n## 3. Analytic Continuation\n\nIf two holomorphic functions agree on a small line segment, they agree everywhere.\n**Trick**: Prove identity for real $x$, it holds for complex $z$.\nExample: $\\sin^2 z + \\cos^2 z = 1$ is true for all $\\mathbb{C}$.\n\n## 4. Argument Principle\n\nTo count zeros of $f(z)$ inside a contour:\n$$ \\frac{1}{2\\pi i} \\oint \\frac{f'(z)}{f(z)} dz = N - P $$\n($N$ zeros, $P$ poles).\n**App**: Nyquist Stability Criterion in Control Theory.\n\n## 5. Identifying Circle Equation\nEquation $|z - a| = r$ is a circle.\nCan be expanded: $(z-a)(\\bar{z}-\\bar{a}) = r^2$.\n$z\\bar{z} - z\\bar{a} - \\bar{z}a + |a|^2 - r^2 = 0$.\nUseful in computational geometry involving inversion.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/04_Python_Implementations.py", "title": "04 Python Implementations", "type": "Code", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/04_Python_Implementations.py", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "\"\"\"\nComplex Analysis Algorithms Implementation.\n\nIncludes:\n1. Complex Number Basic Operations (Demo).\n2. Iterative FFT (Cooley-Tukey).\n3. Mandelbrot Set Generator.\n4. M\u00f6bius Transformation Class.\n\"\"\"\n\nfrom typing import List, Tuple\nimport math\nimport cmath\n\n# ==============================================================================\n# 1. FFT (Iterative)\n# ==============================================================================\n\ndef fft(a: List[complex], inverse: bool = False) -> List[complex]:\n    \"\"\"\n    Computes FFT of array a. Len(a) must be power of 2.\n    \"\"\"\n    n = len(a)\n    if (n & (n - 1)) != 0:\n        raise ValueError(\"Length must be power of 2\")\n        \n    # Bit Reversal Permutation\n    # O(N)\n    b = list(a)\n    shifts = n.bit_length() - 1\n    for i in range(n):\n        # Reverse bits of i\n        rev = 0\n        temp = i\n        for _ in range(shifts):\n            rev = (rev << 1) | (temp & 1)\n            temp >>= 1\n        if i < rev:\n            b[i], b[rev] = b[rev], b[i]\n            \n    # Cooley-Tukey Butterfly\n    # O(N log N)\n    length = 2\n    while length <= n:\n        angle = 2 * math.pi / length * (-1 if inverse else 1)\n        wlen = cmath.exp(complex(0, angle))\n        for i in range(0, n, length):\n            w = 1 + 0j\n            for j in range(length // 2):\n                u = b[i + j]\n                v = b[i + j + length // 2] * w\n                b[i + j] = u + v\n                b[i + j + length // 2] = u - v\n                w *= wlen\n        length *= 2\n        \n    if inverse:\n        for i in range(n):\n            b[i] /= n\n            \n    return b\n\ndef multiply_polynomials_fft(p1: List[int], p2: List[int]) -> List[int]:\n    \"\"\"\n    Multiplies two polynomials using FFT.\n    Takes coeffs, returns coeffs of product.\n    \"\"\"\n    n = 1\n    while n < len(p1) + len(p2): n *= 2\n    \n    fa = [complex(x, 0) for x in p1] + [0] * (n - len(p1))\n    fb = [complex(x, 0) for x in p2] + [0] * (n - len(p2))\n    \n    fa = fft(fa)\n    fb = fft(fb)\n    \n    fc = [fa[i] * fb[i] for i in range(n)]\n    \n    res_complex = fft(fc, inverse=True)\n    return [round(x.real) for x in res_complex]\n\n# ==============================================================================\n# 2. M\u00f6bius Transformation\n# ==============================================================================\n\nclass MobiusTransform:\n    def __init__(self, a, b, c, d):\n        # f(z) = (az + b) / (cz + d)\n        self.mat = [[a, b], [c, d]]\n        \n    def apply(self, z: complex) -> complex:\n        num = self.mat[0][0] * z + self.mat[0][1]\n        den = self.mat[1][0] * z + self.mat[1][1]\n        if den == 0:\n            return float('inf') # Point at infinity\n        return num / den\n\n    def compose(self, other: 'MobiusTransform') -> 'MobiusTransform':\n        # Composition corresponds to matrix multiplication\n        a1, b1 = self.mat[0]\n        c1, d1 = self.mat[1]\n        a2, b2 = other.mat[0]\n        c2, d2 = other.mat[1]\n        \n        return MobiusTransform(\n            a1*a2 + b1*c2, a1*b2 + b1*d2,\n            c1*a2 + d1*c2, c1*b2 + d1*d2\n        )\n\nif __name__ == \"__main__\":\n    # Test FFT Mult: (1 + x)(1 + x) = 1 + 2x + x^2\n    p1 = [1, 1]\n    p2 = [1, 1]\n    res = multiply_polynomials_fft(p1, p2)\n    # Expected [1, 2, 1, 0...]\n    assert res[0] == 1 and res[1] == 2 and res[2] == 1\n    \n    # Test Mobius\n    # f(z) = 1/z  (a=0, b=1, c=1, d=0)\n    inv = MobiusTransform(0, 1, 1, 0)\n    z = 2 + 0j\n    assert abs(inv.apply(z) - 0.5) < 1e-9\n    \n    print(\"Complex Analysis Implementations Verified.\")\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/05_Annotated_Examples_and_Use_Cases.md", "title": "05 Annotated Examples and Use Cases", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/05_Annotated_Examples_and_Use_Cases.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Annotated Examples and Use Cases\n\n## 1. Electrical Engineering: AC Circuits\n\n**Concept**: Impedance.\n*   Resistors: Real. $R$.\n*   Inductors: Imaginary. $j\\omega L$.\n*   Capacitors: Imaginary negative. $1/(j\\omega C)$.\n*   **Ohm's Law**: $V = I Z$ (Complex numbers).\n*   Greatly simplifies differential equations to algebraic equations.\n\n## 2. Fluid Dynamics: Potential Flow\n\n**Concept**: Modeling ideal (inviscid, incompressible) flow in 2D.\n*   Velocity Potential $\\phi$. Stream Function $\\psi$.\n*   Complex Potential: $w(z) = \\phi + i \\psi$.\n*   Velocity vector field is $\\overline{w'(z)}$.\n*   **Joukowski Transform**: Maps circle to airfoil shape. Foundational for early aeronautics.\n\n## 3. Quantum Mechanics\n\n**Wavefunction**: $\\Psi(x, t)$ is complex-valued.\n*   Probability: $|\\Psi|^2$.\n*   Phase is physically meaningful (Interference).\n*   Schr\u00f6dinger Equation involves $i$: $i \\hbar \\frac{\\partial}{\\partial t} \\Psi = \\hat{H} \\Psi$.\n\n## 4. Control Theory: Root Locus\n\n**Problem**: Stability of feedback systems.\n**poles**: Roots of denominator of Transfer Function $H(s)$.\n**Condition**: System is stable if all poles have **negative real part** (Left Half Plane).\n**Nyquist Plot**: Contour integral of transfer function to count poles around origin.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/06_Problems_and_Solutions.md", "title": "06 Problems and Solutions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/06_Problems_and_Solutions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Problems and Solutions\n\n## Problem 1: Integration via Residues\n\n**Statement**: Evaluate $I = \\int_{-\\infty}^\\infty \\frac{1}{x^2 + 1} dx$.\n**Real Method**: $\\arctan(x)|_{-\\infty}^\\infty = \\pi/2 - (-\\pi/2) = \\pi$.\n**Complex Method**:\n1.  Consider $f(z) = \\frac{1}{z^2 + 1}$. Singularities at $z = \\pm i$.\n2.  Contour: Semi-circle in upper half plane $R \\to \\infty$.\n3.  Residue at $z=i$: $\\lim_{z \\to i} (z-i) \\frac{1}{(z-i)(z+i)} = \\frac{1}{2i}$.\n4.  Integral = $2\\pi i \\times \\text{Res} = 2\\pi i (1/2i) = \\pi$. Matches.\n\n## Problem 2: Counting Roots (Rouche's Theorem)\n\n**Statement**: How many roots does $z^5 + 3z + 1 = 0$ have inside $|z| < 1$?\n**Theorem**: If $|g(z)| < |f(z)|$ on boundary, $f$ and $f+g$ have same number of zeros.\n**Attempt**:\n*   Let $f(z) = 3z$, $g(z) = z^5 + 1$.\n*   On boundary $|z|=1$: $|f(z)| = 3$. $|g(z)| \\le |z|^5 + 1 = 2$.\n*   Since $2 < 3$, $|g| < |f|$.\n*   $f(z)=3z$ has 1 zero inside.\n*   Therefore, $z^5 + 3z + 1$ has **1 zero** inside.\n\n## Problem 3: Conformal Map Construction\n\n**Statement**: Map Upper Half Plane ($\\text{Im}(z) > 0$) to Unit Disk ($|w| < 1$).\n**Ansatz**: M\u00f6bius transform.\n*   Map $i \\to 0$ (Center).\n*   Map $0 \\to -1$ (Boundary).\n*   Map $\\infty \\to 1$ (Boundary).\n**Result**: $f(z) = \\frac{z-i}{z+i}$.\n*   This is the **Cayley Transform**.\n"}, {"id": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/07_Advanced_Notes_and_Research_Directions.md", "title": "07 Advanced Notes and Research Directions", "type": "Topic", "path": "Algorithms-and-Data-Structures-Python/01_Pure_Mathematics/05_Complex_Analysis/07_Advanced_Notes_and_Research_Directions.md", "breadcrumbs": ["Algorithms-and-Data-Structures-Python", "01 Pure Mathematics", "05 Complex Analysis"], "content": "# Complex Analysis: Advanced Notes and Research Directions\n\n## 1. Riemann Zeta Function $\\zeta(s)$\n\nDefined as $\\sum n^{-s}$ for Re($s$) > 1. Analytic continuation to $\\mathbb{C}$.\n*   **Riemann Hypothesis (Millennium Prize)**: All non-trivial zeros lie on Re($s$) = 1/2.\n*   Deep connection to distribution of Prime Numbers.\n\n## 2. Several Complex Variables\n\n$\\mathbb{C}^n$ is much weirder than $\\mathbb{C}^1$.\n*   **Hartogs' Extension Theorem**: Singularities cannot be isolated points (unlike $\\mathbb{C}^1$ where $1/z$ has singularity at 0). Holes in domain are \"filled in\" by holomorphic functions.\n*   **Domains of Holomorphy**: Only specific shapes allow functions that don't extend beyond them.\n\n## 3. Modular Forms\n\nFunctions on the upper half plane satisfying symmetries under $SL_2(\\mathbb{Z})$ group actions.\n$$ f\\left(\\frac{az+b}{cz+d}\\right) = (cz+d)^k f(z) $$\n*   Crucial in proof of **Fermat's Last Theorem**.\n*   String Theory uses Modular Forms extensively.\n\n## 4. Complex Dynamics\n\nStudy of iteration $f(f(...z...))$.\n*   **Fatou Set**: Values behave normally.\n*   **Julia Set**: Values behave chaotically.\n*   Essential for Chaos Theory.\n"}, {"id": "Python_Theory/01_Introduction/01_Definition.md", "title": "01 Definition", "type": "Topic", "path": "Python_Theory/01_Introduction/01_Definition.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": ""}, {"id": "Python_Theory/01_Introduction/02_Theory.md", "title": "02 Theory", "type": "Topic", "path": "Python_Theory/01_Introduction/02_Theory.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": ""}, {"id": "Python_Theory/01_Introduction/03_Properties_and_Uses.md", "title": "03 Properties and Uses", "type": "Topic", "path": "Python_Theory/01_Introduction/03_Properties_and_Uses.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": ""}, {"id": "Python_Theory/01_Introduction/04_Syntax_and_Methods.md", "title": "04 Syntax and Methods", "type": "Topic", "path": "Python_Theory/01_Introduction/04_Syntax_and_Methods.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": ""}, {"id": "Python_Theory/01_Introduction/05_Examples.md", "title": "05 Examples", "type": "Topic", "path": "Python_Theory/01_Introduction/05_Examples.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": ""}, {"id": "Python_Theory/01_Introduction/06_Common_Errors.md", "title": "06 Common Errors", "type": "Topic", "path": "Python_Theory/01_Introduction/06_Common_Errors.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": ""}, {"id": "Python_Theory/01_Introduction/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/01_Introduction/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "01 Introduction"], "content": ""}, {"id": "Python_Theory/02_Basic_Syntax/01_Indentation_and_Comments.md", "title": "01 Indentation and Comments", "type": "Topic", "path": "Python_Theory/02_Basic_Syntax/01_Indentation_and_Comments.md", "breadcrumbs": ["Python Theory", "02 Basic Syntax"], "content": "# Indentation and Comments\n\n## Definition\n**Indentation** refers to the spaces at the beginning of a code line. In Python, it is not just for readability but is a **syntactic requirement** to define blocks of code.\n**Comments** are text ignored by the interpreter, used to explain code or leave notes.\n\n## Theory\n- **Indentation**: Most languages (C++, Java) use braces `{}` to define scope. Python uses whitespace. This enforces readability (\"readability counts\").\n- **Comments**: Critical for collaboration. Python supports single-line comments and docstrings (documentation strings) for modules, classes, and functions.\n\n## Syntax and Rules\n\n### Indentation\n- **Standard**: 4 spaces per level (PEP 8 recommendation).\n- **Rule**: All statements in the same block must have the same indentation level.\n- **Tabs vs Spaces**: Do not mix them. Using spaces is the preferred method.\n\n### Comments\n- **Single-line**: Starts with `#`.\n- **Multi-line (Docstrings)**: Enclosed in `\"\"\"` or `'''`. While technically string literals, when placed at the start of a function/module, they act as documentation.\n\n## Examples\n\n```python\n# This is a single-line comment\n\ndef example_function():\n    \"\"\"\n    This is a docstring.\n    It explains the function.\n    \"\"\"\n    if True:\n        # This block is indented\n        print(\"Indentation matters!\")\n    # End of if block\n# End of function\n```\n\n## Common Errors\n1.  **IndentationError: unexpected indent**: Adding spaces where they aren't needed.\n2.  **IndentationError: unindent does not match any outer indentation level**: Messy structure.\n3.  **TabError**: Mixing tabs and spaces.\n"}, {"id": "Python_Theory/02_Basic_Syntax/02_Variables_and_Constants.md", "title": "02 Variables and Constants", "type": "Topic", "path": "Python_Theory/02_Basic_Syntax/02_Variables_and_Constants.md", "breadcrumbs": ["Python Theory", "02 Basic Syntax"], "content": "# Variables and Constants\n\n## Definition\n- **Variable**: A reserved memory location to store values. In Python, a variable is a *name* that refers to an object in memory.\n- **Constant**: A type of variable whose value should not be changed. Python does not enforce constants syntactically, but by convention, uppercase names are used.\n\n## Theory\n- **Dynamic Typing**: You don't declare types (e.g., `int x`). Python infers types at runtime.\n- **References**: Variables are references (pointers) to objects. If `a = [1]` and `b = a`, both point to the same list.\n- **Naming Conventions**:\n    - Variables: `snake_case` (e.g., `user_name`)\n    - Constants: `UPPER_CASE` (e.g., `MAX_SPEED`)\n    - Classes: `PascalCase` (e.g., `MyClass`)\n\n## Syntax\n\n```python\nvariable_name = value\nCONSTANT_NAME = value\n```\n\n- **Multiple Assignment**: `x, y, z = 1, 2, 3`\n- **Chain Assignment**: `x = y = z = 0`\n\n## Examples\n\n```python\n# Variable assignment\nage = 25\nname = \"John\"\n\n# Constant (Convention only)\nPI = 3.14159\n\n# Changing a variable (Dynamic typing)\nx = 100       # x is an int\nx = \"Hello\"   # x is now a str (Perfectly valid in Python)\n\nprint(name)\nprint(x)\n```\n\n## Common Errors\n1.  **NameError**: Using a variable before assignment.\n2.  **SyntaxError**: Variable names cannot start with a number (`1st_var` is invalid) or contain spaces.\n"}, {"id": "Python_Theory/02_Basic_Syntax/03_Input_Output.md", "title": "03 Input Output", "type": "Topic", "path": "Python_Theory/02_Basic_Syntax/03_Input_Output.md", "breadcrumbs": ["Python Theory", "02 Basic Syntax"], "content": "# Input and Output\n\n## Output: `print()`\nThe `print()` function sends data to the standard output.\n\n### key Arguments\n- `sep`: Separator between items (default is space `' '`).\n- `end`: What to print at the end (default is newline `'\\n'`).\n\n### Examples\n```python\nprint(\"Hello\", \"World\")             # Output: Hello World\nprint(\"Hello\", \"World\", sep=\"-\")    # Output: Hello-World\nprint(\"Line 1\", end=\" \")\nprint(\"Line 2\")                     # Output: Line 1 Line 2\n```\n\n## Input: `input()`\nThe `input()` function pauses execution and waits for the user to type text and press Enter.\n**Important**: It *always* returns a **string**.\n\n### Syntax\n```python\nvariable = input(\"Prompt message: \")\n```\n\n### Type Casting\nIf you need a number, you must cast the string.\n```python\nage = input(\"Enter age: \")  # \"25\"\nage_int = int(age)          # 25\n```\n\n## String Formatting (Output Formatting)\nThe modern way to format strings is using **f-strings** (formatted string literals), introduced in Python 3.6.\n\n```python\nname = \"Alice\"\nscore = 95\nprint(f\"Player {name} scored {score} points.\")\n```\n\nOther methods (older):\n- `.format()`: `\"Player {} scored {}\".format(name, score)`\n- `%` operator: `\"Player %s scored %d\" % (name, score)`\n"}, {"id": "Python_Theory/02_Basic_Syntax/04_Practice_Questions.md", "title": "04 Practice Questions", "type": "Topic", "path": "Python_Theory/02_Basic_Syntax/04_Practice_Questions.md", "breadcrumbs": ["Python Theory", "02 Basic Syntax"], "content": "# Practice Questions - Basic Syntax\n\n## Questions\n\n### Q1: Variable Swapping\nCreate two variables `a = 50` and `b = 100`. Swap their values without using a third variable (hint: Python allows multiple assignment).\n\n### Q2: Formatted Output\nAsk the user for their name and birth year. Print a message:\n`Hello [Name], you are approx [age] years old.`\n(Assume current year is 2025).\n\n### Q3: Fix the Code\n```python\nprice = 19.99\nprint(\"The price is \" + price)\n```\n\n## Solutions\n\n**A1:**\n```python\na, b = 50, 100\na, b = b, a\nprint(a, b)  # 100 50\n```\n\n**A2:**\n```python\ncurrent_year = 2025\nname = input(\"Enter name: \")\nyear_str = input(\"Enter birth year: \")\nage = current_year - int(year_str)  # Convert input to int\nprint(f\"Hello {name}, you are approx {age} years old.\")\n```\n\n**A3:**\nError: `TypeError`, cannot concatenate float to string.\nFix:\n```python\nprint(f\"The price is {price}\")\n# OR\nprint(\"The price is \" + str(price))\n```\n"}, {"id": "Python_Theory/03_Data_Types/01_Overview.md", "title": "01 Overview", "type": "Topic", "path": "Python_Theory/03_Data_Types/01_Overview.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Data Types Overview\n\n## Definition\nVariables can store data of different types, and different types can do different things.\nPython has the following standard built-in data types:\n\n## Taxonomy of Data Types\nIt is crucial to understand which types are **Mutable** (changeable) and **Immutable** (unchangeable).\n\n### 1. Immutable Types\nOnce created, their value cannot be changed. If you \"modify\" them, Python actually creates a new object.\n- **Numeric**: `int`, `float`, `complex`\n- **Text**: `str`\n- **Boolean**: `bool`\n- **Sequence**: `tuple` (contains immutable or mutable items, but the tuple structure itself is immutable)\n- **Special**: `NoneType`\n\n### 2. Mutable Types\nYou can change the content without changing the identity (memory address) of the object.\n- **Sequence**: `list`\n- **Mapping**: `dict`\n- **Set Types**: `set`\n- **Binary**: `bytearray`\n\n## Getting the Type\nUse the `type()` function to check the type of any object.\n\n```python\nx = 5\nprint(type(x))  # <class 'int'>\n\ny = \"Hello\"\nprint(type(y))  # <class 'str'>\n```\n\n## Summary Table\n\n| Category | Type Name | Example | Mutable? |\n| :--- | :--- | :--- | :--- |\n| Text | `str` | `\"Hello\"` | No |\n| Numeric | `int` | `20` | No |\n| Numeric | `float` | `20.5` | No |\n| Numeric | `complex` | `1j` | No |\n| Sequence | `list` | `[\"apple\", \"banana\"]` | **Yes** |\n| Sequence | `tuple` | `(\"apple\", \"banana\")` | No |\n| Sequence | `range` | `range(6)` | No |\n| Mapping | `dict` | `{\"name\": \"John\", \"age\": 36}` | **Yes** |\n| Set | `set` | `{\"apple\", \"banana\"}` | **Yes** |\n| Set | `frozenset` | `frozenset({\"apple\", \"banana\"})` | No |\n| Boolean | `bool` | `True` | No |\n| Binary | `bytes` | `b\"Hello\"` | No |\n| None | `NoneType` | `None` | No |\n"}, {"id": "Python_Theory/03_Data_Types/02_Numbers.md", "title": "02 Numbers", "type": "Topic", "path": "Python_Theory/03_Data_Types/02_Numbers.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Numbers\n\n## Definition\nPython supports three distinct numeric types:\n1.  **Integers** (`int`)\n2.  **Floating point numbers** (`float`)\n3.  **Complex numbers** (`complex`)\n\n## 1. Integers (`int`)\n- Whole numbers, positive or negative, without decimals, of unlimited length.\n- Python 3 handles large integers automatically (no \"long\" type like in Python 2 or C).\n\n```python\nx = 1\ny = 35656222554887711\nz = -3255522\n\nprint(type(x))  # <class 'int'>\n```\n\n## 2. Floating Point Numbers (`float`)\n- Numbers containing one or more decimals.\n- Can also be scientific numbers with an \"e\" to indicate the power of 10.\n\n```python\nx = 1.10\ny = 1.0\nz = -35.59\nw = 35e3        # 35 * 10^3 = 35000.0\n# Note: w is a float\n```\n\n## 3. Complex Numbers (`complex`)\n- Written with a \"j\" as the imaginary part.\n- Useful in engineering and complex mathematics.\n\n```python\nx = 3+5j\ny = 5j\nz = -5j\n\nprint(type(x))  # <class 'complex'>\nprint(x.real)   # 3.0\nprint(x.imag)   # 5.0\n```\n\n## Useful Math Functions\n\n### Built-in\n- `abs(x)`: Absolute value.\n- `round(x, n)`: Round number to `n` digits.\n- `pow(x, y)`: x to the power of y (same as `x ** y`).\n\n### The `math` Module\nFor more advanced operations, import `math`.\n\n```python\nimport math\n\nprint(math.ceil(1.4))   # 2\nprint(math.floor(1.4))  # 1\nprint(math.sqrt(64))    # 8.0\nprint(math.pi)          # 3.14159...\n```\n\n## Common Errors\n- **Float Precision**: Floats are approximations. `0.1 + 0.2` might equal `0.30000000000000004` instead of `0.3` due to binary floating-point representation.\n- **Division**: In Python 3, `/` always returns a float (`a / b`). Use `//` for integer (floor) division.\n"}, {"id": "Python_Theory/03_Data_Types/03_Booleans.md", "title": "03 Booleans", "type": "Topic", "path": "Python_Theory/03_Data_Types/03_Booleans.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Booleans\n\n## Definition\nBooleans represent one of two values: `True` or `False`. They are a subclass of integers (where True is 1 and False is 0).\n\n## Theory\n- Used primarily in **conditional statements** (if/else) and **loops**.\n- Comparison operations return booleans.\n\n```python\nprint(10 > 9)   # True\nprint(10 == 9)  # False\nprint(10 < 9)   # False\n```\n\n## Truthiness (True or False?)\nIn Python, almost any value is evaluated to `True` if it has some sort of content.\n\n### What is True?\n- Any non-zero number.\n- Any non-empty string.\n- Any non-empty list, tuple, set, or dictionary.\n\n### What is False?\n- `False` itself.\n- `None`.\n- Zero of any numeric type: `0`, `0.0`, `0j`.\n- Empty sequences and collections: `''`, `()`, `[]`, `{}`.\n\n## Bool Function\nTo check if a value acts as True or False, use the `bool()` function.\n\n```python\nprint(bool(\"Hello\"))  # True\nprint(bool(15))       # True\n\nprint(bool(\"\"))       # False\nprint(bool(0))        # False\nprint(bool([]))       # False\n```\n\n## Boolean Logic Operators\n`and`, `or`, `not`\n\n```python\nx = True\ny = False\n\nprint(x and y)  # False\nprint(x or y)   # True\nprint(not x)    # False\n```\n"}, {"id": "Python_Theory/03_Data_Types/04_Type_Conversion.md", "title": "04 Type Conversion", "type": "Topic", "path": "Python_Theory/03_Data_Types/04_Type_Conversion.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Type Conversion (Casting)\n\n## Definition\nType conversion is the process of converting the value of one data type (integer, string, float, etc.) to another data type.\n\n## 1. Implicit Conversion\nPython automatically converts one data type to another without any user involvement. This usually happens when mixing types to prevent data loss.\n\n```python\nx_int = 10\ny_float = 10.5\n\nresult = x_int + y_float\n\nprint(result)        # 20.5\nprint(type(result))  # <class 'float'>\n# Python promoted the int to float to perform the addition.\n```\n\n## 2. Explicit Conversion (Casting)\nThe user manually changes the data type using built-in functions like `int()`, `float()`, `str()`, etc.\n\n### Common Functions\n\n- `int(x)`: Converts x to an integer.\n    - `int(3.9)` -> `3` (truncates, does not round)\n    - `int(\"10\")` -> `10`\n    - `int(\"10.5\")` -> Error! (String must look like an int)\n\n- `float(x)`: Converts x to a float.\n    - `float(5)` -> `5.0`\n    - `float(\"3.14\")` -> `3.14`\n\n- `str(x)`: Converts x to a string representation.\n    - `str(100)` -> `\"100\"`\n    - `str([1, 2])` -> `\"[1, 2]\"`\n\n### Examples\n\n```python\n# Convert float to int\nnum_sum = int(123.654)\nprint(num_sum)  # 123 (truncation)\n\n# Convert number to string for concatenation\nage = 25\nmessage = \"I am \" + str(age) + \" years old\"\nprint(message)\n```\n\n## Common Errors\n- **ValueError**: Trying to cast an incompatible string to a number.\n  ```python\n  x = int(\"Hello\")  # ValueError: invalid literal for int()\n  y = int(\"12.5\")   # ValueError: invalid literal for int() (must convert to float first, then int)\n  ```\n"}, {"id": "Python_Theory/03_Data_Types/05_NoneType.md", "title": "05 NoneType", "type": "Topic", "path": "Python_Theory/03_Data_Types/05_NoneType.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# NoneType\n\n## Definition\n`None` is a special keyword in Python that represents the **absence of a value** or a **null** value. It is an object of its own datatype, the `NoneType`.\n\n## Theory\n- `None` is not the same as `0` (zero), `False`, or an empty string `\"\"`.\n- `None` is the only value of the `NoneType`.\n- Functions that do not explicitly return a value return `None` by default.\n\n## Syntax and Usage\n\n```python\nx = None\n\nif x is None:\n    print(\"x has no value\")\n\nif x is not None:\n    print(\"x has a value\")\n```\n\n### Important Rule: Use `is` for None\nAlways use `is` or `is not` to check for `None`, rather than `==` or `!=`.\n- `x is None` (Correct/Pythonic)\n- `x == None` (Works, but discouraged)\n\n## Example: Default return value\n\n```python\ndef my_func():\n    print(\"Doing something\")\n    # No return statement here\n\nresult = my_func()\nprint(result)  # Output: None\n```\n\n## Common Errors\n- **AttributeError**: Trying to access methods on a `None` value (often forgetting that a function returned `None`).\n    ```python\n    x = None\n    # print(x.upper())  # AttributeError: 'NoneType' object has no attribute 'upper'\n    ```\n"}, {"id": "Python_Theory/03_Data_Types/06_Practice_Questions.md", "title": "06 Practice Questions", "type": "Topic", "path": "Python_Theory/03_Data_Types/06_Practice_Questions.md", "breadcrumbs": ["Python Theory", "03 Data Types"], "content": "# Practice Questions - Data Types\n\n## Questions\n\n### Q1: Type Identification\nWhat is the data type of the following values?\n1. `x = 5`\n2. `x = 5.0`\n3. `x = 5 > 4`\n4. `x = \"5\"`\n5. `x = int(\"5\")`\n\n### Q2: Immutability\nWhat happens if you run the following code? Why?\n```python\nx = (1, 2)\nx[0] = 5\n```\n\n### Q3: Casting Challenge\nConvert the float number `8.99` to an integer. What is the result: `8` or `9`?\n\n### Q4: Boolean Logic\nEvaluate:\n`True and False or not False`\n\n---\n\n## Solutions\n\n**A1:**\n1. `int`\n2. `float`\n3. `bool` (`True`)\n4. `str`\n5. `int`\n\n**A2:**\n**TypeError**. Tuples are immutable; you cannot change elements after creation.\n\n**A3:**\nResult is `8`. Casting `int(8.99)` truncates the decimal part; it does not round.\n\n**A4:**\nOrder of operations: `not` -> `and` -> `or`.\n1. `not False` -> `True`\n2. `True and False` -> `False`\n3. `False or True` -> `True`\nFinal Answer: `True`\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/01_Arithmetic.md", "title": "01 Arithmetic", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/01_Arithmetic.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Arithmetic Operators\n\n## Definition\nArithmetic operators are used with numeric values to perform common mathematical operations.\n\n## List of Operators\n\n| Operator | Name | Description | Example |\n| :--- | :--- | :--- | :--- |\n| `+` | Addition | Adds two values. | `x + y` |\n| `-` | Subtraction | Subtracts right operand from left. | `x - y` |\n| `*` | Multiplication | Multiplies two values. | `x * y` |\n| `/` | Division | Divides left by right (always returns float). | `x / y` |\n| `%` | Modulus | Returns the remainder of division. | `x % y` |\n| `**` | Exponentiation | Raises left operand to power of right. | `x ** y` |\n| `//` | Floor Division | Divides and rounds down to nearest integer. | `x // y` |\n\n## Code Examples\n\n```python\na = 10\nb = 3\n\nprint(a + b)   # 13\nprint(a - b)   # 7\nprint(a * b)   # 30\nprint(a / b)   # 3.3333333333333335 (Float division)\nprint(a // b)  # 3 (Floor division - truncates decimal)\nprint(a % b)   # 1 (Remainder: 10 = 3*3 + 1)\nprint(a ** b)  # 1000 (10^3)\n```\n\n## Common Uses\n- **Modulus (`%`)**: Checking if a number is even or odd (`x % 2 == 0`).\n- **Floor Division (`//`)**: Determining how many full items fit in a container.\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/02_Comparison_Logical.md", "title": "02 Comparison Logical", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/02_Comparison_Logical.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Comparison and Logical Operators\n\n## 1. Comparison Operators\nComparison operators are used to compare two values. They **always** return a Boolean value (`True` or `False`).\n\n| Operator | Name | Example |\n| :--- | :--- | :--- |\n| `==` | Equal | `x == y` |\n| `!=` | Not Equal | `x != y` |\n| `>` | Greater than | `x > y` |\n| `<` | Less than | `x < y` |\n| `>=` | Greater than or equal to | `x >= y` |\n| `<=` | Less than or equal to | `x <= y` |\n\n### Chained Comparison\nPython supports chained comparisons, which is a unique feature.\n```python\nx = 5\nprint(1 < x < 10)  # True (Equivalent to: 1 < x and x < 10)\n```\n\n## 2. Logical Operators\nLogical operators are used to combine conditional statements.\n\n| Operator | Description | Example |\n| :--- | :--- | :--- |\n| `and` | Returns True if both statements are true | `x < 5 and  x < 10` |\n| `or` | Returns True if one of the statements is true | `x < 5 or x < 4` |\n| `not` | Reverse the result, returns False if the result is true | `not(x < 5 and x < 10)` |\n\n### Short-Circuit Evaluation\n- `and`: If the first operand is False, Python doesn't check the second operand; returns False immediately.\n- `or`: If the first operand is True, Python doesn't check the second operand; returns True immediately.\n\n```python\nx = 10\n# 'x > 20' is False, so execution stops there. \n# Safe because 10/0 would raise ZeroDivisionError if evaluated.\nif x > 20 and (10 / 0) == 1:\n    print(\"This won't print\")\nelse:\n    print(\"Safe\")\n```\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/03_Assignment_Bitwise.md", "title": "03 Assignment Bitwise", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/03_Assignment_Bitwise.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Assignment and Bitwise Operators\n\n## 1. Assignment Operators\nUsed to assign values to variables.\n\n| Operator | Description | Example | Same As |\n| :--- | :--- | :--- | :--- |\n| `=` | Assigns value | `x = 5` | |\n| `+=` | Add AND | `x += 3` | `x = x + 3` |\n| `-=` | Subtract AND | `x -= 3` | `x = x - 3` |\n| `*=` | Multiply AND | `x *= 3` | `x = x * 3` |\n| `/=` | Divide AND | `x /= 3` | `x = x / 3` |\n| `//=` | Floor Div AND | `x //= 3` | `x = x // 3` |\n| `%=` | Modulus AND | `x %= 3` | `x = x % 3` |\n| `**=` | Exponent AND | `x **= 3` | `x = x ** 3` |\n\n## 2. Bitwise Operators\nBitwise operators act on operands as if they were strings of binary digits. They operate bit by bit.\n\n| Operator | Name | Description | Example |\n| :--- | :--- | :--- | :--- |\n| `&` | AND | Sets each bit to 1 if both bits are 1 | `x & y` |\n| `|` | OR | Sets each bit to 1 if one of two bits is 1 | `x | y` |\n| `^` | XOR | Sets each bit to 1 if only one of two bits is 1 | `x ^ y` |\n| `~` | NOT | Inverts all the bits | `~x` |\n| `<<` | Zero fill left shift | Shift left by pushing zeros in from the right | `x << 2` |\n| `>>` | Signed right shift | Shift right by pushing copies of the leftmost bit in from the left | `x >> 2` |\n\n### Example\n```python\nval = 10        # Binary: 1010\nmask = 4        # Binary: 0100\n\nprint(val & mask)  # 0000 -> 0\nprint(val | mask)  # 1110 -> 14\nprint(val >> 1)    # 0101 -> 5\n```\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/04_Membership_Identity.md", "title": "04 Membership Identity", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/04_Membership_Identity.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Membership and Identity Operators\n\n## 1. Membership Operators\nMembership operators are used to test if a sequence is presented in an object.\n\n| Operator | Description | Example |\n| :--- | :--- | :--- |\n| `in` | Returns True if a sequence with the specified value is present in the object | `x in y` |\n| `not in` | Returns True if a sequence with the specified value is NOT present in the object | `x not in y` |\n\n### Examples\n```python\nfruits = [\"apple\", \"banana\"]\n\nprint(\"banana\" in fruits)  # True\nprint(\"pineapple\" not in fruits)  # True\nprint(\"a\" in \"apple\")  # True (Works with strings too)\n```\n\n## 2. Identity Operators\nIdentity operators compare the objects, not if they are equal, but if they are actually the **same object**, with the same memory location.\n\n| Operator | Description | Example |\n| :--- | :--- | :--- |\n| `is` | Returns True if both variables are the same object | `x is y` |\n| `is not` | Returns True if both variables are not the same object | `x is not y` |\n\n### `is` vs `==`\n- `==` compares **value**.\n- `is` compares **identity** (memory address).\n\n```python\nx = [\"apple\", \"banana\"]\ny = [\"apple\", \"banana\"]\nz = x\n\nprint(x is z)  # True (z points to the same object as x)\nprint(x is y)  # False (x and y are two different objects in memory)\nprint(x == y)  # True (x and y have the same content)\n```\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/05_Operator_Precedence.md", "title": "05 Operator Precedence", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/05_Operator_Precedence.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Operator Precedence\n\n## Definition\nOperator precedence describes the order in which operations are performed when there are multiple operators in an expression.\n\n## Precedence Table (Highest to Lowest)\n\n| Level | Operator | Description |\n| :--- | :--- | :--- |\n| 1 | `()` | Parentheses |\n| 2 | `**` | Exponentiation |\n| 3 | `+x`, `-x`, `~x` | Unary plus, Unary minus, Bitwise NOT |\n| 4 | `*`, `/`, `//`, `%` | Multiplication, Division, Floor division, Modulus |\n| 5 | `+`, `-` | Addition, Subtraction |\n| 6 | `<<`, `>>` | Bitwise shift |\n| 7 | `&` | Bitwise AND |\n| 8 | `^` | Bitwise XOR |\n| 9 | `\\|` | Bitwise OR |\n| 10 | `==`, `!=`, `>`, `>=`, `<`, `<=`, `is`, `is not`, `in`, `not in` | Comparisons, Identity, Membership operators |\n| 11 | `not` | Logical NOT |\n| 12 | `and` | Logical AND |\n| 13 | `or` | Logical OR |\n\n## Examples\n\n```python\nresult = 10 + 2 * 3\n# Multiplication (*) is higher than Addition (+)\n# 10 + 6\n# 16\nprint(result)\n\nresult = (10 + 2) * 3\n# Parentheses have the highest precedence\n# 12 * 3\n# 36\nprint(result)\n\n# Right-to-left associativity for Exponentiation\nprint(2 ** 3 ** 2)  # 2 ** (3 ** 2) -> 2 ** 9 -> 512\n```\n\n## Tips\n- When in doubt, use parentheses `()` to ensure the order of operations is what you intend. It improves readability.\n"}, {"id": "Python_Theory/04_Operators_and_Expressions/06_Practice_Questions.md", "title": "06 Practice Questions", "type": "Topic", "path": "Python_Theory/04_Operators_and_Expressions/06_Practice_Questions.md", "breadcrumbs": ["Python Theory", "04 Operators and Expressions"], "content": "# Practice Questions - Operators\n\n## Questions\n\n### Q1: Arithmetic\nCalculate `25 // 4` and `25 % 4`. Explain the results.\n\n### Q2: Logic Check\nWhat is the result of `False or (True and False)`?\n\n### Q3: Identity\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b)\nprint(a is b)\n```\nWhat will the two print statements output?\n\n### Q4: Precedence\nEvaluate: `3 * 1 ** 3`.\n\n### Q5: Membership\nHow do you check if the character \"z\" is NOT present in the string \"Python\"?\n\n---\n\n## Solutions\n\n**A1:**\n- `25 // 4` -> `6` (Integer division, goes in 6 times)\n- `25 % 4` -> `1` (Remainder is 1)\n\n**A2:**\n`False`.\n1. `(True and False)` -> `False`\n2. `False or False` -> `False`\n\n**A3:**\n- `True` (Values are equal)\n- `False` (Different objects in memory). `[1, 2, 3]` creates a new list each time.\n\n**A4:**\n`3`.\nExponentiation (`**`) has higher precedence than multiplication (`*`).\n1. `1 ** 3` -> `1`\n2. `3 * 1` -> `3`\n\n**A5:**\n```python\n\"z\" not in \"Python\"  # Returns True\n```\n"}, {"id": "Python_Theory/05_Control_Flow/01_Conditional_Statements.md", "title": "01 Conditional Statements", "type": "Topic", "path": "Python_Theory/05_Control_Flow/01_Conditional_Statements.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# Conditional Statements (if, elif, else)\n\n## Definition\nConditional statements allow the program to execute certain blocks of code only if specific conditions are met.\n\n## Syntax\n\n```python\nif condition:\n    # Code to execute if condition is True\nelif other_condition:\n    # Code to execute if previous conditions were False and this is True\nelse:\n    # Code to execute if all previous conditions were False\n```\n\n## Important Rules\n1.  **Indentation**: The code block under the `if/elif/else` statement must be indented.\n2.  **Order**: `if` comes first, `elif` is optional (can have multiple), and `else` is optional (must be last).\n3.  **Conditions**: Must evaluate to a Boolean (True/False).\n\n## Examples\n\n### Basic If-Else\n```python\nage = 18\n\nif age >= 18:\n    print(\"You are an adult.\")\nelse:\n    print(\"You are a minor.\")\n```\n\n### Multiple Conditions (Elif)\n```python\nscore = 85\n\nif score >= 90:\n    print(\"Grade: A\")\nelif score >= 80:\n    print(\"Grade: B\")\nelif score >= 70:\n    print(\"Grade: C\")\nelse:\n    print(\"Grade: F\")\n```\n\n### Nested If\nYou can have an `if` statement inside another `if` statement.\n\n```python\nx = 25\n\nif x > 10:\n    print(\"Above 10\")\n    if x > 20:\n        print(\"and also above 20!\")\n```\n\n## Short Hand If (Ternary Operator)\nWrite if-else in a single line.\n`value_if_true if condition else value_if_false`\n\n```python\na = 5\nb = 10\nprint(\"A is greater\") if a > b else print(\"B is greater\")\n```\n"}, {"id": "Python_Theory/05_Control_Flow/02_Loops_For.md", "title": "02 Loops For", "type": "Topic", "path": "Python_Theory/05_Control_Flow/02_Loops_For.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# For Loops\n\n## Definition\nA `for` loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string).\n\n## Syntax\n```python\nfor item in sequence:\n    # Code block to be executed\n```\n\n## The `range()` Function\nOften used with for loops to repeat a block of code a specific number of times.\n- `range(stop)`: 0 to stop-1.\n- `range(start, stop)`: start to stop-1.\n- `range(start, stop, step)`: increment by step.\n\n## Examples\n\n### 1. Iterating over a List\n```python\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor x in fruits:\n    print(x)\n```\n\n### 2. Iterating over a String\n```python\nfor char in \"banana\":\n    print(char)\n```\n\n### 3. Using `range()`\n```python\nfor i in range(5):\n    print(i)\n# Output: 0, 1, 2, 3, 4\n\nfor i in range(2, 6):\n    print(i)\n# Output: 2, 3, 4, 5\n```\n\n### 4. Nested Loops\nA loop inside a loop.\n```python\nadj = [\"red\", \"big\"]\nfruits = [\"apple\", \"banana\"]\n\nfor x in adj:\n    for y in fruits:\n        print(x, y)\n```\n"}, {"id": "Python_Theory/05_Control_Flow/03_Loops_While.md", "title": "03 Loops While", "type": "Topic", "path": "Python_Theory/05_Control_Flow/03_Loops_While.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# While Loops\n\n## Definition\nWith the `while` loop, we can execute a set of statements as long as a condition is true.\n\n## Syntax\n```python\nwhile condition:\n    # Code block\n```\n\n**Warning**: Remember to increment/change the variable used in the condition to avoid an **infinite loop**.\n\n## Examples\n\n### Basic While Loop\n```python\ni = 1\nwhile i < 6:\n    print(i)\n    i += 1  # Important: Increment i\n```\n\n## When to use `while` vs `for`?\n- Use **for loops** when you know exactly how many times you want to loop (e.g., iterating over a list).\n- Use **while loops** when you want to loop until a specific condition is met, and you don't know beforehand how many iterations that will take (e.g., waiting for user input).\n\n## Infinite Loops\nSometimes infinite loops are useful (e.g., servers, game loops), but accidental ones crash programs.\n```python\n# Infinite loop example (Use Ctrl+C to stop)\n# while True:\n#     print(\"This will run forever\")\n```\n"}, {"id": "Python_Theory/05_Control_Flow/04_Loop_Control_Statements.md", "title": "04 Loop Control Statements", "type": "Topic", "path": "Python_Theory/05_Control_Flow/04_Loop_Control_Statements.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# Loop Control Statements (break, continue, pass)\n\nLoop control statements change the execution from its normal sequence.\n\n## 1. Break\nTerminates the loop containing it. Control of the program flows to the statement immediately after the body of the loop.\n\n```python\nfor val in \"string\":\n    if val == \"i\":\n        break\n    print(val)\nprint(\"The end\")\n\n# Output:\n# s\n# t\n# r\n# The end\n```\n\n## 2. Continue\nSkips the rest of the code inside `exclude` the current iteration only. Loop does not terminate but continues on with the next iteration.\n\n```python\nfor val in \"string\":\n    if val == \"i\":\n        continue\n    print(val)\nprint(\"The end\")\n\n# Output:\n# s\n# t\n# r\n# n\n# g\n# The end\n```\n\n## 3. Pass\nThe `pass` statement is a null operation; nothing happens when it executes. It is used as a placeholder.\n\n```python\nfor x in [0, 1, 2]:\n    pass # To be implemented later\n```\n\n## The `else` Clause in Loops\nPython allows `else` at the end of a `for` or `while` loop.\n- The `else` block executes **only if the loop completes normally**.\n- It does **not** execute if the loop was stopped by a `break`.\n\n```python\nfor n in range(5):\n    if n == 10:\n        break\nelse:\n    print(\"Loop completed successfully!\")\n# Output: Loop completed successfully!\n```\n"}, {"id": "Python_Theory/05_Control_Flow/05_Practice_Questions.md", "title": "05 Practice Questions", "type": "Topic", "path": "Python_Theory/05_Control_Flow/05_Practice_Questions.md", "breadcrumbs": ["Python Theory", "05 Control Flow"], "content": "# Practice Questions - Control Flow\n\n## Questions\n\n### Q1: Grading System\nWrite a program that takes a score (0-100) and prints:\n- \"A\" if score > 90\n- \"B\" if score > 80\n- \"C\" if score > 70\n- \"Fail\" otherwise.\n\n### Q2: Sum of Numbers\nWrite a `for` loop to calculate the sum of all numbers from 1 to 100.\n\n### Q3: Pattern Printing\nUse nested loops to print the following pattern:\n```\n*\n**\n***\n****\n*****\n```\n\n### Q4: Finder\nWrite a loop that searches for the number `5` in the list `[1, 9, 3, 5, 7]`. If found, print \"Found!\" and stop the loop.\n\n---\n\n## Solutions\n\n**A1:**\n```python\nscore = 85\nif score > 90:\n    print(\"A\")\nelif score > 80:\n    print(\"B\")\nelif score > 70:\n    print(\"C\")\nelse:\n    print(\"Fail\")\n```\n\n**A2:**\n```python\ntotal = 0\nfor i in range(1, 101):\n    total += i\nprint(total) # 5050\n```\n\n**A3:**\n```python\nfor i in range(1, 6):\n    print(\"*\" * i)\n# OR nested loop way:\n# for i in range(1, 6):\n#    for j in range(i):\n#        print(\"*\", end=\"\")\n#    print()\n```\n\n**A4:**\n```python\nnums = [1, 9, 3, 5, 7]\nfor n in nums:\n    if n == 5:\n        print(\"Found!\")\n        break\n```\n"}, {"id": "Python_Theory/06_Functions/01_Definition_Syntax.md", "title": "01 Definition Syntax", "type": "Topic", "path": "Python_Theory/06_Functions/01_Definition_Syntax.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Functions Definition and Syntax\n\n## Definition\nA **function** is a block of organized, reusable code that is used to perform a single, related action. Functions provide better modularity for your application and a high degree of code reusing.\n\n## Theory\n- **Abstractions**: Functions allow you to abstract logic. Instead of repeating 10 lines of code, you call a function once.\n- **Maintainability**: If you need to change logic, you only change it in one place (the function definition).\n\n## Syntax\n- Defined using the `def` keyword.\n- Function name should follow variable naming conventions (snake_case).\n- Parentheses `()` allow passing parameters.\n- A colon `:` starts the function block.\n- The function body must be indented.\n- An optional `return` statement exits the function, passing back a value.\n\n```python\ndef function_name(parameters):\n    \"\"\"docstring\"\"\"\n    # statement(s)\n    return expression\n```\n\n## First Function Example\n\n```python\n# Definition\ndef say_hello():\n    print(\"Hello from a function\")\n\n# Calling the function\nsay_hello()\n```\n\n## Pass by Object Reference\nPython uses a mechanism known as \"Call by Object Reference\".\n- If you pass an **immutable** object (int, str, tuple), the function cannot modify the original object.\n- If you pass a **mutable** object (list, dict), the function *can* modify the contents of the object.\n"}, {"id": "Python_Theory/06_Functions/02_Parameters_Arguments.md", "title": "02 Parameters Arguments", "type": "Topic", "path": "Python_Theory/06_Functions/02_Parameters_Arguments.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Parameters and Arguments\n\n## Definition\n- **Parameter**: The variable listed inside the parentheses in the function definition.\n- **Argument**: The value that is sent to the function when it is called.\n\n## Types of Arguments\n\n### 1. Positional Arguments\nThe most common type. Arguments must be passed in the correct order.\n\n```python\ndef describe_pet(animal_type, pet_name):\n    print(f\"I have a {animal_type} named {pet_name}.\")\n\ndescribe_pet(\"hamster\", \"Harry\")\n```\n\n### 2. Keyword Arguments\nYou specify the parameter name when calling the function. Order doesn't matter.\n\n```python\ndescribe_pet(pet_name=\"Harry\", animal_type=\"hamster\")\n```\n\n### 3. Default Arguments\nParameters can have default values. If the argument is omitted, the default is used.\n\n```python\ndef describe_pet(pet_name, animal_type=\"dog\"):\n    print(f\"I have a {animal_type} named {pet_name}.\")\n\ndescribe_pet(\"Willie\")         # Uses default \"dog\"\ndescribe_pet(\"Harry\", \"cat\")   # Overrides default\n```\n\n### 4. Arbitrary Arguments (`*args`)\nUsed when you don't know how many arguments will be passed. Receiving a tuple of arguments.\n\n```python\ndef make_pizza(*toppings):\n    print(toppings)\n    for topping in toppings:\n        print(f\"- {topping}\")\n\nmake_pizza(\"pepperoni\")\nmake_pizza(\"mushrooms\", \"green peppers\", \"extra cheese\")\n```\n\n### 5. Arbitrary Keyword Arguments (`**kwargs`)\nUsed when you don't know how many keyword arguments will be passed. Receives a dictionary.\n\n```python\ndef build_profile(first, last, **user_info):\n    user_info['first_name'] = first\n    user_info['last_name'] = last\n    return user_info\n\nuser_profile = build_profile('albert', 'einstein', location='princeton', field='physics')\nprint(user_profile)\n```\n"}, {"id": "Python_Theory/06_Functions/03_Return_Statement.md", "title": "03 Return Statement", "type": "Topic", "path": "Python_Theory/06_Functions/03_Return_Statement.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Return Statement\n\n## Definition\nThe `return` statement is used to exit a function and go back to the place from where it was called.\n\n## Usage\n- **Returning a value**: `return result`\n- **Returning `None`**: If `return` is omitted or used without a value, the function returns `None`.\n- **Exiting early**: `return` can be used to stop function execution based on a condition.\n\n## Multiple Return Values\nPython allows returning multiple values. It effectively packs them into a **tuple**.\n\n```python\ndef get_user():\n    name = \"John\"\n    age = 30\n    return name, age\n\nname, age = get_user()\nprint(name) # John\n```\n\n## Examples\n\n### Basic Return\n```python\ndef add(a, b):\n    return a + b\n\nresult = add(5, 3)\nprint(result) # 8\n```\n\n### Early Exit\n```python\ndef absolute_value(num):\n    if num >= 0:\n        return num\n    return -num\n\nprint(absolute_value(-10)) # 10\n```\n"}, {"id": "Python_Theory/06_Functions/04_Scope_Lifetime.md", "title": "04 Scope Lifetime", "type": "Topic", "path": "Python_Theory/06_Functions/04_Scope_Lifetime.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Scope and Lifetime\n\n## Definition\n- **Scope**: The region of code where a variable is defined and can be accessed.\n- **Lifetime**: How long a variable exists in memory.\n\n## Types of Scope (LEGB Rule)\nPython resolves names using the LEGB rule:\n1.  **L**ocal: Defined inside function/class.\n2.  **E**nclosing: Defined in enclosing functions (nested functions).\n3.  **G**lobal: Defined at the uppermost level.\n4.  **B**uilt-in: Reserved names in Python modules (e.g., `print`, `len`).\n\n## Global vs Local\n\n### Local Scope\nVariables created inside a function are local to it.\n```python\ndef my_func():\n    x = 10  # Local scope\n    print(x)\n\nmy_func()\n# print(x) # NameError: name 'x' is not defined\n```\n\n### Global Scope\nVariables created outside functions are global.\n```python\nx = 100 # Global\n\ndef my_func():\n    print(x) # Access global x\n\nmy_func()\n```\n\n## The `global` Keyword\nTo modify a global variable inside a function, use `global`.\n```python\ncount = 0\n\ndef increment():\n    global count\n    count += 1\n\nincrement()\nprint(count) # 1\n```\n\n## Common Errors\n- **UnboundLocalError**: Trying to modify a global variable inside a function without declaring it global, but treating it like a local variable.\n    ```python\n    x = 10\n    def broken():\n        print(x) # Errors here because Python sees assignment below and thinks x is local\n        x = 5\n    ```\n"}, {"id": "Python_Theory/06_Functions/05_Lambda_Functions.md", "title": "05 Lambda Functions", "type": "Topic", "path": "Python_Theory/06_Functions/05_Lambda_Functions.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Lambda Functions (Anonymous Functions)\n\n## Definition\nA **lambda function** is a small anonymous function.\n- It can take any number of arguments, but can only have **one expression**.\n- It returns the result of the expression automatically.\n\n## Syntax\n```python\nlambda arguments: expression\n```\n\n## Examples\n\n### 1. Basic Usage\n```python\n# A lambda that adds 10 to the argument\nx = lambda a: a + 10\nprint(x(5))  # 15\n```\n\n### 2. Multiple Arguments\n```python\n# Multiply argument a with argument b\nx = lambda a, b: a * b\nprint(x(5, 6))  # 30\n```\n\n## When to Use?\nLambda functions are most useful when used as an **anonymous function inside another function**, especially with higher-order functions like `map()`, `filter()`, and `reduce()`.\n\n### Example with `filter()`\nKeep only even numbers.\n```python\nnums = [1, 5, 4, 6, 8, 11, 3, 12]\n\nevens = list(filter(lambda x: x % 2 == 0, nums))\nprint(evens) # [4, 6, 8, 12]\n```\n\n### Example with `map()`\nDouble every number.\n```python\nnums = [1, 2, 3, 4]\n\ndoubled = list(map(lambda x: x * 2, nums))\nprint(doubled) # [2, 4, 6, 8]\n```\n"}, {"id": "Python_Theory/06_Functions/06_Recursion.md", "title": "06 Recursion", "type": "Topic", "path": "Python_Theory/06_Functions/06_Recursion.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Recursion\n\n## Definition\n**Recursion** is a common mathematical and programming concept. It means that a function **calls itself**.\n\n## Theory\n- **Base Case**: The condition that stops the recursion. Without it, the function calls itself forever (Stack Overflow).\n- **Recursive Case**: The part where the function calls itself with a modified parameter, moving towards the base case.\n\n## Example: Factorial\nFactorial of n (`n!`) is `n * (n-1) * ... * 1`.\n`5! = 5 * 4 * 3 * 2 * 1 = 120`.\n\n```python\ndef factorial(n):\n    # Base Case\n    if n == 1:\n        return 1\n    # Recursive Case\n    else:\n        return n * factorial(n - 1)\n\nprint(factorial(5)) # 120\n```\n\n## Analysis of Execution\n`factorial(5)` calls `5 * factorial(4)`\n    `factorial(4)` calls `4 * factorial(3)`\n        `factorial(3)` calls `3 * factorial(2)`\n            `factorial(2)` calls `2 * factorial(1)`\n                `factorial(1)` returns `1`\n\n## Pros and Cons\n- **Pros**: Code looks clean and elegant for problems like tree traversals, sorting (Merge Sort, Quick Sort).\n- **Cons**: Can be memory-intensive (maintains a stack frame for each call). Python has a recursion limit (usually 1000).\n\n## Common Errors\n- **RecursionError: maximum recursion depth exceeded**: Happens when there is no base case or the base case is unreachable.\n"}, {"id": "Python_Theory/06_Functions/07_Practice_Questions.md", "title": "07 Practice Questions", "type": "Topic", "path": "Python_Theory/06_Functions/07_Practice_Questions.md", "breadcrumbs": ["Python Theory", "06 Functions"], "content": "# Practice Questions - Functions\n\n## Questions\n\n### Q1: Calculator Function\nWrite a function `calculate(a, b, operation)` where `operation` is a string (`add`, `sub`). It should return the result.\n\n### Q2: Lambda Sort\nGiven a list of tuples: `points = [(1, 2), (3, 1), (5, 0)]`.\nuse a lambda function to sort this list by the *second* element of each tuple.\n\n### Q3: Factorial Recursion\nWrite a recursive function that returns the sum of natural numbers up to `n`. `sum(3) -> 3+2+1 = 6`.\n\n### Q4: Default Arguments\nDefine a function `greet(name, msg=\"Good morning!\")`. Call it in two ways: once with just a name, and once with a name and a custom message.\n\n### Q5: Scope Debug\nWhat is the output of this code?\n```python\nx = 10\ndef change():\n    x = 20\nchange()\nprint(x)\n```\n\n---\n\n## Solutions\n\n**A1:**\n```python\ndef calculate(a, b, operation):\n    if operation == \"add\":\n        return a + b\n    elif operation == \"sub\":\n        return a - b\n\nprint(calculate(10, 5, \"add\")) # 15\n```\n\n**A2:**\n```python\npoints = [(1, 2), (3, 1), (5, 0)]\npoints.sort(key=lambda x: x[1])\nprint(points)\n# Output: [(5, 0), (3, 1), (1, 2)]\n```\n\n**A3:**\n```python\ndef sum_n(n):\n    if n == 1:\n        return 1\n    return n + sum_n(n - 1)\n```\n\n**A4:**\n```python\ngreet(\"Alice\")\ngreet(\"Bob\", \"How are you?\")\n```\n\n**A5:**\n`10`. The function `change()` creates a *local* variable `x` and sets it to 20. It does not affect the *global* `x`.\n"}],
    stats: {"files": 70, "topics": 14, "lines_of_code": 792, "last_updated": "2025-12-09 12:55"}
};
console.log("KB Data Loaded", window.KB_DATA.stats);
